
<!-- saved from url=(0075)https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">

<title>Spring AMQP</title><link rel="stylesheet" type="text/css" href="./Spring AMQP_files/manual-singlepage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div lang="en" class="book"><div class="titlepage"><div><div><h1 class="title"><a name="d5e1"></a>Spring AMQP</h1></div><div><div class="authorgroup"><h2>Authors</h2>
<span class="author"><span class="firstname">Mark</span> <span class="surname">Pollack</span></span>
, <span class="author"><span class="firstname">Mark</span> <span class="surname">Fisher</span></span>
, <span class="author"><span class="firstname">Oleg</span> <span class="surname">Zhurakousky</span></span>
, <span class="author"><span class="firstname">Dave</span> <span class="surname">Syer</span></span>
, <span class="author"><span class="firstname">Gary</span> <span class="surname">Russell</span></span>
, <span class="author"><span class="firstname">Gunnar</span> <span class="surname">Hillert</span></span>
, <span class="author"><span class="firstname">Artem</span> <span class="surname">Bilan</span></span>
, <span class="author"><span class="firstname">Stéphane</span> <span class="surname">Nicoll</span></span>
</div></div><div><p class="releaseinfo">1.7.8.RELEASE</p></div><div><p class="copyright">Copyright © 2010-2018 Pivotal Software Inc.</p></div><div><div class="legalnotice"><a name="d5e35" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#d5e35"></a>
<p>
Copies of this document may be made for your own use and for distribution to
others, provided that you do not charge any fee for such copies and further
provided that each copy contains this Copyright Notice, whether distributed in
print or electronically.
</p>
</div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="chapter"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_preface">1. Preface</a></span></dt><dt><span class="chapter"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction">2. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#quick-tour">2.1. Quick Tour for the impatient</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction_2">2.1.1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#compatibility">Compatibility</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_very_very_quick">Very, Very Quick</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_with_xml_configuration">With XML Configuration</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_with_java_configuration">With Java Configuration</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#whats-new">2.2. What’s New</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_changes_in_1_7_since_1_6">2.2.1. Changes in 1.7 Since 1.6</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_amqp_client_library">AMQP Client library</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_log4j2_upgrade">Log4j2 upgrade</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_logback_appender">Logback Appender</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_spring_retry_upgrade">Spring Retry upgrade</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_fasterxml_jackson_upgrade">FasterXML Jackson upgrade</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_junit_rules">JUnit @Rules</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_container_conditional_rollback">Container Conditional Rollback</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_connection_naming_strategy">Connection Naming Strategy</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_listener_container_changes">Listener Container Changes</a></span></dt></dl></dd><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_earlier_releases">2.2.2. Earlier Releases</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_reference">3. Reference</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#amqp">3.1. Using Spring AMQP</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_amqp_abstractions">3.1.1. AMQP Abstractions</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction_3">Introduction</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_message">Message</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_exchange">Exchange</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_queue">Queue</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_binding">Binding</a></span></dt></dl></dd><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#connections">3.1.2. Connection and Resource Management</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction_4">Introduction</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#connection-factory">Configuring the Underlying Client Connection Factory</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbitconnectionfactorybean_and_configuring_ssl">RabbitConnectionFactoryBean and Configuring SSL</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#routing-connection-factory">Routing Connection Factory</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#queue-affinity">Queue Affinity and the LocalizedQueueConnectionFactory</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#cf-pub-conf-ret">Publisher Confirms and Returns</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#channel-close-logging">Logging Channel Close Events</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#runtime-cache-properties">Runtime Cache Properties</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#auto-recovery">RabbitMQ Automatic Connection/Topology recovery</a></span></dt></dl></dd><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#custom-client-props">3.1.3. Adding Custom Client Connection Properties</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#amqp-template">3.1.4. AmqpTemplate</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction_5">Introduction</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#template-retry">Adding Retry Capabilities</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#template-confirms">Publisher Confirms and Returns</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#template-messaging">Messaging integration</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#template-user-id">Validated User Id</a></span></dt></dl></dd><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#sending-messages">3.1.5. Sending messages</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction_6">Introduction</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#message-builder">Message Builder API</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_publisher_returns">Publisher Returns</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#template-batching">Batching</a></span></dt></dl></dd><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#receiving-messages">3.1.6. Receiving messages</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction_7">Introduction</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#polling-consumer">Polling Consumer</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#async-consumer">Asynchronous Consumer</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#de-batching">Batched Messages</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#consumer-events">Consumer Events</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#consumerTags">Consumer Tags</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#async-annotation-driven">Annotation-driven Listener Endpoints</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#threading">Threading and Asynchronous Consumers</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#idle-containers">Detecting Idle Asynchronous Consumers</a></span></dt></dl></dd><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#message-converters">3.1.7. Message Converters</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction_9">Introduction</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#simple-message-converter">SimpleMessageConverter</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#serializer-message-converter">SerializerMessageConverter</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#json-message-converter">Jackson2JsonMessageConverter</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_marshallingmessageconverter">MarshallingMessageConverter</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_contenttypedelegatingmessageconverter">ContentTypeDelegatingMessageConverter</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#java-deserialization">Java Deserialization</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#message-properties-converters">Message Properties Converters</a></span></dt></dl></dd><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#post-processing">3.1.8. Modifying Messages - Compression and More</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#request-reply">3.1.9. Request/Reply Messaging</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction_10">Introduction</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#reply-timeout">Reply Timeout</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#direct-reply-to">RabbitMQ Direct reply-to</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_message_correlation_with_a_reply_queue">Message Correlation With A Reply Queue</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#reply-listener">Reply Listener Container</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#async-template">AsyncRabbitTemplate</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#remoting">Spring Remoting with AMQP</a></span></dt></dl></dd><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#broker-configuration">3.1.10. Configuring the broker</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction_11">Introduction</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#builder-api">Builder API for Queues and Exchanges</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#collection-declaration">Declaring Collections of Exchanges, Queues, Bindings</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#conditional-declaration">Conditional Declaration</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#anonymous-queue">AnonymousQueue</a></span></dt></dl></dd><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#delayed-message-exchange">3.1.11. Delayed Message Exchange</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#management-template">3.1.12. RabbitMQ REST API</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#exception-handling">3.1.13. Exception Handling</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#transactions">3.1.14. Transactions</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction_12">Introduction</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#conditional-rollback">Conditional Rollback</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#transaction-rollback">A note on Rollback of Received Messages</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_using_the_rabbittransactionmanager">Using the RabbitTransactionManager</a></span></dt></dl></dd><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#containerAttributes">3.1.15. Message Listener Container Configuration</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#listener-concurrency">3.1.16. Listener Concurrency</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#exclusive-consumer">3.1.17. Exclusive Consumer</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#listener-queues">3.1.18. Listener Container Queues</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_resilience_recovering_from_errors_and_broker_failures">3.1.19. Resilience: Recovering from Errors and Broker Failures</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction_13">Introduction</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#automatic-declaration">Automatic Declaration of Exchanges, Queues and Bindings</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#retry">Failures in Synchronous Operations and Options for Retry</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#async-listeners">Message Listeners and the Asynchronous Case</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_exception_classification_for_retry">Exception Classification for Retry</a></span></dt></dl></dd><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_debugging">3.1.20. Debugging</a></span></dt></dl></dd><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#logging">3.2. Logging Subsystem AMQP Appenders</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_common_properties">3.2.1. Common properties</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_log4j_appender">3.2.2. Log4j Appender</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_log4j2_appender">3.2.3. Log4j2 Appender</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_logback_appender_2">3.2.4. Logback Appender</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_customizing_the_messages">3.2.5. Customizing the Messages</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_customizing_the_client_properties">3.2.6. Customizing the Client Properties</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_simple_string_properties">Simple String Properties</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_advanced_technique_for_log4j_and_logback">Advanced Technique for Log4j and Logback</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#sample-apps">3.3. Sample Applications</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction_14">3.3.1. Introduction</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_hello_world">3.3.2. Hello World</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction_15">Introduction</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#hello-world-sync">Synchronous Example</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#hello-world-async">Asynchronous Example</a></span></dt></dl></dd><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_stock_trading">3.3.3. Stock Trading</a></span></dt></dl></dd><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#testing">3.4. Testing Support</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction_16">3.4.1. Introduction</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#mockito-answer">3.4.2. Mockito Answer&lt;?&gt; Implementations</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#__rabbitlistenertest_and_rabbitlistenertestharness">3.4.3. @RabbitListenerTest and RabbitListenerTestHarness</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#junit-rules">3.4.4. JUnit @Rules</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_brokerrunning">BrokerRunning</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_longrunningintegrationtest">LongRunningIntegrationTest</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="chapter"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_spring_integration_reference">4. Spring Integration - Reference</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#spring-integration-amqp">4.1. Spring Integration AMQP Support</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#spring-integration-amqp-introduction">4.1.1. Introduction</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_inbound_channel_adapter">4.1.2. Inbound Channel Adapter</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_outbound_channel_adapter">4.1.3. Outbound Channel Adapter</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_inbound_gateway">4.1.4. Inbound Gateway</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_outbound_gateway">4.1.5. Outbound Gateway</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#resources">5. Other Resources</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#further-reading">5.1. Further Reading</a></span></dt></dl></dd><dt><span class="appendix"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_change_history">A. Change History</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_current_release">A.1. Current Release</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#previous-whats-new">A.2. Previous Releases</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_changes_in_1_6_since_1_5">A.2.1. Changes in 1.6 Since 1.5</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_testing_support">Testing Support</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_builder">Builder</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_namespace_changes">Namespace Changes</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_listener_container_changes_2">Listener Container Changes</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_autodeclare_and_rabbitadmins">AutoDeclare and RabbitAdmins</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_amqptemplate_receive_with_timeout">AmqpTemplate: receive with timeout</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_asyncrabbittemplate">AsyncRabbitTemplate</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbittemplate_changes">RabbitTemplate Changes</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_message_properties">Message Properties</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbitadmin_changes">RabbitAdmin Changes</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#__rabbitlistener_changes">@RabbitListener Changes</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_delayed_message_exchange">Delayed Message Exchange</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_exchange_internal_flag">Exchange internal flag</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_cachingconnectionfactory_changes">CachingConnectionFactory Changes</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbitconnectionfactorybean">RabbitConnectionFactoryBean</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_java_deserialization">Java Deserialization</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_json_messageconverter">JSON MessageConverter</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_logging_appenders">Logging Appenders</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbittemplate_changes_2">RabbitTemplate Changes</a></span></dt></dl></dd><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_changes_in_1_5_since_1_4">A.2.2. Changes in 1.5 Since 1.4</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_spring_erlang_is_no_longer_supported">spring-erlang is No Longer Supported</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_cachingconnectionfactory_changes_2">CachingConnectionFactory Changes</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_properties_to_control_container_queue_declaration_behavior">Properties to Control Container Queue Declaration Behavior</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_class_package_change">Class Package Change</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_defaultmessagepropertiesconverter">DefaultMessagePropertiesConverter</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#__rabbitlistener_improvements">@RabbitListener Improvements</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_automatic_exchange_queue_binding_declaration">Automatic Exchange, Queue, Binding Declaration</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbittemplate_changes_3">RabbitTemplate Changes</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_the_rabbitmanagementtemplate">The RabbitManagementTemplate</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_listener_container_bean_names_xml">Listener Container Bean Names (XML)</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_class_level_rabbitlistener">Class-Level @RabbitListener</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_simplemessagelistenercontainer_backoff_support">SimpleMessageListenerContainer: BackOff support</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_channel_close_logging">Channel Close Logging</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_application_events">Application Events</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_consumer_tag_configuration">Consumer Tag Configuration</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_messagelisteneradapter">MessageListenerAdapter</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_localizedqueueconnectionfactory">LocalizedQueueConnectionFactory</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_anonymous_queue_naming">Anonymous Queue Naming</a></span></dt></dl></dd><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_changes_in_1_4_since_1_3">A.2.3. Changes in 1.4 Since 1.3</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#__rabbitlistener_annotation">@RabbitListener Annotation</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbitmessagingtemplate">RabbitMessagingTemplate</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_listener_container_emphasis_missing_queues_fatal_emphasis_attribute">Listener Container <span class="emphasis"><em>Missing Queues Fatal</em></span> Attribute</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbittemplate_emphasis_confirmcallback_emphasis_interface">RabbitTemplate <span class="emphasis"><em>ConfirmCallback</em></span> Interface</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbitconnectionfactorybean_2">RabbitConnectionFactoryBean</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_cachingconnectionfactory">CachingConnectionFactory</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_log_appender">Log Appender</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_listener_queues">Listener Queues</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbittemplate_mandatory_and_connectionfactoryselector_expressions">RabbitTemplate: mandatory and connectionFactorySelector Expressions</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_listeners_and_the_routing_connection_factory">Listeners and the Routing Connection Factory</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbittemplate_recoverycallback_option">RabbitTemplate: RecoveryCallback option</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_messageconversionexception">MessageConversionException</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbitmq_3_4_compatibility">RabbitMQ 3.4 Compatibility</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_contenttypedelegatingmessageconverter_2">ContentTypeDelegatingMessageConverter</a></span></dt></dl></dd><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_changes_in_1_3_since_1_2">A.2.4. Changes in 1.3 Since 1.2</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_listener_concurrency">Listener Concurrency</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_listener_queues_2">Listener Queues</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_consumer_priority">Consumer Priority</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_exclusive_consumer">Exclusive Consumer</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbit_admin">Rabbit Admin</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_direct_exchange_binding">Direct Exchange Binding</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_amqp_template">AMQP Template</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_caching_connection_factory">Caching Connection Factory</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_binding_arguments">Binding Arguments</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_routing_connection_factory">Routing Connection Factory</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_messagebuilder_and_messagepropertiesbuilder">MessageBuilder and MessagePropertiesBuilder</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_retryinterceptorbuilder">RetryInterceptorBuilder</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_republishmessagerecoverer">RepublishMessageRecoverer</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_default_error_handler_since_1_3_2">Default Error Handler (Since 1.3.2)</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_listener_container_missingqueuesfatal_property_since_1_3_5">Listener Container 'missingQueuesFatal` Property (Since 1.3.5)</a></span></dt></dl></dd><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_changes_to_1_2_since_1_1">A.2.5. Changes to 1.2 Since 1.1</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbitmq_version">RabbitMQ Version</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbit_admin_2">Rabbit Admin</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbit_template">Rabbit Template</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_json_message_converters">JSON Message Converters</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_automatic_declaration_of_queues_etc">Automatic Declaration of Queues, etc</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_amqp_remoting">AMQP Remoting</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_requested_heart_beats">Requested Heart Beats</a></span></dt></dl></dd><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_changes_to_1_1_since_1_0">A.2.6. Changes to 1.1 Since 1.0</a></span></dt><dd><dl><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_general">General</a></span></dt><dt><span class="section"><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_amqp_log4j_appender">AMQP Log4j Appender</a></span></dt></dl></dd></dl></dd></dl></dd></dl></div>
<div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="_preface" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_preface"></a>1.&nbsp;Preface</h1></div></div></div>
<p><a name="preface" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#preface"></a>The Spring AMQP project applies core Spring concepts to the development of AMQP-based messaging solutions.
We provide a "template" as a high-level abstraction for sending and receiving messages.
We also provide support for Message-driven POJOs.
These libraries facilitate management of AMQP resources while promoting the use of dependency injection and declarative configuration.
In all of these cases, you will see similarities to the JMS support in the Spring Framework.
For other project-related information visit the Spring AMQP project <a class="ulink" href="https://projects.spring.io/spring-amqp/" target="_top">homepage</a>.</p>
</div>
<div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="_introduction" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction"></a>2.&nbsp;Introduction</h1></div></div></div>
<p>This first part of the reference documentation is a high-level overview of Spring AMQP and the underlying concepts and some code snippets that will get you up and running as quickly as possible.</p>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quick-tour" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#quick-tour"></a>2.1&nbsp;Quick Tour for the impatient</h2></div></div></div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_introduction_2" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction_2"></a>2.1.1&nbsp;Introduction</h3></div></div></div>
<p>This is the 5 minute tour to get started with Spring AMQP.</p>
<p>Prerequisites: install and run the RabbitMQ broker (<a class="ulink" href="https://www.rabbitmq.com/download.html" target="_top">http://www.rabbitmq.com/download.html</a>).
Then grab the spring-rabbit JAR and all its dependencies - the easiest way to do that is to declare a dependency in your build tool, e.g.
for Maven:</p>
<pre class="programlisting"><span class="hl-tag">&lt;dependency&gt;</span>
  <span class="hl-tag">&lt;groupId&gt;</span>org.springframework.amqp<span class="hl-tag">&lt;/groupId&gt;</span>
  <span class="hl-tag">&lt;artifactId&gt;</span>spring-rabbit<span class="hl-tag">&lt;/artifactId&gt;</span>
  <span class="hl-tag">&lt;version&gt;</span>1.7.8.RELEASE<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span></pre>
<p>And for gradle:</p>
<pre class="programlisting">compile <span class="hl-string">'org.springframework.amqp:spring-rabbit:1.7.8.RELEASE'</span></pre>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="compatibility" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#compatibility"></a>Compatibility</h4></div></div></div>
<p>While the default Spring Framework version dependency is 4.3.x, Spring AMQP is generally compatible with earlier
versions of Spring Framework.
Annotation-based listeners and the <code class="literal">RabbitMessagingTemplate</code> require Spring Framework 4.1 or higher, however.</p>
<p>The minimum <code class="literal">amqp-client</code> java client library version is 4.0.0.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_very_very_quick" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_very_very_quick"></a>Very, Very Quick</h4></div></div></div>
<p>Using plain, imperative Java to send and receive a message:</p>
<pre class="programlisting">ConnectionFactory connectionFactory = <span class="hl-keyword">new</span> CachingConnectionFactory();
AmqpAdmin admin = <span class="hl-keyword">new</span> RabbitAdmin(connectionFactory);
admin.declareQueue(<span class="hl-keyword">new</span> Queue(<span class="hl-string">"myqueue"</span>));
AmqpTemplate template = <span class="hl-keyword">new</span> RabbitTemplate(connectionFactory);
template.convertAndSend(<span class="hl-string">"myqueue"</span>, <span class="hl-string">"foo"</span>);
String foo = (String) template.receiveAndConvert(<span class="hl-string">"myqueue"</span>);</pre>
<p>Note that there is a <code class="literal">ConnectionFactory</code> in the native Java Rabbit client as well.
We are using the Spring abstraction in the code above.
We are relying on the default exchange in the broker (since none is specified in the send), and the default binding of all queues to the default exchange by their name (hence we can use the queue name as a routing key in the send).
Those behaviours are defined in the AMQP specification.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_with_xml_configuration" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_with_xml_configuration"></a>With XML Configuration</h4></div></div></div>
<p>The same example as above, but externalizing the resource configuration to XML:</p>
<pre class="programlisting">ApplicationContext context =
    <span class="hl-keyword">new</span> GenericXmlApplicationContext(<span class="hl-string">"classpath:/rabbit-context.xml"</span>);
AmqpTemplate template = context.getBean(AmqpTemplate.<span class="hl-keyword">class</span>);
template.convertAndSend(<span class="hl-string">"myqueue"</span>, <span class="hl-string">"foo"</span>);
String foo = (String) template.receiveAndConvert(<span class="hl-string">"myqueue"</span>);</pre>
<pre class="programlisting"><span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hl-attribute">xmlns:rabbit</span>=<span class="hl-value">"http://www.springframework.org/schema/rabbit"</span>
       <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/rabbit
           http://www.springframework.org/schema/rabbit/spring-rabbit.xsd
           http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;rabbit:connection-factory</span> <span class="hl-attribute">id</span>=<span class="hl-value">"connectionFactory"</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;rabbit:template</span> <span class="hl-attribute">id</span>=<span class="hl-value">"amqpTemplate"</span> <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"connectionFactory"</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;rabbit:admin</span> <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"connectionFactory"</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;rabbit:queue</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myqueue"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>
<p>The <code class="literal">&lt;rabbit:admin/&gt;</code> declaration by default automatically looks for beans of type <code class="literal">Queue</code>, <code class="literal">Exchange</code> and <code class="literal">Binding</code> and declares them to the broker on behalf of the user, hence there is no need to use that bean explicitly in the simple Java driver.
There are plenty of options to configure the properties of the components in the XML schema - you can use auto-complete features of your XML editor to explore them and look at their documentation.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_with_java_configuration" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_with_java_configuration"></a>With Java Configuration</h4></div></div></div>
<p>The same example again with the external configuration in Java:</p>
<pre class="programlisting">ApplicationContext context =
    <span class="hl-keyword">new</span> AnnotationConfigApplicationContext(RabbitConfiguration.<span class="hl-keyword">class</span>);
AmqpTemplate template = context.getBean(AmqpTemplate.<span class="hl-keyword">class</span>);
template.convertAndSend(<span class="hl-string">"myqueue"</span>, <span class="hl-string">"foo"</span>);
String foo = (String) template.receiveAndConvert(<span class="hl-string">"myqueue"</span>);

........

<em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> RabbitConfiguration {

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> ConnectionFactory connectionFactory() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> CachingConnectionFactory(<span class="hl-string">"localhost"</span>);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> AmqpAdmin amqpAdmin() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> RabbitAdmin(connectionFactory());
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> RabbitTemplate rabbitTemplate() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> RabbitTemplate(connectionFactory());
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> Queue myQueue() {
       <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> Queue(<span class="hl-string">"myqueue"</span>);
    }
}</pre>
</div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="whats-new" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#whats-new"></a>2.2&nbsp;What’s New</h2></div></div></div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_changes_in_1_7_since_1_6" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_changes_in_1_7_since_1_6"></a>2.2.1&nbsp;Changes in 1.7 Since 1.6</h3></div></div></div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_amqp_client_library" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_amqp_client_library"></a>AMQP Client library</h4></div></div></div>
<p>Spring AMQP now uses the new 4.0.x version of the <code class="literal">amqp-client</code> library provided by the RabbitMQ team.
This client has auto recovery configured by default; see <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#auto-recovery" title="RabbitMQ Automatic Connection/Topology recovery">the section called “RabbitMQ Automatic Connection/Topology recovery”</a>.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The 4.0.x client enables automatic recovery by default; while compatible with this feature, Spring AMQP has its own recovery mechanisms and the client recovery feature generally isn’t needed.
It is recommended to disable <code class="literal">amqp-client</code> automatic recovery, to avoid getting <code class="literal">AutoRecoverConnectionNotCurrentlyOpenException</code> s when the broker is available, but the connection has not yet recovered.
Starting with <span class="emphasis"><em>version 1.7.1</em></span>, Spring AMQP disables it unless you explicitly create your own RabbitMQ connection factory and provide it to the <code class="literal">CachingConnectionFactory</code>.
RabbitMQ <code class="literal">ConnectionFactory</code> instances created by the <code class="literal">RabbitConnectionFactoryBean</code> will also have the option disabled by default.</p>
</td></tr></tbody></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_log4j2_upgrade" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_log4j2_upgrade"></a>Log4j2 upgrade</h4></div></div></div>
<p>The minimum Log4j2 version (for the <code class="literal">AmqpAppender</code>) is now <code class="literal">2.7</code>.
The framework is no longer compatible with previous versions.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#logging" title="3.2 Logging Subsystem AMQP Appenders">Section&nbsp;3.2, “Logging Subsystem AMQP Appenders”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_logback_appender" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_logback_appender"></a>Logback Appender</h4></div></div></div>
<p>This appender no longer captures caller data (method, line number) by default; it can be re-enabled by setting the <code class="literal">includeCallerData</code> configuration option.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#logging" title="3.2 Logging Subsystem AMQP Appenders">Section&nbsp;3.2, “Logging Subsystem AMQP Appenders”</a> for information about the available log appenders.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_spring_retry_upgrade" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_spring_retry_upgrade"></a>Spring Retry upgrade</h4></div></div></div>
<p>The minimum Spring Retry version is now <code class="literal">1.2</code>.
The framework is no longer compatible with previous versions.</p>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_shutdown_behavior" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_shutdown_behavior"></a>Shutdown Behavior</h5></div></div></div>
<p>You can now set <code class="literal">forceCloseChannel</code> to <code class="literal">true</code> so that, if the container threads do not respond to a shutdown within <code class="literal">shutdownTimeout</code>, the channel(s) will be forced closed,
causing any unacked messages to be requeued.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#containerAttributes" title="3.1.15 Message Listener Container Configuration">Section&nbsp;3.1.15, “Message Listener Container Configuration”</a> for more information.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_fasterxml_jackson_upgrade" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_fasterxml_jackson_upgrade"></a>FasterXML Jackson upgrade</h4></div></div></div>
<p>The minimum Jackson version is now <code class="literal">2.8</code>.
The framework is no longer compatible with previous versions.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_junit_rules" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_junit_rules"></a>JUnit @Rules</h4></div></div></div>
<p>Rules that have up until now been used internally by the framework have now been made available in a separate jar <code class="literal">spring-rabbit-junit</code>.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#junit-rules" title="3.4.4 JUnit @Rules">Section&nbsp;3.4.4, “JUnit @Rules”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_container_conditional_rollback" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_container_conditional_rollback"></a>Container Conditional Rollback</h4></div></div></div>
<p>When using an external transaction manager (e.g. JDBC), rule-based rollback is now supported when providing the container with a transaction attribute.
It is also now more flexible when using a transaction advice.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_connection_naming_strategy" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_connection_naming_strategy"></a>Connection Naming Strategy</h4></div></div></div>
<p>A new <code class="literal">ConnectionNameStrategy</code> is now provided to populate the application-specific identification of the target RabbitMQ connection from the <code class="literal">AbstractConnectionFactory</code>.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#connections" title="3.1.2 Connection and Resource Management">Section&nbsp;3.1.2, “Connection and Resource Management”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_listener_container_changes" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_listener_container_changes"></a>Listener Container Changes</h4></div></div></div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_transaction_rollback_behavior" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_transaction_rollback_behavior"></a>Transaction Rollback behavior</h5></div></div></div>
<p>Message requeue on transaction rollback can now be configured to be consistent, regardless of whether or not a transaction manager is configured.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#transaction-rollback" title="A note on Rollback of Received Messages">the section called “A note on Rollback of Received Messages”</a> for more information.</p>
</div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_earlier_releases" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_earlier_releases"></a>2.2.2&nbsp;Earlier Releases</h3></div></div></div>
<p>See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#previous-whats-new" title="A.2 Previous Releases">Section&nbsp;A.2, “Previous Releases”</a> for changes in previous versions.</p>
</div>
</div>
</div>
<div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="_reference" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_reference"></a>3.&nbsp;Reference</h1></div></div></div>
<p>This part of the reference documentation details the various components that comprise Spring AMQP.
The <a class="link" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#amqp" title="3.1 Using Spring AMQP">main chapter</a> covers the core classes to develop an AMQP application.
This part also includes a chapter about the <a class="link" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#sample-apps" title="3.3 Sample Applications">sample applications</a>.</p>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="amqp" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#amqp"></a>3.1&nbsp;Using Spring AMQP</h2></div></div></div>
<p>In this chapter, we will explore the interfaces and classes that are the essential components for developing applications with Spring AMQP.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_amqp_abstractions" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_amqp_abstractions"></a>3.1.1&nbsp;AMQP Abstractions</h3></div></div></div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_introduction_3" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction_3"></a>Introduction</h4></div></div></div>
<p>Spring AMQP consists of a handful of modules, each represented by a JAR in the distribution.
These modules are: spring-amqp, and spring-rabbit.
The <span class="emphasis"><em>spring-amqp</em></span> module contains the <code class="literal">org.springframework.amqp.core</code> package.
Within that package, you will find the classes that represent the core AMQP "model".
Our intention is to provide generic abstractions that do not rely on any particular AMQP broker implementation or client library.
End user code will be more portable across vendor implementations as it can be developed against the abstraction layer only.
These abstractions are then used implemented by broker-specific modules, such as <span class="emphasis"><em>spring-rabbit</em></span>.
There is currently only a RabbitMQ implementation; however the abstractions have been validated in .NET using Apache Qpid in addition to RabbitMQ.
Since AMQP operates at the protocol level in principle, the RabbitMQ client can be used with any broker that supports the same protocol version, but we do not test any other brokers at present.</p>
<p>The overview here assumes that you are already familiar with the basics of the AMQP specification.
If you are not, then have a look at the resources listed in <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#resources" title="5. Other Resources">Chapter&nbsp;5, <i>Other Resources</i></a></p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_message" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_message"></a>Message</h4></div></div></div>
<p>The 0-9-1 AMQP specification does not define a Message class or interface.
Instead, when performing an operation such as <code class="literal">basicPublish()</code>, the content is passed as a byte-array argument and additional properties are passed in as separate arguments.
Spring AMQP defines a Message class as part of a more general AMQP domain model representation.
The purpose of the Message class is to simply encapsulate the body and properties within a single instance so that the API can in turn be simpler.
The Message class definition is quite straightforward.</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Message {

    <span class="hl-keyword">private</span> <span class="hl-keyword">final</span> MessageProperties messageProperties;

    <span class="hl-keyword">private</span> <span class="hl-keyword">final</span> <span class="hl-keyword">byte</span>[] body;

    <span class="hl-keyword">public</span> Message(<span class="hl-keyword">byte</span>[] body, MessageProperties messageProperties) {
        <span class="hl-keyword">this</span>.body = body;
        <span class="hl-keyword">this</span>.messageProperties = messageProperties;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">byte</span>[] getBody() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.body;
    }

    <span class="hl-keyword">public</span> MessageProperties getMessageProperties() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.messageProperties;
    }
}</pre>
<p>The <code class="literal">MessageProperties</code> interface defines several common properties such as <span class="emphasis"><em>messageId</em></span>, <span class="emphasis"><em>timestamp</em></span>, <span class="emphasis"><em>contentType</em></span>, and several more.
Those properties can also be extended with user-defined <span class="emphasis"><em>headers</em></span> by calling the <code class="literal">setHeader(String
key, Object value)</code> method.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./Spring AMQP_files/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Starting with versions <code class="literal">1.5.7</code>, <code class="literal">1.6.11</code>, <code class="literal">1.7.4</code>, <code class="literal">2.0.0</code>, if a message body is a serialized <code class="literal">Serializable</code> java object, it is no longer deserialized (by default) when performing <code class="literal">toString()</code> operations (such as in log messages).
This is to prevent unsafe deserialization.
By default, only <code class="literal">java.util</code> and <code class="literal">java.lang</code> classes are deserialized.
To revert to the previous behavior, you can add allowable class/package patterns by invoking <code class="literal">Message.addWhiteListPatterns(...)</code>.
A simple <code class="literal">*</code> wildcard is supported, for example <code class="literal">com.foo.*, *.MyClass</code>.
Bodies that cannot be deserialized will be represented by <code class="literal">byte[&lt;size&gt;]</code> in log messages.</p>
</td></tr></tbody></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_exchange" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_exchange"></a>Exchange</h4></div></div></div>
<p>The <code class="literal">Exchange</code> interface represents an AMQP Exchange, which is what a Message Producer sends to.
Each Exchange within a virtual host of a broker will have a unique name as well as a few other properties:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> Exchange {

    String getName();

    String getExchangeType();

    <span class="hl-keyword">boolean</span> isDurable();

    <span class="hl-keyword">boolean</span> isAutoDelete();

    Map&lt;String, Object&gt; getArguments();

}</pre>
<p>As you can see, an Exchange also has a <span class="emphasis"><em>type</em></span> represented by constants defined in <code class="literal">ExchangeTypes</code>.
The basic types are: <code class="literal">Direct</code>, <code class="literal">Topic</code>, <code class="literal">Fanout</code>, and <code class="literal">Headers</code>.
In the core package you will find implementations of the <code class="literal">Exchange</code> interface for each of those types.
The behavior varies across these Exchange types in terms of how they handle bindings to Queues.
For example, a Direct exchange allows for a Queue to be bound by a fixed routing key (often the Queue’s name).
A Topic exchange supports bindings with routing patterns that may include the <span class="emphasis"><em>*</em></span> and <span class="emphasis"><em>#</em></span> wildcards for <span class="emphasis"><em>exactly-one</em></span> and <span class="emphasis"><em>zero-or-more</em></span>, respectively.
The Fanout exchange publishes to all Queues that are bound to it without taking any routing key into consideration.
For much more information about these and the other Exchange types, check out <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#resources" title="5. Other Resources">Chapter&nbsp;5, <i>Other Resources</i></a>.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The AMQP specification also requires that any broker provide a "default" Direct Exchange that has no name.
All Queues that are declared will be bound to that default Exchange with their names as routing keys.
You will learn more about the default Exchange’s usage within Spring AMQP in <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#amqp-template" title="3.1.4 AmqpTemplate">Section&nbsp;3.1.4, “AmqpTemplate”</a>.</p>
</td></tr></tbody></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_queue" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_queue"></a>Queue</h4></div></div></div>
<p>The <code class="literal">Queue</code> class represents the component from which a Message Consumer receives Messages.
Like the various Exchange classes, our implementation is intended to be an abstract representation of this core AMQP type.</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Queue  {

    <span class="hl-keyword">private</span> <span class="hl-keyword">final</span> String name;

    <span class="hl-keyword">private</span> <span class="hl-keyword">volatile</span> <span class="hl-keyword">boolean</span> durable;

    <span class="hl-keyword">private</span> <span class="hl-keyword">volatile</span> <span class="hl-keyword">boolean</span> exclusive;

    <span class="hl-keyword">private</span> <span class="hl-keyword">volatile</span> <span class="hl-keyword">boolean</span> autoDelete;

    <span class="hl-keyword">private</span> <span class="hl-keyword">volatile</span> Map&lt;String, Object&gt; arguments;

    <strong class="hl-tag" style="color: blue">/**
     * The queue is durable, non-exclusive and non auto-delete.
     *
     * @param name the name of the queue.
     */</strong>
    <span class="hl-keyword">public</span> Queue(String name) {
        <span class="hl-keyword">this</span>(name, true, false, false);
    }

    <span class="hl-comment">// Getters and Setters omitted for brevity</span>

}</pre>
<p>Notice that the constructor takes the Queue name.
Depending on the implementation, the admin template may provide methods for generating a uniquely named Queue.
Such Queues can be useful as a "reply-to" address or other <span class="strong"><strong>temporary</strong></span> situations.
For that reason, the <span class="emphasis"><em>exclusive</em></span> and <span class="emphasis"><em>autoDelete</em></span> properties of an auto-generated Queue would both be set to <span class="emphasis"><em>true</em></span>.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>See the section on queues in <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#broker-configuration" title="3.1.10 Configuring the broker">Section&nbsp;3.1.10, “Configuring the broker”</a> for information about declaring queues using namespace support, including queue arguments.</p>
</td></tr></tbody></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_binding" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_binding"></a>Binding</h4></div></div></div>
<p>Given that a producer sends to an Exchange and a consumer receives from a Queue, the bindings that connect Queues to Exchanges are critical for connecting those producers and consumers via messaging.
In Spring AMQP, we define a <code class="literal">Binding</code> class to represent those connections.
Let’s review the basic options for binding Queues to Exchanges.</p>
<p>You can bind a Queue to a DirectExchange with a fixed routing key.</p>
<pre class="programlisting"><span class="hl-keyword">new</span> Binding(someQueue, someDirectExchange, <span class="hl-string">"foo.bar"</span>)</pre>
<p>You can bind a Queue to a TopicExchange with a routing pattern.</p>
<pre class="programlisting"><span class="hl-keyword">new</span> Binding(someQueue, someTopicExchange, <span class="hl-string">"foo.*"</span>)</pre>
<p>You can bind a Queue to a FanoutExchange with no routing key.</p>
<pre class="programlisting"><span class="hl-keyword">new</span> Binding(someQueue, someFanoutExchange)</pre>
<p>We also provide a <code class="literal">BindingBuilder</code> to facilitate a "fluent API" style.</p>
<pre class="programlisting">Binding b = BindingBuilder.bind(someQueue).to(someTopicExchange).with(<span class="hl-string">"foo.*"</span>);</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The BindingBuilder class is shown above for clarity, but this style works well when using a static import for the <span class="emphasis"><em>bind()</em></span> method.</p>
</td></tr></tbody></table></div>
<p>By itself, an instance of the Binding class is just holding the data about a connection.
In other words, it is not an "active" component.
However, as you will see later in <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#broker-configuration" title="3.1.10 Configuring the broker">Section&nbsp;3.1.10, “Configuring the broker”</a>, Binding instances can be used by the <code class="literal">AmqpAdmin</code> class to actually trigger the binding actions on the broker.
Also, as you will see in that same section, the Binding instances can be defined using Spring’s <code class="literal">@Bean</code>-style within <code class="literal">@Configuration</code> classes.
There is also a convenient base class which further simplifies that approach for generating AMQP-related bean definitions and recognizes the Queues, Exchanges, and Bindings so that they will all be declared on the AMQP broker upon application startup.</p>
<p>The <code class="literal">AmqpTemplate</code> is also defined within the core package.
As one of the main components involved in actual AMQP messaging, it is discussed in detail in its own section (see <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#amqp-template" title="3.1.4 AmqpTemplate">Section&nbsp;3.1.4, “AmqpTemplate”</a>).</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="connections" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#connections"></a>3.1.2&nbsp;Connection and Resource Management</h3></div></div></div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_introduction_4" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction_4"></a>Introduction</h4></div></div></div>
<p>Whereas the AMQP model we described in the previous section is generic and applicable to all implementations, when we get into the management of resources, the details are specific to the broker implementation.
Therefore, in this section, we will be focusing on code that exists only within our "spring-rabbit" module since at this point, RabbitMQ is the only supported implementation.</p>
<p>The central component for managing a connection to the RabbitMQ broker is the <code class="literal">ConnectionFactory</code> interface.
The responsibility of a <code class="literal">ConnectionFactory</code> implementation is to provide an instance of <code class="literal">org.springframework.amqp.rabbit.connection.Connection</code> which is a wrapper for <code class="literal">com.rabbitmq.client.Connection</code>.
The only concrete implementation we provide is <code class="literal">CachingConnectionFactory</code> which, by default, establishes a single connection proxy that can be shared by the application.
Sharing of the connection is possible since the "unit of work" for messaging with AMQP is actually a "channel" (in some ways, this is similar to the relationship between a Connection and a Session in JMS).
As you can imagine, the connection instance provides a <code class="literal">createChannel</code> method.
The <code class="literal">CachingConnectionFactory</code> implementation supports caching of those channels, and it maintains separate caches for channels based on whether they are transactional or not.
When creating an instance of <code class="literal">CachingConnectionFactory</code>, the <span class="emphasis"><em>hostname</em></span> can be provided via the constructor.
The <span class="emphasis"><em>username</em></span> and <span class="emphasis"><em>password</em></span> properties should be provided as well.
If you would like to configure the size of the channel cache (the default is 25), you could call the
<code class="literal">setChannelCacheSize()</code> method here as well.</p>
<p>Starting with <span class="emphasis"><em>version 1.3</em></span>, the <code class="literal">CachingConnectionFactory</code> can be configured to cache connections as well as just channels.
In this case, each call to <code class="literal">createConnection()</code> creates a new connection (or retrieves an idle one from the cache).
Closing a connection returns it to the cache (if the cache size has not been reached).
Channels created on such connections are cached too.
The use of separate connections might be useful in some environments, such as consuming from an HA cluster, in
conjunction with a load balancer, to connect to different cluster members.
Set the <code class="literal">cacheMode</code> to <code class="literal">CacheMode.CONNECTION</code>.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>This does not limit the number of connections, it specifies how many idle open connections are allowed.</p>
</td></tr></tbody></table></div>
<p>Starting with <span class="emphasis"><em>version 1.5.5</em></span>, a new property <code class="literal">connectionLimit</code> is provided.
When this is set, it limits the total number of connections allowed.
When set, if the limit is reached, the <code class="literal">channelCheckoutTimeLimit</code> is used to wait for a connection to become idle.
If the time is exceeded, an <code class="literal">AmqpTimeoutException</code> is thrown.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./Spring AMQP_files/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>When the cache mode is <code class="literal">CONNECTION</code>, automatic declaration of queues etc.
(See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#automatic-declaration" title="Automatic Declaration of Exchanges, Queues and Bindings">the section called “Automatic Declaration of Exchanges, Queues and Bindings”</a>) is NOT supported.</p>
<p>Also, at the time of writing, the <code class="literal">rabbitmq-client</code> library creates a fixed thread pool for each connection (5 threads) by default.
When using a large number of connections, you should consider setting a custom <code class="literal">executor</code> on the <code class="literal">CachingConnectionFactory</code>.
Then, the same executor will be used by all connections and its threads can be shared.
The executor’s thread pool should be unbounded, or set appropriately for the expected utilization (usually, at least one thread per connection).
If multiple channels are created on each connection then the pool size will affect the concurrency, so a variable (or simple cached) thread pool executor would be most suitable.</p>
</td></tr></tbody></table></div>
<p>It is important to understand that the cache size is (by default) not a limit, but merely the number of channels that can be cached.
With a cache size of, say, 10, any number of channels can actually be in use.
If more than 10 channels are being used and they are all returned to the cache, 10 will go in the cache; the remainder will be physically closed.</p>
<p>Starting with <span class="emphasis"><em>version 1.6</em></span>, the default channel cache size has been increased from 1 to 25.
In high volume, multi-threaded, environments, a small cache means that channels are created and closed at a high rate.
Increasing the default cache size will avoid this overhead.
You should monitor the channels in use via the RabbitMQ Admin UI and consider increasing the cache size further if you
see many channels being created and closed.
The cache will only grow on-demand (to suit the concurrency requirements of the application) so this change will not
impact existing low-volume applications.</p>
<p>Starting with <span class="emphasis"><em>version 1.4.2</em></span>, the <code class="literal">CachingConnectionFactory</code> has a property <code class="literal">channelCheckoutTimeout</code>.
When this property is greater than zero, the <code class="literal">channelCacheSize</code> becomes a limit on the number of channels that can be created on a connection.
If the limit is reached, calling threads will block until a channel is available or this timeout is reached, in which case a <code class="literal">AmqpTimeoutException</code> is thrown.</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="./Spring AMQP_files/warning.png"></td><th align="left">Warning</th></tr><tr><td align="left" valign="top">
<p>Channels used within the framework (e.g.
<code class="literal">RabbitTemplate</code>) will be reliably returned to the cache.
If you create channels outside of the framework, (e.g.
by accessing the connection(s) directly and invoking <code class="literal">createChannel()</code>), you must return them (by closing) reliably, perhaps in a <code class="literal">finally</code> block, to avoid running out of channels.</p>
</td></tr></tbody></table></div>
<pre class="programlisting">CachingConnectionFactory connectionFactory = <span class="hl-keyword">new</span> CachingConnectionFactory(<span class="hl-string">"somehost"</span>);
connectionFactory.setUsername(<span class="hl-string">"guest"</span>);
connectionFactory.setPassword(<span class="hl-string">"guest"</span>);

Connection connection = connectionFactory.createConnection();</pre>
<p>When using XML, the configuration might look like this:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"connectionFactory"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.amqp.rabbit.connection.CachingConnectionFactory"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"somehost"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"username"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"guest"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"guest"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>There is also a <code class="literal">SingleConnectionFactory</code> implementation which is only available in the unit test code of the framework.
It is simpler than <code class="literal">CachingConnectionFactory</code> since it does not cache channels, but it is not intended for practical usage outside of simple tests due to its lack of performance and resilience.
If you find a need to implement your own <code class="literal">ConnectionFactory</code> for some reason, the <code class="literal">AbstractConnectionFactory</code> base class may provide a nice starting point.</p>
</td></tr></tbody></table></div>
<p>A <code class="literal">ConnectionFactory</code> can be created quickly and conveniently using the rabbit namespace:</p>
<pre class="programlisting"><span class="hl-tag">&lt;rabbit:connection-factory</span> <span class="hl-attribute">id</span>=<span class="hl-value">"connectionFactory"</span><span class="hl-tag">/&gt;</span></pre>
<p>In most cases this will be preferable since the framework can choose the best defaults for you.
The created instance will be a <code class="literal">CachingConnectionFactory</code>.
Keep in mind that the default cache size for channels is 25.
If you want more channels to be cached set a larger value via the <span class="emphasis"><em>channelCacheSize</em></span> property.
In XML it would look like this:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"connectionFactory"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.amqp.rabbit.connection.CachingConnectionFactory"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"somehost"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"username"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"guest"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"guest"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"channelCacheSize"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"50"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>And with the namespace you can just add the <span class="emphasis"><em>channel-cache-size</em></span> attribute:</p>
<pre class="programlisting"><span class="hl-tag">&lt;rabbit:connection-factory</span>
    <span class="hl-attribute">id</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">channel-cache-size</span>=<span class="hl-value">"50"</span><span class="hl-tag">/&gt;</span></pre>
<p>The default cache mode is CHANNEL, but you can configure it to cache connections instead; in this case, we use <code class="literal">connection-cache-size</code>:</p>
<pre class="programlisting"><span class="hl-tag">&lt;rabbit:connection-factory</span>
    <span class="hl-attribute">id</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">cache-mode</span>=<span class="hl-value">"CONNECTION"</span> <span class="hl-attribute">connection-cache-size</span>=<span class="hl-value">"25"</span><span class="hl-tag">/&gt;</span></pre>
<p>Host and port attributes can be provided using the namespace</p>
<pre class="programlisting"><span class="hl-tag">&lt;rabbit:connection-factory</span>
    <span class="hl-attribute">id</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">host</span>=<span class="hl-value">"somehost"</span> <span class="hl-attribute">port</span>=<span class="hl-value">"5672"</span><span class="hl-tag">/&gt;</span></pre>
<p>Alternatively, if running in a clustered environment, use the addresses attribute.</p>
<pre class="programlisting"><span class="hl-tag">&lt;rabbit:connection-factory</span>
    <span class="hl-attribute">id</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">addresses</span>=<span class="hl-value">"host1:5672,host2:5672"</span><span class="hl-tag">/&gt;</span></pre>
<p>Here’s an example with a custom thread factory that prefixes thread names with <code class="literal">rabbitmq-</code>.</p>
<pre class="programlisting"><span class="hl-tag">&lt;rabbit:connection-factory</span> <span class="hl-attribute">id</span>=<span class="hl-value">"multiHost"</span> <span class="hl-attribute">virtual-host</span>=<span class="hl-value">"/bar"</span> <span class="hl-attribute">addresses</span>=<span class="hl-value">"host1:1234,host2,host3:4567"</span>
    <span class="hl-attribute">thread-factory</span>=<span class="hl-value">"tf"</span>
    <span class="hl-attribute">channel-cache-size</span>=<span class="hl-value">"10"</span> <span class="hl-attribute">username</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">password</span>=<span class="hl-value">"password"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"tf"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.scheduling.concurrent.CustomizableThreadFactory"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"rabbitmq-"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>Starting with <span class="emphasis"><em>version 1.7</em></span> a <code class="literal">ConnectionNameStrategy</code> is provided for the injection into the <code class="literal">AbstractionConnectionFactory</code>.
The generated name is used for the application-specific identification of the target RabbitMQ connection.
The connection name is displayed in the management UI if RabbitMQ server supports it.
This value doesn’t have to be unique and cannot be used as a connection identifier e.g. in HTTP API requests.
This value is supposed to be human-readable and is a part of <code class="literal">ClientProperties</code> under <code class="literal">connection_name</code> key.
Can be used as a simple Lambda:</p>
<pre class="programlisting">connectionFactory.setConnectionNameStrategy(connectionFactory -&gt; <span class="hl-string">"MY_CONNECTION"</span>);</pre>
<p>The <code class="literal">ConnectionFactory</code> argument can be used to distinguish target connection names by some logic.
By default a <code class="literal">beanName</code> of the <code class="literal">AbstractConnectionFactory</code> and an internal counter are used to generate <code class="literal">connection_name</code>.
The <code class="literal">&lt;rabbit:connection-factory&gt;</code> namespace component is also supplied with the <code class="literal">connection-name-strategy</code> attribute.</p>
<p>Starting with <span class="emphasis"><em>version 1.7.7</em></span>, an <code class="literal">AmqpResourceNotAvailableException</code> is provided, which is thrown now when <code class="literal">SimpleConnection.createChannel()</code> can’t create a <code class="literal">Channel</code>, for example, because the <code class="literal">channelMax</code> limit is reached and there are no available channels in the cache.
This exception can be used in the <code class="literal">RetryPolicy</code> to recover the operation after some back-off.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="connection-factory" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#connection-factory"></a>Configuring the Underlying Client Connection Factory</h4></div></div></div>
<p>The <code class="literal">CachingConnectionFactory</code> uses an instance of the Rabbit client <code class="literal">ConnectionFactory</code>; a number of configuration properties are passed through (<code class="literal">host, port, userName, password, requestedHeartBeat,
connectionTimeout</code> for example) when setting the equivalent property on the <code class="literal">CachingConnectionFactory</code>.
To set other properties (<code class="literal">clientProperties</code> for example), define an instance of the rabbit factory and provide a reference to it using the appropriate constructor of the <code class="literal">CachingConnectionFactory</code>.
When using the namespace as described above, provide a reference to the configured factory in the <code class="literal">connection-factory</code> attribute.
For convenience, a factory bean is provided to assist in configuring the connection factory in a Spring application context, as discussed in the next section.</p>
<pre class="programlisting"><span class="hl-tag">&lt;rabbit:connection-factory</span>
      <span class="hl-attribute">id</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"rabbitConnectionFactory"</span><span class="hl-tag">/&gt;</span></pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The 4.0.x client enables automatic recovery by default; while compatible with this feature, Spring AMQP has its own recovery mechanisms and the client recovery feature generally isn’t needed.
It is recommended to disable <code class="literal">amqp-client</code> automatic recovery, to avoid getting <code class="literal">AutoRecoverConnectionNotCurrentlyOpenException</code> s when the broker is available, but the connection has not yet recovered.
You may notice this exception, for example, when a <code class="literal">RetryTemplate</code> is configured in a <code class="literal">RabbitTemplate</code>, even when failing over to another broker in a cluster.
Since the auto recovering connection recovers on a timer, the connection may be recovered faster using Spring AMQP’s recovery mechanisms.
Starting with <span class="emphasis"><em>version 1.7.1</em></span>, Spring AMQP disables it unless you explicitly create your own RabbitMQ connection factory and provide it to the <code class="literal">CachingConnectionFactory</code>.
RabbitMQ <code class="literal">ConnectionFactory</code> instances created by the <code class="literal">RabbitConnectionFactoryBean</code> will also have the option disabled by default.</p>
</td></tr></tbody></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_rabbitconnectionfactorybean_and_configuring_ssl" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbitconnectionfactorybean_and_configuring_ssl"></a>RabbitConnectionFactoryBean and Configuring SSL</h4></div></div></div>
<p>Starting with <span class="emphasis"><em>version 1.4</em></span>, a convenient <code class="literal">RabbitConnectionFactoryBean</code> is provided to enable convenient configuration of SSL properties on the underlying client connection factory, using dependency injection.
Other setters simply delegate to the underlying factory.
Previously you had to configure the SSL options programmatically.</p>
<pre class="programlisting"><span class="hl-tag">&lt;rabbit:connection-factory</span> <span class="hl-attribute">id</span>=<span class="hl-value">"rabbitConnectionFactory"</span>
    <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"clientConnectionFactory"</span>
    <span class="hl-attribute">host</span>=<span class="hl-value">"${host}"</span>
    <span class="hl-attribute">port</span>=<span class="hl-value">"${port}"</span>
    <span class="hl-attribute">virtual-host</span>=<span class="hl-value">"${vhost}"</span>
    <span class="hl-attribute">username</span>=<span class="hl-value">"${username}"</span> <span class="hl-attribute">password</span>=<span class="hl-value">"${password}"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"clientConnectionFactory"</span>
        <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.amqp.rabbit.connection.RabbitConnectionFactoryBean"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"useSSL"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"true"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"sslPropertiesLocation"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"file:/secrets/rabbitSSL.properties"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>Refer to the <a class="ulink" href="https://www.rabbitmq.com/ssl.html" target="_top">RabbitMQ Documentation</a> for information about configuring SSL.
Omit the <code class="literal">keyStore</code> and <code class="literal">trustStore</code> configuration to connect over SSL without certificate validation.
Key and trust store configuration can be provided as follows:</p>
<p>The <code class="literal">sslPropertiesLocation</code> property is a Spring <code class="literal">Resource</code> pointing to a properties file containing the following keys:</p>
<pre class="screen">keyStore=file:/secret/keycert.p12
trustStore=file:/secret/trustStore
keyStore.passPhrase=secret
trustStore.passPhrase=secret</pre>
<p>The <code class="literal">keyStore</code> and <code class="literal">truststore</code> are Spring <code class="literal">Resources</code> pointing to the stores.
Typically this properties file will be secured by the operating system with the application having read access.</p>
<p>Starting with Spring AMQP <span class="emphasis"><em>version 1.5</em></span>, these properties can be set directly on the factory bean.
If both discrete properties and <code class="literal">sslPropertiesLocation</code> is provided, properties in the latter will override the
discrete values.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="routing-connection-factory" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#routing-connection-factory"></a>Routing Connection Factory</h4></div></div></div>
<p>Starting with <span class="emphasis"><em>version 1.3</em></span>, the <code class="literal">AbstractRoutingConnectionFactory</code> has been introduced.
This provides a mechanism to configure mappings for several <code class="literal">ConnectionFactories</code> and determine a target <code class="literal">ConnectionFactory</code> by some <code class="literal">lookupKey</code> at runtime.
Typically, the implementation checks a thread-bound context.
For convenience, Spring AMQP provides the <code class="literal">SimpleRoutingConnectionFactory</code>, which gets the current thread-bound <code class="literal">lookupKey</code> from the <code class="literal">SimpleResourceHolder</code>:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"connectionFactory"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.amqp.rabbit.connection.SimpleRoutingConnectionFactory"</span><span class="hl-tag">&gt;</span>
	<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"targetConnectionFactories"</span><span class="hl-tag">&gt;</span>
		<span class="hl-tag">&lt;map&gt;</span>
			<span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"#{connectionFactory1.virtualHost}"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"connectionFactory1"</span><span class="hl-tag">/&gt;</span>
			<span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"#{connectionFactory2.virtualHost}"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"connectionFactory2"</span><span class="hl-tag">/&gt;</span>
		<span class="hl-tag">&lt;/map&gt;</span>
	<span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;rabbit:template</span> <span class="hl-attribute">id</span>=<span class="hl-value">"template"</span> <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"connectionFactory"</span><span class="hl-tag"> /&gt;</span></pre>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyService {

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span class="hl-keyword">private</span> RabbitTemplate rabbitTemplate;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> service(String vHost, String payload) {
        SimpleResourceHolder.bind(rabbitTemplate.getConnectionFactory(), vHost);
        rabbitTemplate.convertAndSend(payload);
        SimpleResourceHolder.unbind(rabbitTemplate.getConnectionFactory());
    }

}</pre>
<p>It is important to unbind the resource after use.
For more information see the JavaDocs of <code class="literal">AbstractRoutingConnectionFactory</code>.</p>
<p>Starting with <span class="emphasis"><em>version 1.4</em></span>, the <code class="literal">RabbitTemplate</code> supports the SpEL <code class="literal">sendConnectionFactorySelectorExpression</code> and <code class="literal">receiveConnectionFactorySelectorExpression</code> properties, which are evaluated on each AMQP protocol interaction operation (<code class="literal">send</code>, <code class="literal">sendAndReceive</code>, <code class="literal">receive</code> or <code class="literal">receiveAndReply</code>), resolving to a <code class="literal">lookupKey</code> value for the provided <code class="literal">AbstractRoutingConnectionFactory</code>.
Bean references, such as <code class="literal">"@vHostResolver.getVHost(#root)"</code> can be used in the expression.
For <code class="literal">send</code> operations, the Message to be sent is the root evaluation object; for <code class="literal">receive</code> operations, the <span class="strong"><strong>queueName</strong></span> is the root evaluation object.</p>
<p>The <span class="strong"><strong>routing</strong></span> algorithm is: If the selector expression is <code class="literal">null</code>, or is evaluated to <code class="literal">null</code>, or the provided <code class="literal">ConnectionFactory</code> isn’t an instance of <code class="literal">AbstractRoutingConnectionFactory</code>, everything works as before, relying on the provided <code class="literal">ConnectionFactory</code> implementation.
The same occurs if the evaluation result isn’t <code class="literal">null</code>, but there is no target <code class="literal">ConnectionFactory</code> for that <code class="literal">lookupKey</code> and the <code class="literal">AbstractRoutingConnectionFactory</code> is configured with <code class="literal">lenientFallback = true</code>.
Of course, in the case of an <code class="literal">AbstractRoutingConnectionFactory</code> it does fallback to its <code class="literal">routing</code> implementation based on <code class="literal">determineCurrentLookupKey()</code>.
But, if <code class="literal">lenientFallback = false</code>, an <code class="literal">IllegalStateException</code> is thrown.</p>
<p>The Namespace support also provides the <code class="literal">send-connection-factory-selector-expression</code> and <code class="literal">receive-connection-factory-selector-expression</code> attributes on the <code class="literal">&lt;rabbit:template&gt;</code> component.</p>
<p>Also starting with <span class="emphasis"><em>version 1.4</em></span>, you can configure a routing connection factory in a listener container.
In that case, the list of queue names is used as the lookup key.
For example, if you configure the container with <code class="literal">setQueueNames("foo", "bar")</code>, the lookup key will be <code class="literal">"[foo,bar]"</code> (no spaces).</p>
<p>Starting with <span class="emphasis"><em>version 1.6.9</em></span> you can add a qualifier to the lookup key using <code class="literal">setLookupKeyQualifier</code> on the listener container.
This would enable, for example, listening to queues with the same name, but in different virtual host (where you would have a connection factory for each).</p>
<p>For example, with lookup key qualifier <code class="literal">foo</code> and a container listening to queue <code class="literal">bar</code>, the lookup key you would register the target connection factory with would be <code class="literal">foo[bar]</code>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="queue-affinity" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#queue-affinity"></a>Queue Affinity and the LocalizedQueueConnectionFactory</h4></div></div></div>
<p>When using HA queues in a cluster, for the best performance, it can be desirable to connect to the physical broker
where the master queue resides.
While the <code class="literal">CachingConnectionFactory</code> can be configured with multiple broker addresses; this is to fail over and the
client will attempt to connect in order.
The <code class="literal">LocalizedQueueConnectionFactory</code> uses the REST API provided by the admin plugin to determine which node the
queue is mastered.
It then creates (or retrieves from a cache) a <code class="literal">CachingConnectionFactory</code> that will connect to just that node.
If the connection fails, the new master node is determined and the consumer connects to it.
The <code class="literal">LocalizedQueueConnectionFactory</code> is configured with a default connection factory, in case the physical location
of the queue cannot be determined, in which case it will connect as normal to the cluster.</p>
<p>The <code class="literal">LocalizedQueueConnectionFactory</code> is a <code class="literal">RoutingConnectionFactory</code> and the <code class="literal">SimpleMessageListenerContainer</code> uses the
queue names as the lookup key as discussed in <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#routing-connection-factory" title="Routing Connection Factory">the section called “Routing Connection Factory”</a> above.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>For this reason (the use of the queue name for the lookup), the <code class="literal">LocalizedQueueConnectionFactory</code> can only be
used if the container is configured to listen to a single queue.</p>
</td></tr></tbody></table></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The RabbitMQ management plugin must be enabled on each node.</p>
</td></tr></tbody></table></div>
<div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Caution"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="./Spring AMQP_files/caution.png"></td><th align="left">Caution</th></tr><tr><td align="left" valign="top">
<p>This connection factory is intended for long-lived connections, such as those used by the
<code class="literal">SimpleMessageListenerContainer</code>.
It is not intended for short connection use, such as with a <code class="literal">RabbitTemplate</code> because of the overhead of invoking the
REST API before making the connection.
Also, for publish operations, the queue is unknown, and the message is published to all cluster members anyway,
so the logic of looking up the node has little value.</p>
</td></tr></tbody></table></div>
<p>Here is an example configuration, using Spring Boot’s RabbitProperties to configure the factories:</p>
<pre class="programlisting">@Autowired
private RabbitProperties props;

private final String[] adminUris = { "http://host1:15672", "http://host2:15672" };

private final String[] nodes = { "rabbit@host1", "rabbit@host2" };

@Bean
public ConnectionFactory defaultConnectionFactory() {
    CachingConnectionFactory cf = new CachingConnectionFactory();
    cf.setAddresses(this.props.getAddresses());
    cf.setUsername(this.props.getUsername());
    cf.setPassword(this.props.getPassword());
    cf.setVirtualHost(this.props.getVirtualHost());
    return cf;
}

@Bean
public ConnectionFactory queueAffinityCF(
        @Qualifier("defaultConnectionFactory") ConnectionFactory defaultCF) {
    return new LocalizedQueueConnectionFactory(defaultCF,
            StringUtils.commaDelimitedListToStringArray(this.props.getAddresses()),
            this.adminUris, this.nodes,
            this.props.getVirtualHost(), this.props.getUsername(), this.props.getPassword(),
            false, null);
}</pre>
<p>Notice that the first three parameters are arrays of <code class="literal">addresses</code>, <code class="literal">adminUris</code> and <code class="literal">nodes</code>.
These are positional in that when a container attempts to connect to a queue, it determines on which node the queue is
mastered and connects to the address in the same array position.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="cf-pub-conf-ret" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#cf-pub-conf-ret"></a>Publisher Confirms and Returns</h4></div></div></div>
<p>Confirmed and returned messages are supported by setting the <code class="literal">CachingConnectionFactory</code>'s <code class="literal">publisherConfirms</code> and <code class="literal">publisherReturns</code> properties to 'true' respectively.</p>
<p>When these options are set, <code class="literal">Channel</code> s created by the factory are wrapped in an <code class="literal">PublisherCallbackChannel</code>, which is used to facilitate the callbacks.
When such a channel is obtained, the client can register a <code class="literal">PublisherCallbackChannel.Listener</code> with the <code class="literal">Channel</code>.
The <code class="literal">PublisherCallbackChannel</code> implementation contains logic to route a confirm/return to the appropriate listener.
These features are explained further in the following sections.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="./Spring AMQP_files/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>For some more background information, please see the following blog post by the RabbitMQ team titled <a class="ulink" href="https://www.rabbitmq.com/blog/2011/02/10/introducing-publisher-confirms/" target="_top">Introducing Publisher Confirms</a>.</p>
</td></tr></tbody></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="channel-close-logging" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#channel-close-logging"></a>Logging Channel Close Events</h4></div></div></div>
<p>A mechanism to enable users to control logging levels was introduced in <span class="emphasis"><em>version 1.5</em></span>.</p>
<p>The <code class="literal">CachingConnectionFactory</code> uses a default strategy to log channel closures as follows:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Normal channel closes (200 OK) are not logged.
</li><li class="listitem">
If a channel is closed due to a failed passive queue declaration, it is logged at debug level.
</li><li class="listitem">
If a channel is closed because the <code class="literal">basic.consume</code> is refused due to an exclusive consumer condition, it is logged at
INFO level.
</li><li class="listitem">
All others are logged at ERROR level.
</li></ul></div>
<p>To modify this behavior, inject a custom <code class="literal">ConditionalExceptionLogger</code> into the
<code class="literal">CachingConnectionFactory</code> in its <code class="literal">closeExceptionLogger</code> property.</p>
<p>Also see <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#consumer-events" title="Consumer Events">the section called “Consumer Events”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="runtime-cache-properties" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#runtime-cache-properties"></a>Runtime Cache Properties</h4></div></div></div>
<p>Staring with <span class="emphasis"><em>version 1.6</em></span>, the <code class="literal">CachingConnectionFactory</code> now provides cache statistics via the <code class="literal">getCacheProperties()</code>
method.
These statistics can be used to tune the cache to optimize it in production.
For example, the high water marks can be used to determine whether the cache size should be increased.
If it equals the cache size, you might want to consider increasing further.</p>
<div class="table"><a name="d5e526" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#d5e526"></a><p class="title"><b>Table&nbsp;3.1.&nbsp;Cache properties for CacheMode.CHANNEL</b></p><div class="table-contents">
<table summary="Cache properties for CacheMode.CHANNEL" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Property</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Meaning</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">connectionName</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The name of the connection generated by the <code class="literal">ConnectionNameStrategy</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">channelCacheSize</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The currently configured maximum channels that are allowed to be idle.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">localPort</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The local port for the connection (if available).
This can be used to correlate with connections/channels on the RabbitMQ Admin UI.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">idleChannelsTx</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The number of transactional channels that are currently idle (cached).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">idleChannelsNotTx</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The number of non-transactional channels that are currently idle (cached).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">idleChannelsTxHighWater</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The maximum number of transactional channels that have been concurrently idle (cached).</p></td></tr><tr><td style="border-right: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">idleChannelsNotTxHighWater</pre></td><td style="" align="left" valign="top"><p>The maximum number of non-transactional channels have been concurrently idle (cached).</p></td></tr></tbody></table>
</div></div><br class="table-break">
<div class="table"><a name="d5e572" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#d5e572"></a><p class="title"><b>Table&nbsp;3.2.&nbsp;Cache properties for CacheMode.CONNECTION</b></p><div class="table-contents">
<table summary="Cache properties for CacheMode.CONNECTION" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Property</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Meaning</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">connectionName:&lt;localPort&gt;</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The name of the connection generated by the <code class="literal">ConnectionNameStrategy</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">openConnections</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The number of connection objects representing connections to brokers.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">channelCacheSize</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The currently configured maximum channels that are allowed to be idle.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">connectionCacheSize</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The currently configured maximum connections that are allowed to be idle.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">idleConnections</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The number of connections that are currently idle.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">idleConnectionsHighWater</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The maximum number of connections that have been concurrently idle.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">idleChannelsTx:&lt;localPort&gt;</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The number of transactional channels that are currently idle (cached) for this connection.
The localPort part of the property name can be used to correlate with connections/channels on the RabbitMQ Admin UI.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">idleChannelsNotTx:&lt;localPort&gt;</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The number of non-transactional channels that are currently idle (cached) for this connection.
The localPort part of the property name can be used to correlate with connections/channels on the RabbitMQ Admin UI.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">idleChannelsTxHighWater:
&lt;localPort&gt;</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The maximum number of transactional channels that have been concurrently idle (cached).
The localPort part of the property name can be used to correlate with connections/channels on the RabbitMQ Admin UI.</p></td></tr><tr><td style="border-right: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">idleChannelsNotTxHighWater:
&lt;localPort&gt;</pre></td><td style="" align="left" valign="top"><p>The maximum number of non-transactional channels have been concurrently idle (cached).
The localPort part of the property name can be used to correlate with connections/channels on the RabbitMQ Admin UI.</p></td></tr></tbody></table>
</div></div><br class="table-break">
<p>The <code class="literal">cacheMode</code> property (<code class="literal">CHANNEL</code> or <code class="literal">CONNECTION</code> is also included).</p>
<div class="figure"><a name="d5e637" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#d5e637"></a><p class="title"><b>Figure&nbsp;3.1.&nbsp;JVisualVM Example</b></p><div class="figure-contents">
<div class="mediaobject" align="center"><img src="./Spring AMQP_files/cacheStats.png" align="middle" alt="cacheStats"></div>
</div></div><br class="figure-break">
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="auto-recovery" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#auto-recovery"></a>RabbitMQ Automatic Connection/Topology recovery</h4></div></div></div>
<p>Since the first version of Spring AMQP, the framework has provided its own connection and channel recovery in the event of a broker failure.
Also, as discussed in <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#broker-configuration" title="3.1.10 Configuring the broker">Section&nbsp;3.1.10, “Configuring the broker”</a>, the <code class="literal">RabbitAdmin</code> will re-declare any infrastructure beans (queues etc) when the connection is re-established.
It therefore does not rely on the <a class="ulink" href="https://www.rabbitmq.com/api-guide.html#recovery" target="_top">Auto Recovery</a> that is now provided by the <code class="literal">amqp-client</code> library.
Spring AMQP now uses the <code class="literal">4.0.x</code> version of <code class="literal">amqp-client</code>, which has auto recovery enabled by default.
Spring AMQP can still use its own recovery mechanisms if you wish, disabling it in the client, (by setting the <code class="literal">automaticRecoveryEnabled</code> property on the underlying <code class="literal">RabbitMQ connectionFactory</code> to <code class="literal">false</code>).
However, the framework is completely compatible with auto recovery being enabled.
This means any consumers you create within your code (perhaps via <code class="literal">RabbitTemplate.execute()</code>) can be recovered automatically.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="custom-client-props" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#custom-client-props"></a>3.1.3&nbsp;Adding Custom Client Connection Properties</h3></div></div></div>
<p>The <code class="literal">CachingConnectionFactory</code> now allows you to access the underlying connection factory to allow, for example,
setting custom client properties:</p>
<pre class="programlisting">connectionFactory.getRabbitConnectionFactory().getClientProperties().put(<span class="hl-string">"foo"</span>, <span class="hl-string">"bar"</span>);</pre>
<p>These properties appear in the RabbitMQ Admin UI when viewing the connection.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="amqp-template" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#amqp-template"></a>3.1.4&nbsp;AmqpTemplate</h3></div></div></div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_introduction_5" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction_5"></a>Introduction</h4></div></div></div>
<p>As with many other high-level abstractions provided by the Spring Framework and related projects, Spring AMQP provides a "template" that plays a central role.
The interface that defines the main operations is called <code class="literal">AmqpTemplate</code>.
Those operations cover the general behavior for sending and receiving Messages.
In other words, they are not unique to any implementation, hence the "AMQP" in the name.
On the other hand, there are implementations of that interface that are tied to implementations of the AMQP protocol.
Unlike JMS, which is an interface-level API itself, AMQP is a wire-level protocol.
The implementations of that protocol provide their own client libraries, so each implementation of the template interface will depend on a particular client library.
Currently, there is only a single implementation: <code class="literal">RabbitTemplate</code>.
In the examples that follow, you will often see usage of an "AmqpTemplate", but when you look at the configuration examples, or any code excerpts where the template is instantiated and/or setters are invoked, you will see the implementation type (e.g.
"RabbitTemplate").</p>
<p>As mentioned above, the <code class="literal">AmqpTemplate</code> interface defines all of the basic operations for sending and receiving Messages.
We will explore Message sending and reception, respectively, in the two sections that follow.</p>
<p>See also <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#async-template" title="AsyncRabbitTemplate">the section called “AsyncRabbitTemplate”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="template-retry" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#template-retry"></a>Adding Retry Capabilities</h4></div></div></div>
<p>Starting with <span class="emphasis"><em>version 1.3</em></span> you can now configure the <code class="literal">RabbitTemplate</code> to use a <code class="literal">RetryTemplate</code> to help with handling problems with broker connectivity.
Refer to the <a class="ulink" href="https://github.com/spring-projects/spring-retry" target="_top">spring-retry</a> project for complete information; the following is just one example that uses an exponential back off policy and the default <code class="literal">SimpleRetryPolicy</code> which will make three attempts before throwing the exception to the caller.</p>
<p>Using the XML namespace:</p>
<pre class="programlisting"><span class="hl-tag">&lt;rabbit:template</span> <span class="hl-attribute">id</span>=<span class="hl-value">"template"</span> <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">retry-template</span>=<span class="hl-value">"retryTemplate"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"retryTemplate"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.retry.support.RetryTemplate"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"backOffPolicy"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.retry.backoff.ExponentialBackOffPolicy"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"initialInterval"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"500"</span><span class="hl-tag"> /&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"multiplier"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"10.0"</span><span class="hl-tag"> /&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"maxInterval"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"10000"</span><span class="hl-tag"> /&gt;</span>
        <span class="hl-tag">&lt;/bean&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>Using <code class="literal">@Configuration</code>:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> AmqpTemplate rabbitTemplate();
    RabbitTemplate template = <span class="hl-keyword">new</span> RabbitTemplate(connectionFactory());
    RetryTemplate retryTemplate = <span class="hl-keyword">new</span> RetryTemplate();
    ExponentialBackOffPolicy backOffPolicy = <span class="hl-keyword">new</span> ExponentialBackOffPolicy();
    backOffPolicy.setInitialInterval(<span class="hl-number">500</span>);
    backOffPolicy.setMultiplier(<span class="hl-number">10.0</span>);
    backOffPolicy.setMaxInterval(<span class="hl-number">10000</span>);
    retryTemplate.setBackOffPolicy(backOffPolicy);
    template.setRetryTemplate(retryTemplate);
    <span class="hl-keyword">return</span> template;
}</pre>
<p>Starting with <span class="emphasis"><em>version 1.4</em></span>, in addition to the <code class="literal">retryTemplate</code> property, the <code class="literal">recoveryCallback</code> option is supported on the <code class="literal">RabbitTemplate</code>.
It is used as a second argument for the <code class="literal">RetryTemplate.execute(RetryCallback&lt;T, E&gt; retryCallback,
RecoveryCallback&lt;T&gt;recoveryCallback)</code>.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The <code class="literal">RecoveryCallback</code> is somewhat limited in that the retry context only contains the <code class="literal">lastThrowable</code> field.
For more sophisticated use cases, you should use an external <code class="literal">RetryTemplate</code> so that you can convey additional information to the <code class="literal">RecoveryCallback</code> via the context’s attributes:</p>
</td></tr></tbody></table></div>
<pre class="programlisting">retryTemplate.execute(
    <span class="hl-keyword">new</span> RetryCallback&lt;Object, Exception&gt;() {

        <em><span class="hl-annotation" style="color: gray">@Override</span></em>
        <span class="hl-keyword">public</span> Object doWithRetry(RetryContext context) <span class="hl-keyword">throws</span> Exception {
            context.setAttribute(<span class="hl-string">"message"</span>, message);
            <span class="hl-keyword">return</span> rabbitTemplate.convertAndSend(exchange, routingKey, message);
        }
    }, <span class="hl-keyword">new</span> RecoveryCallback&lt;Object&gt;() {

        <em><span class="hl-annotation" style="color: gray">@Override</span></em>
        <span class="hl-keyword">public</span> Object recover(RetryContext context) <span class="hl-keyword">throws</span> Exception {
            Object message = context.getAttribute(<span class="hl-string">"message"</span>);
            Throwable t = context.getLastThrowable();
            <span class="hl-comment">// Do something with message</span>
            <span class="hl-keyword">return</span> null;
        }
    });
}</pre>
<p>In this case, you would <span class="strong"><strong>not</strong></span> inject a <code class="literal">RetryTemplate</code> into the <code class="literal">RabbitTemplate</code>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="template-confirms" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#template-confirms"></a>Publisher Confirms and Returns</h4></div></div></div>
<p>The <code class="literal">RabbitTemplate</code> implementation of <code class="literal">AmqpTemplate</code> supports Publisher Confirms and Returns.</p>
<p>For returned messages, the template’s <code class="literal">mandatory</code> property must be set to <code class="literal">true</code>, or the <code class="literal">mandatory-expression</code>
must evaluate to <code class="literal">true</code> for a particular message.
This feature requires a <code class="literal">CachingConnectionFactory</code> that has its <code class="literal">publisherReturns</code> property set to true (see <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#cf-pub-conf-ret" title="Publisher Confirms and Returns">the section called “Publisher Confirms and Returns”</a>).
Returns are sent to to the client by it registering a <code class="literal">RabbitTemplate.ReturnCallback</code> by calling <code class="literal">setReturnCallback(ReturnCallback callback)</code>.
The callback must implement this method:</p>
<pre class="programlisting"><span class="hl-keyword">void</span> returnedMessage(Message message, <span class="hl-keyword">int</span> replyCode, String replyText,
          String exchange, String routingKey);</pre>
<p>Only one <code class="literal">ReturnCallback</code> is supported by each <code class="literal">RabbitTemplate</code>.
See also <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#reply-timeout" title="Reply Timeout">the section called “Reply Timeout”</a>.</p>
<p>For Publisher Confirms (aka Publisher Acknowledgements), the template requires a <code class="literal">CachingConnectionFactory</code> that has its <code class="literal">publisherConfirms</code> property set to true.
Confirms are sent to to the client by it registering a <code class="literal">RabbitTemplate.ConfirmCallback</code> by calling <code class="literal">setConfirmCallback(ConfirmCallback callback)</code>.
The callback must implement this method:</p>
<pre class="programlisting"><span class="hl-keyword">void</span> confirm(CorrelationData correlationData, <span class="hl-keyword">boolean</span> ack, String cause);</pre>
<p>The <code class="literal">CorrelationData</code> is an object supplied by the client when sending the original message.
The <code class="literal">ack</code> is true for an <code class="literal">ack</code> and false for a <code class="literal">nack</code>.
For <code class="literal">nack</code> s, the cause may contain a reason for the nack, if it is available when the <code class="literal">nack</code> is generated.
An example is when sending a message to a non-existent exchange.
In that case the broker closes the channel; the reason for the closure is included in the <code class="literal">cause</code>.
<code class="literal">cause</code> was added in <span class="emphasis"><em>version 1.4</em></span>.</p>
<p>Only one <code class="literal">ConfirmCallback</code> is supported by a <code class="literal">RabbitTemplate</code>.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>When a rabbit template send operation completes, the channel is closed; this would preclude the reception of confirms or returns in the case when the connection factory cache is full (when there is space in the cache, the channel is not physically closed and the returns/confirms will proceed as normal).
When the cache is full, the framework defers the close for up to 5 seconds, in order to allow time for the confirms/returns to be received.
When using confirms, the channel will be closed when the last confirm is received.
When using only returns, the channel will remain open for the full 5 seconds.
It is generally recommended to set the connection factory’s <code class="literal">channelCacheSize</code> to a large enough value so that the
channel on which a message is published is returned to the cache instead of being closed.
You can monitor channel usage using the RabbitMQ management plugin; if you see channels being opened/closed rapidly you
should consider increasing the cache size to reduce overhead on the server.</p>
</td></tr></tbody></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="template-messaging" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#template-messaging"></a>Messaging integration</h4></div></div></div>
<p>Starting with <span class="emphasis"><em>version 1.4</em></span> <code class="literal">RabbitMessagingTemplate</code>, built on top of <code class="literal">RabbitTemplate</code>, provides an integration with the Spring Framework messaging abstraction, i.e.
<code class="literal">org.springframework.messaging.Message</code>.
This allows you to send and receive messages using the <code class="literal">spring-messaging</code> <code class="literal">Message&lt;?&gt;</code> abstraction.
This abstraction is used by other Spring projects such as Spring Integration and Spring’s STOMP support.
There are two message converters involved; one to convert between a spring-messaging <code class="literal">Message&lt;?&gt;</code> and Spring AMQP’s <code class="literal">Message</code> abstraction, and one to convert between Spring AMQP’s <code class="literal">Message</code> abstraction and the format required by the underlying RabbitMQ client library.
By default, the message payload is converted by the provided <code class="literal">RabbitTemplate</code> 's message converter.
Alternatively, you can inject a custom <code class="literal">MessagingMessageConverter</code> with some other payload converter:</p>
<pre class="programlisting">MessagingMessageConverter amqpMessageConverter = <span class="hl-keyword">new</span> MessagingMessageConverter();
amqpMessageConverter.setPayloadConverter(myPayloadConverter);
rabbitMessagingTemplate.setAmqpMessageConverter(amqpMessageConverter);</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="template-user-id" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#template-user-id"></a>Validated User Id</h4></div></div></div>
<p>Starting with <span class="emphasis"><em>version 1.6</em></span>, the template now supports a <code class="literal">user-id-expression</code> (<code class="literal">userIdExpression</code> when using Java configuration).
If a message is sent, the user id property is set (if not already set) after evaluating this expression.
The root object for the evaluation is the message to be sent.</p>
<p>Examples:</p>
<pre class="programlisting"><span class="hl-tag">&lt;rabbit:template</span> <span class="hl-attribute">...</span> <span class="hl-attribute">user-id-expression</span>=<span class="hl-value">"'guest'"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;rabbit:template</span> <span class="hl-attribute">...</span> <span class="hl-attribute">user-id-expression</span>=<span class="hl-value">"@myConnectionFactory.username"</span><span class="hl-tag"> /&gt;</span></pre>
<p>The first example is a literal expression; the second obtains the <code class="literal">username</code> property from a connection factory bean in the application context.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sending-messages" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#sending-messages"></a>3.1.5&nbsp;Sending messages</h3></div></div></div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_introduction_6" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction_6"></a>Introduction</h4></div></div></div>
<p>When sending a Message, one can use any of the following methods:</p>
<pre class="programlisting"><span class="hl-keyword">void</span> send(Message message) <span class="hl-keyword">throws</span> AmqpException;

<span class="hl-keyword">void</span> send(String routingKey, Message message) <span class="hl-keyword">throws</span> AmqpException;

<span class="hl-keyword">void</span> send(String exchange, String routingKey, Message message) <span class="hl-keyword">throws</span> AmqpException;</pre>
<p>We can begin our discussion with the last method listed above since it is actually the most explicit.
It allows an AMQP Exchange name to be provided at runtime along with a routing key.
The last parameter is the callback that is responsible for actual creating of the Message instance.
An example of using this method to send a Message might look this this:</p>
<pre class="programlisting">amqpTemplate.send(<span class="hl-string">"marketData.topic"</span>, <span class="hl-string">"quotes.nasdaq.FOO"</span>,
    <span class="hl-keyword">new</span> Message(<span class="hl-string">"12.34"</span>.getBytes(), someProperties));</pre>
<p>The "exchange" property can be set on the template itself if you plan to use that template instance to send to the same exchange most or all of the time.
In such cases, the second method listed above may be used instead.
The following example is functionally equivalent to the previous one:</p>
<pre class="programlisting">amqpTemplate.setExchange(<span class="hl-string">"marketData.topic"</span>);
amqpTemplate.send(<span class="hl-string">"quotes.nasdaq.FOO"</span>, <span class="hl-keyword">new</span> Message(<span class="hl-string">"12.34"</span>.getBytes(), someProperties));</pre>
<p>If both the "exchange" and "routingKey" properties are set on the template, then the method accepting only the <code class="literal">Message</code> may be used:</p>
<pre class="programlisting">amqpTemplate.setExchange(<span class="hl-string">"marketData.topic"</span>);
amqpTemplate.setRoutingKey(<span class="hl-string">"quotes.nasdaq.FOO"</span>);
amqpTemplate.send(<span class="hl-keyword">new</span> Message(<span class="hl-string">"12.34"</span>.getBytes(), someProperties));</pre>
<p>A better way of thinking about the exchange and routing key properties is that the explicit method parameters will always override the template’s default values.
In fact, even if you do not explicitly set those properties on the template, there are always default values in place.
In both cases, the default is an empty String, but that is actually a sensible default.
As far as the routing key is concerned, it’s not always necessary in the first place (e.g.
a Fanout Exchange).
Furthermore, a Queue may be bound to an Exchange with an empty String.
Those are both legitimate scenarios for reliance on the default empty String value for the routing key property of the template.
As far as the Exchange name is concerned, the empty String is quite commonly used because the AMQP specification defines the "default Exchange" as having no name.
Since all Queues are automatically bound to that default Exchange (which is a Direct Exchange) using their name as the binding value, that second method above can be used for simple point-to-point Messaging to any Queue through the default Exchange.
Simply provide the queue name as the "routingKey" - either by providing the method parameter at runtime:</p>
<pre class="programlisting">RabbitTemplate template = <span class="hl-keyword">new</span> RabbitTemplate(); <span class="hl-comment">// using default no-name Exchange</span>
template.send(<span class="hl-string">"queue.helloWorld"</span>, <span class="hl-keyword">new</span> Message(<span class="hl-string">"Hello World"</span>.getBytes(), someProperties));</pre>
<p>Or, if you prefer to create a template that will be used for publishing primarily or exclusively to a single Queue, the following is perfectly reasonable:</p>
<pre class="programlisting">RabbitTemplate template = <span class="hl-keyword">new</span> RabbitTemplate(); <span class="hl-comment">// using default no-name Exchange</span>
template.setRoutingKey(<span class="hl-string">"queue.helloWorld"</span>); <span class="hl-comment">// but we'll always send to this Queue</span>
template.send(<span class="hl-keyword">new</span> Message(<span class="hl-string">"Hello World"</span>.getBytes(), someProperties));</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="message-builder" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#message-builder"></a>Message Builder API</h4></div></div></div>
<p>Starting with <span class="emphasis"><em>version 1.3</em></span>, a message builder API is provided by the <code class="literal">MessageBuilder</code> and <code class="literal">MessagePropertiesBuilder</code>; they provides a convenient "fluent" means of creating a message or message properties:</p>
<pre class="programlisting">Message message = MessageBuilder.withBody(<span class="hl-string">"foo"</span>.getBytes())
    .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)
    .setMessageId(<span class="hl-string">"123"</span>)
    .setHeader(<span class="hl-string">"bar"</span>, <span class="hl-string">"baz"</span>)
    .build();</pre>
<p>or</p>
<pre class="programlisting">MessageProperties props = MessagePropertiesBuilder.newInstance()
    .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)
    .setMessageId(<span class="hl-string">"123"</span>)
    .setHeader(<span class="hl-string">"bar"</span>, <span class="hl-string">"baz"</span>)
    .build();
Message message = MessageBuilder.withBody(<span class="hl-string">"foo"</span>.getBytes())
    .andProperties(props)
    .build();</pre>
<p>Each of the properties defined on the <a class="ulink" href="https://docs.spring.io/spring-amqp/docs/latest-ga/api/org/springframework/amqp/core/MessageProperties.html" target="_top">MessageProperties</a> can be set.
Other methods include <code class="literal">setHeader(String key, String value)</code>, <code class="literal">removeHeader(String key)</code>, <code class="literal">removeHeaders()</code>, and <code class="literal">copyProperties(MessageProperties properties)</code>.
Each property setting method has a <code class="literal">set*IfAbsent()</code> variant.
In the cases where a default initial value exists, the method is named <code class="literal">set*IfAbsentOrDefault()</code>.</p>
<p>Five static methods are provided to create an initial message builder:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">static</span> MessageBuilder withBody(<span class="hl-keyword">byte</span>[] body) <a name="CO1-1" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO1-1"></a><span><img src="./Spring AMQP_files/1.png" alt="1" border="0"></span>

<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> MessageBuilder withClonedBody(<span class="hl-keyword">byte</span>[] body) <a name="CO1-2" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO1-2"></a><span><img src="./Spring AMQP_files/2.png" alt="2" border="0"></span>

<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> MessageBuilder withBody(<span class="hl-keyword">byte</span>[] body, <span class="hl-keyword">int</span> from, <span class="hl-keyword">int</span> to) <a name="CO1-3" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO1-3"></a><span><img src="./Spring AMQP_files/3.png" alt="3" border="0"></span>

<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> MessageBuilder fromMessage(Message message) <a name="CO1-4" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO1-4"></a><span><img src="./Spring AMQP_files/4.png" alt="4" border="0"></span>

<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> MessageBuilder fromClonedMessage(Message message) <a name="CO1-5" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO1-5"></a><span><img src="./Spring AMQP_files/5.png" alt="5" border="0"></span></pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr><td width="5%" valign="top" align="left"><p><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO1-1"><span><img src="./Spring AMQP_files/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The message created by the builder will have a body that is a direct reference to the argument.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO1-2"><span><img src="./Spring AMQP_files/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The message created by the builder will have a body that is a new array containing a copy of bytes in the argument.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO1-3"><span><img src="./Spring AMQP_files/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The message created by the builder will have a body that is a new array containing the range of bytes from the argument.
See <code class="literal">Arrays.copyOfRange()</code> for more details.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO1-4"><span><img src="./Spring AMQP_files/4.png" alt="4" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The message created by the builder will have a body that is a direct reference to the body of the argument.
The argument’s properties are copied to a new <code class="literal">MessageProperties</code> object.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO1-5"><span><img src="./Spring AMQP_files/5.png" alt="5" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The message created by the builder will have a body that is a new array containing a copy of the argument’s body.
The argument’s properties are copied to a new <code class="literal">MessageProperties</code> object.</p>
</td></tr></tbody></table></div>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">static</span> MessagePropertiesBuilder newInstance() <a name="CO2-1" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO2-1"></a><span><img src="./Spring AMQP_files/1.png" alt="1" border="0"></span>

<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> MessagePropertiesBuilder fromProperties(MessageProperties properties) <a name="CO2-2" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO2-2"></a><span><img src="./Spring AMQP_files/2.png" alt="2" border="0"></span>

<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> MessagePropertiesBuilder fromClonedProperties(MessageProperties properties) <a name="CO2-3" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO2-3"></a><span><img src="./Spring AMQP_files/3.png" alt="3" border="0"></span></pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr><td width="5%" valign="top" align="left"><p><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO2-1"><span><img src="./Spring AMQP_files/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p>A new message properties object is initialized with default values.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO2-2"><span><img src="./Spring AMQP_files/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The builder is initialized with, and <code class="literal">build()</code> will return, the provided properties object.,</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO2-3"><span><img src="./Spring AMQP_files/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The argument’s properties are copied to a new <code class="literal">MessageProperties</code> object.</p>
</td></tr></tbody></table></div>
<p>With the <code class="literal">RabbitTemplate</code> implementation of <code class="literal">AmqpTemplate</code>, each of the <code class="literal">send()</code> methods has an overloaded version that takes an additional <code class="literal">CorrelationData</code> object.
When publisher confirms are enabled, this object is returned in the callback described in <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#amqp-template" title="3.1.4 AmqpTemplate">Section&nbsp;3.1.4, “AmqpTemplate”</a>.
This allows the sender to correlate a confirm (ack or nack) with the sent message.</p>
<p>Starting with <span class="emphasis"><em>version 1.6.7</em></span>, the <code class="literal">CorrelationAwareMessagePostProcessor</code> interface was introduced, allowing the correlation data to be modified after the message has been converted:</p>
<pre class="programlisting">Message postProcessMessage(Message message, Correlation correlation);</pre>
<p>Also starting with <span class="emphasis"><em>version 1.6.7</em></span> a new callback interface is provided <code class="literal">CorrelationDataPostProcessor</code>; this is invoked after all <code class="literal">MessagePostProcessor</code> s (provided in the <code class="literal">send()</code> method as well as those provided in <code class="literal">setBeforePublishPostProcessors()</code>).
Implementations can update or replace the correlation data supplied in the <code class="literal">send()</code> method (if any).
The <code class="literal">Message</code> and original <code class="literal">CorrelationData</code> (if any) are provided as arguments.</p>
<pre class="programlisting">CorrelationData postProcess(Message message, CorrelationData correlationData);</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_publisher_returns" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_publisher_returns"></a>Publisher Returns</h4></div></div></div>
<p>When the template’s <code class="literal">mandatory</code> property is <span class="emphasis"><em>true</em></span> returned messages are provided by the callback described in <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#amqp-template" title="3.1.4 AmqpTemplate">Section&nbsp;3.1.4, “AmqpTemplate”</a>.</p>
<p>Starting with <span class="emphasis"><em>version 1.4</em></span> the <code class="literal">RabbitTemplate</code> supports the SpEL <code class="literal">mandatoryExpression</code> property, which is evaluated against each request message, as the root evaluation object, resolving to a <code class="literal">boolean</code> value.
Bean references, such as <code class="literal">"@myBean.isMandatory(#root)"</code> can be used in the expression.</p>
<p>Publisher returns can also be used internally by the <code class="literal">RabbitTemplate</code> in send and receive operations.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#reply-timeout" title="Reply Timeout">the section called “Reply Timeout”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="template-batching" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#template-batching"></a>Batching</h4></div></div></div>
<p>Starting with <span class="emphasis"><em>version 1.4.2</em></span>, the <code class="literal">BatchingRabbitTemplate</code> has been introduced.
This is a subclass of <code class="literal">RabbitTemplate</code> with an overridden <code class="literal">send</code> method that batches messages according to the
<code class="literal">BatchingStrategy</code>; only when a batch is complete is the message sent to RabbitMQ.</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> BatchingStrategy {

	MessageBatch addToBatch(String exchange, String routingKey, Message message);

	Date nextRelease();

	Collection&lt;MessageBatch&gt; releaseBatches();

}</pre>
<div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Caution"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="./Spring AMQP_files/caution.png"></td><th align="left">Caution</th></tr><tr><td align="left" valign="top">
<p>Batched data is held in memory; unsent messages can be lost in the event of a system failure.</p>
</td></tr></tbody></table></div>
<p>A <code class="literal">SimpleBatchingStrategy</code> is provided.
It supports sending messages to a single exchange/routing key. It has properties:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">batchSize</code> - the number of messages in a batch before it is sent
</li><li class="listitem">
<code class="literal">bufferLimit</code> - the maximum size of the batched message; this will preempt the <code class="literal">batchSize</code> if exceeded, and cause a partial batch to be sent
</li><li class="listitem">
<code class="literal">timeout</code> - a time after which a partial batch will be sent when there is no new activity adding messages to the batch
</li></ul></div>
<p>The <code class="literal">SimpleBatchingStrategy</code> formats the batch by preceding each embedded message with a 4 byte binary length.
This is communicated to the receiving system by setting the <code class="literal">springBatchFormat</code> message property to <code class="literal">lengthHeader4</code>.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./Spring AMQP_files/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Batched messages are automatically de-batched by listener containers (using the <code class="literal">springBatchFormat</code> message header). Rejecting any message from a batch will cause the entire batch to be rejected.</p>
</td></tr></tbody></table></div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="receiving-messages" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#receiving-messages"></a>3.1.6&nbsp;Receiving messages</h3></div></div></div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_introduction_7" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction_7"></a>Introduction</h4></div></div></div>
<p>Message reception is always a little more complicated than sending.
There are two ways to receive a <code class="literal">Message</code>.
The simpler option is to poll for a single <code class="literal">Message</code> at a time with a polling method call.
The more complicated yet more common approach is to register a listener that will receive <code class="literal">Messages</code> on-demand, asynchronously.
We will look at an example of each approach in the next two sub-sections.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="polling-consumer" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#polling-consumer"></a>Polling Consumer</h4></div></div></div>
<p>The <code class="literal">AmqpTemplate</code> itself can be used for polled Message reception.
By default, if no message is available, <code class="literal">null</code> is returned immediately; there is no blocking.
Starting with <span class="emphasis"><em>version 1.5</em></span>, you can now set a <code class="literal">receiveTimeout</code>, in milliseconds, and the receive methods will block for
up to that long, waiting for a message.
A value less than zero means block indefinitely (or at least until the
connection to the broker is lost).
<span class="emphasis"><em>Version 1.6</em></span> introduced variants of the <code class="literal">receive</code> methods allowing the timeout to be passed in on each call.</p>
<div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Caution"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="./Spring AMQP_files/caution.png"></td><th align="left">Caution</th></tr><tr><td align="left" valign="top">
<p>Since the receive operation creates a new <code class="literal">QueueingConsumer</code> for each message, this technique is not really
appropriate for high-volume environments; consider using an asynchronous consumer, or a <code class="literal">receiveTimeout</code> of zero for
those use cases.</p>
</td></tr></tbody></table></div>
<p>There are four simple <span class="emphasis"><em>receive</em></span> methods available.
As with the Exchange on the sending side, there is a method that requires a default queue property having been set
directly on the template itself, and there is a method that accepts a queue parameter at runtime.
<span class="emphasis"><em>Version 1.6</em></span> introduced variants to accept <code class="literal">timeoutMillis</code> to override <code class="literal">receiveTimeout</code> on a per-request basis.</p>
<pre class="programlisting">Message receive() <span class="hl-keyword">throws</span> AmqpException;

Message receive(String queueName) <span class="hl-keyword">throws</span> AmqpException;

Message receive(<span class="hl-keyword">long</span> timeoutMillis) <span class="hl-keyword">throws</span> AmqpException;

Message receive(String queueName, <span class="hl-keyword">long</span> timeoutMillis) <span class="hl-keyword">throws</span> AmqpException;</pre>
<p>Just like in the case of sending messages, the <code class="literal">AmqpTemplate</code> has some convenience methods for receiving POJOs instead of <code class="literal">Message</code> instances, and implementations will provide a way to customize the <code class="literal">MessageConverter</code> used to create the <code class="literal">Object</code> returned:</p>
<pre class="programlisting">Object receiveAndConvert() <span class="hl-keyword">throws</span> AmqpException;

Object receiveAndConvert(String queueName) <span class="hl-keyword">throws</span> AmqpException;

Message receiveAndConvert(<span class="hl-keyword">long</span> timeoutMillis) <span class="hl-keyword">throws</span> AmqpException;

Message receiveAndConvert(String queueName, <span class="hl-keyword">long</span> timeoutMillis) <span class="hl-keyword">throws</span> AmqpException;</pre>
<p>Similar to <code class="literal">sendAndReceive</code> methods, beginning with <span class="emphasis"><em>version 1.3</em></span>, the <code class="literal">AmqpTemplate</code> has several convenience <code class="literal">receiveAndReply</code> methods for synchronously receiving, processing and replying to messages:</p>
<pre class="programlisting">&lt;R, S&gt; <span class="hl-keyword">boolean</span> receiveAndReply(ReceiveAndReplyCallback&lt;R, S&gt; callback)
	   <span class="hl-keyword">throws</span> AmqpException;

&lt;R, S&gt; <span class="hl-keyword">boolean</span> receiveAndReply(String queueName, ReceiveAndReplyCallback&lt;R, S&gt; callback)
 	<span class="hl-keyword">throws</span> AmqpException;

&lt;R, S&gt; <span class="hl-keyword">boolean</span> receiveAndReply(ReceiveAndReplyCallback&lt;R, S&gt; callback,
	String replyExchange, String replyRoutingKey) <span class="hl-keyword">throws</span> AmqpException;

&lt;R, S&gt; <span class="hl-keyword">boolean</span> receiveAndReply(String queueName, ReceiveAndReplyCallback&lt;R, S&gt; callback,
	String replyExchange, String replyRoutingKey) <span class="hl-keyword">throws</span> AmqpException;

&lt;R, S&gt; <span class="hl-keyword">boolean</span> receiveAndReply(ReceiveAndReplyCallback&lt;R, S&gt; callback,
 	ReplyToAddressCallback&lt;S&gt; replyToAddressCallback) <span class="hl-keyword">throws</span> AmqpException;

&lt;R, S&gt; <span class="hl-keyword">boolean</span> receiveAndReply(String queueName, ReceiveAndReplyCallback&lt;R, S&gt; callback,
			ReplyToAddressCallback&lt;S&gt; replyToAddressCallback) <span class="hl-keyword">throws</span> AmqpException;</pre>
<p>The <code class="literal">AmqpTemplate</code> implementation takes care of the <span class="emphasis"><em>receive</em></span> and <span class="emphasis"><em>reply</em></span> phases.
In most cases you should provide only an implementation of <code class="literal">ReceiveAndReplyCallback</code> to perform some business logic for the received message and build a reply object or message, if needed.
Note, a <code class="literal">ReceiveAndReplyCallback</code> may return <code class="literal">null</code>.
In this case no reply is sent and <code class="literal">receiveAndReply</code> works like the <code class="literal">receive</code> method.
This allows the same queue to be used for a mixture of messages, some of which may not need a reply.</p>
<p>Automatic message (request and reply) conversion is applied only if the provided callback is not an instance of <code class="literal">ReceiveAndReplyMessageCallback</code> - which provides a raw message exchange contract.</p>
<p>The <code class="literal">ReplyToAddressCallback</code> is useful for cases requiring custom logic to determine the <code class="literal">replyTo</code> address at runtime against the received message and reply from the <code class="literal">ReceiveAndReplyCallback</code>.
By default, <code class="literal">replyTo</code> information in the request message is used to route the reply.</p>
<p>The following is an example of POJO-based receive and reply…&#8203;</p>
<pre class="programlisting"><span class="hl-keyword">boolean</span> received =
        <span class="hl-keyword">this</span>.template.receiveAndReply(ROUTE, <span class="hl-keyword">new</span> ReceiveAndReplyCallback&lt;Order, Invoice&gt;() {

                <span class="hl-keyword">public</span> Invoice handle(Order order) {
                        <span class="hl-keyword">return</span> processOrder(order);
                }
        });
<span class="hl-keyword">if</span> (received) {
        log.info(<span class="hl-string">"We received an order!"</span>);
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="async-consumer" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#async-consumer"></a>Asynchronous Consumer</h4></div></div></div>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./Spring AMQP_files/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Spring AMQP also supports annotated-listener endpoints through the use of the <code class="literal">@RabbitListener</code> annotation and provides an open infrastructure to register endpoints programmatically.
This is by far the most convenient way to setup an asynchronous consumer, see <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#async-annotation-driven" title="Annotation-driven Listener Endpoints">the section called “Annotation-driven Listener Endpoints”</a> for more details.</p>
</td></tr></tbody></table></div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_message_listener" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_message_listener"></a>Message Listener</h5></div></div></div>
<p>For asynchronous Message reception, a dedicated component (not the <code class="literal">AmqpTemplate</code>) is involved.
That component is a container for a Message consuming callback.
We will look at the container and its properties in just a moment, but first we should look at the callback since that is where your application code will be integrated with the messaging system.
There are a few options for the callback starting with an implementation of the <code class="literal">MessageListener</code> interface:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> MessageListener {
    <span class="hl-keyword">void</span> onMessage(Message message);
}</pre>
<p>If your callback logic depends upon the AMQP Channel instance for any reason, you may instead use the <code class="literal">ChannelAwareMessageListener</code>.
It looks similar but with an extra parameter:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> ChannelAwareMessageListener {
    <span class="hl-keyword">void</span> onMessage(Message message, Channel channel) <span class="hl-keyword">throws</span> Exception;
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="message-listener-adapter" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#message-listener-adapter"></a>MessageListenerAdapter</h5></div></div></div>
<p>If you prefer to maintain a stricter separation between your application logic and the messaging API, you can rely upon an adapter implementation that is provided by the framework.
This is often referred to as "Message-driven POJO" support.
When using the adapter, you only need to provide a reference to the instance that the adapter itself should invoke.</p>
<pre class="programlisting">MessageListenerAdapter listener = <span class="hl-keyword">new</span> MessageListenerAdapter(somePojo);
    listener.setDefaultListenerMethod(<span class="hl-string">"myMethod"</span>);</pre>
<p>You can subclass the adapter and provide an implementation of <code class="literal">getListenerMethodName()</code> to dynamically select different methods based on the message.
This method has two parameters, the <code class="literal">originalMessage</code> and <code class="literal">extractedMessage</code>, the latter being the result of any conversion.
By default, a <code class="literal">SimpleMessageConverter</code> is configured; see <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#simple-message-converter" title="SimpleMessageConverter">the section called “SimpleMessageConverter”</a> for more information and
information about other converters available.</p>
<p>Starting with <span class="emphasis"><em>version 1.4.2</em></span>, the original message has properties <code class="literal">consumerQueue</code> and <code class="literal">consumerTag</code> which can be used
to determine which queue a message was received from.</p>
<p>Starting with <span class="emphasis"><em>version 1.5</em></span>, you can configure a map of consumer queue/tag to method name, to dynamically select the
method to call.
If no entry is in the map, we fall back to the default listener method.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_container" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_container"></a>Container</h5></div></div></div>
<p>Now that you’ve seen the various options for the Message-listening callback, we can turn our attention to the container.
Basically, the container handles the "active" responsibilities so that the listener callback can remain passive.
The container is an example of a "lifecycle" component.
It provides methods for starting and stopping.
When configuring the container, you are essentially bridging the gap between an AMQP Queue and the <code class="literal">MessageListener</code> instance.
You must provide a reference to the <code class="literal">ConnectionFactory</code> and the queue name or Queue instance(s) from which that listener should consume Messages.
Here is the most basic example using the default implementation, <code class="literal">SimpleMessageListenerContainer</code> :</p>
<pre class="programlisting">SimpleMessageListenerContainer container = <span class="hl-keyword">new</span> SimpleMessageListenerContainer();
container.setConnectionFactory(rabbitConnectionFactory);
container.setQueueNames(<span class="hl-string">"some.queue"</span>);
container.setMessageListener(<span class="hl-keyword">new</span> MessageListenerAdapter(somePojo));</pre>
<p>As an "active" component, it’s most common to create the listener container with a bean definition so that it can simply run in the background.
This can be done via XML:</p>
<pre class="programlisting"><span class="hl-tag">&lt;rabbit:listener-container</span> <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"rabbitConnectionFactory"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;rabbit:listener</span> <span class="hl-attribute">queues</span>=<span class="hl-value">"some.queue"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"somePojo"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"handle"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/rabbit:listener-container&gt;</span></pre>
<p>Or, you may prefer to use the @Configuration style which will look very similar to the actual code snippet above:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ExampleAmqpConfiguration {

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> SimpleMessageListenerContainer messageListenerContainer() {
        SimpleMessageListenerContainer container = <span class="hl-keyword">new</span> SimpleMessageListenerContainer();
        container.setConnectionFactory(rabbitConnectionFactory());
        container.setQueueName(<span class="hl-string">"some.queue"</span>);
        container.setMessageListener(exampleListener());
        <span class="hl-keyword">return</span> container;
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> ConnectionFactory rabbitConnectionFactory() {
        CachingConnectionFactory connectionFactory =
            <span class="hl-keyword">new</span> CachingConnectionFactory(<span class="hl-string">"localhost"</span>);
        connectionFactory.setUsername(<span class="hl-string">"guest"</span>);
        connectionFactory.setPassword(<span class="hl-string">"guest"</span>);
        <span class="hl-keyword">return</span> connectionFactory;
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> MessageListener exampleListener() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> MessageListener() {
            <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> onMessage(Message message) {
                System.out.println(<span class="hl-string">"received: "</span> + message);
            }
        };
    }
}</pre>
<p><a name="consumer-priority" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#consumer-priority"></a>Starting with <span class="strong"><strong>RabbitMQ Version 3.2</strong></span>, the broker now supports consumer priority (see <a class="ulink" href="https://www.rabbitmq.com/blog/2013/12/16/using-consumer-priorities-with-rabbitmq/" target="_top">Using Consumer Priorities with RabbitMQ</a>).
This is enabled by setting the <code class="literal">x-priority</code> argument on the consumer.
The <code class="literal">SimpleMessageListenerContainer</code> now supports setting consumer arguments:</p>
<pre class="programlisting">container.setConsumerArguments(Collections.
&lt;String, Object&gt; singletonMap(<span class="hl-string">"x-priority"</span>, Integer.valueOf(<span class="hl-number">10</span>)));</pre>
<p>For convenience, the namespace provides the <code class="literal">priority</code> attribute on the <code class="literal">listener</code> element:</p>
<pre class="programlisting"><span class="hl-tag">&lt;rabbit:listener-container</span> <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"rabbitConnectionFactory"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;rabbit:listener</span> <span class="hl-attribute">queues</span>=<span class="hl-value">"some.queue"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"somePojo"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"handle"</span> <span class="hl-attribute">priority</span>=<span class="hl-value">"10"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/rabbit:listener-container&gt;</span></pre>
<p>Starting with <span class="emphasis"><em>version 1.3</em></span> the queue(s) on which the container is listening can be modified at runtime; see <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#listener-queues" title="3.1.18 Listener Container Queues">Section&nbsp;3.1.18, “Listener Container Queues”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="lc-auto-delete" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#lc-auto-delete"></a><span class="emphasis"><em>auto-delete</em></span> Queues</h5></div></div></div>
<p>When a container is configured to listen to <code class="literal">auto-delete</code> queue(s), or the queue has an <code class="literal">x-expires</code> option or the <a class="ulink" href="https://www.rabbitmq.com/ttl.html" target="_top">Time-To-Live</a> policy is configured on the Broker, the queue is removed by the broker when the container is stopped (last consumer is cancelled).
Before <span class="emphasis"><em>version 1.3</em></span>, the container could not be restarted because the queue was missing; the <code class="literal">RabbitAdmin</code> only automatically redeclares queues etc, when the connection is closed/opens, which does not happen when the container is stopped/started.</p>
<p>Starting with <span class="emphasis"><em>version 1.3</em></span>, the container will now use a <code class="literal">RabbitAdmin</code> to redeclare any missing queues during startup.</p>
<p>You can also use conditional declaration (<a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#conditional-declaration" title="Conditional Declaration">the section called “Conditional Declaration”</a>) together with an <code class="literal">auto-startup="false"</code> admin to defer queue declaration until the container is started.</p>
<pre class="programlisting"><span class="hl-tag">&lt;rabbit:queue</span> <span class="hl-attribute">id</span>=<span class="hl-value">"otherAnon"</span> <span class="hl-attribute">declared-by</span>=<span class="hl-value">"containerAdmin"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;rabbit:direct-exchange</span> <span class="hl-attribute">name</span>=<span class="hl-value">"otherExchange"</span> <span class="hl-attribute">auto-delete</span>=<span class="hl-value">"true"</span> <span class="hl-attribute">declared-by</span>=<span class="hl-value">"containerAdmin"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;rabbit:bindings&gt;</span>
        <span class="hl-tag">&lt;rabbit:binding</span> <span class="hl-attribute">queue</span>=<span class="hl-value">"otherAnon"</span> <span class="hl-attribute">key</span>=<span class="hl-value">"otherAnon"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/rabbit:bindings&gt;</span>
<span class="hl-tag">&lt;/rabbit:direct-exchange&gt;</span>

<span class="hl-tag">&lt;rabbit:listener-container</span> <span class="hl-attribute">id</span>=<span class="hl-value">"container2"</span> <span class="hl-attribute">auto-startup</span>=<span class="hl-value">"false"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;rabbit:listener</span> <span class="hl-attribute">id</span>=<span class="hl-value">"listener2"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"foo"</span> <span class="hl-attribute">queues</span>=<span class="hl-value">"otherAnon"</span> <span class="hl-attribute">admin</span>=<span class="hl-value">"containerAdmin"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/rabbit:listener-container&gt;</span>

<span class="hl-tag">&lt;rabbit:admin</span> <span class="hl-attribute">id</span>=<span class="hl-value">"containerAdmin"</span> <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"rabbitConnectionFactory"</span>
    <span class="hl-attribute">auto-startup</span>=<span class="hl-value">"false"</span><span class="hl-tag"> /&gt;</span></pre>
<p>In this case, the queue and exchange are declared by <code class="literal">containerAdmin</code> which has <code class="literal">auto-startup="false"</code> so the elements are not declared during context initialization.
Also, the container is not started for the same reason.
When the container is later started, it uses it’s reference to <code class="literal">containerAdmin</code> to declare the elements.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="de-batching" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#de-batching"></a>Batched Messages</h4></div></div></div>
<p>Batched messages are automatically de-batched by listener containers (using the <code class="literal">springBatchFormat</code> message header). Rejecting any message from a batch will cause the entire batch to be rejected.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#template-batching" title="Batching">the section called “Batching”</a> for more information about batching.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="consumer-events" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#consumer-events"></a>Consumer Events</h4></div></div></div>
<p>Starting with <span class="emphasis"><em>version 1.5</em></span>, the <code class="literal">SimpleMessageListenerContainer</code> publishes application events whenever a listener
(consumer) experiences a failure of some kind.
The event <code class="literal">ListenerContainerConsumerFailedEvent</code> has the following properties:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">container</code> - the listener container where the consumer experienced the problem.
</li><li class="listitem">
<code class="literal">reason</code> - a textual reason for the failure.
</li><li class="listitem">
<code class="literal">fatal</code> - a boolean indicating whether the failure was fatal; with non-fatal exceptions, the container will attempt
to restart the consumer, according to the <code class="literal">retryInterval</code>.
</li><li class="listitem">
<code class="literal">throwable</code> - the <code class="literal">Throwable</code> that was caught.
</li></ul></div>
<p>These events can be consumed by implementing <code class="literal">ApplicationListener&lt;ListenerContainerConsumerFailedEvent&gt;</code>.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>System-wide events (such as connection failures) will be published by all consumers when <code class="literal">concurrentConsumers</code>
is greater than 1.</p>
</td></tr></tbody></table></div>
<p>If a consumer fails because one if its queues is being used exclusively, by default, as well as publishing the
event, a <code class="literal">WARN</code> log is issued. To change this logging behavior, provide a custom <code class="literal">ConditionalExceptionLogger</code> in the
<code class="literal">SimpleMessageListenerContainer</code> 's <code class="literal">exclusiveConsumerExceptionLogger</code> property.
See also <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#channel-close-logging" title="Logging Channel Close Events">the section called “Logging Channel Close Events”</a>.</p>
<p>Fatal errors are always logged at <code class="literal">ERROR</code> level; this it not modifiable.</p>
<p>Several other events are published at various stages of the container lifecycle:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">AsyncConsumerStartedEvent</code> (when the consumer is started)
</li><li class="listitem">
<code class="literal">AsyncConsumerRestartedEvent</code> (when the consumer is restarted after a failure - <code class="literal">SimpleMessageListenerContainer</code> only)
</li><li class="listitem">
<code class="literal">AsyncConsumerTerminatedEvent</code> (when a consumer is stopped normally)
</li><li class="listitem">
<code class="literal">AsyncConsumerStoppedEvent</code> (when the consumer is stopped - <code class="literal">SimpleMessageListenerContainer</code> only)
</li><li class="listitem">
<code class="literal">ConsumeOkEvent</code> (when a <code class="literal">consumeOk</code> is received from the broker, contains the queue name and <code class="literal">consumerTag</code>)
</li><li class="listitem">
<code class="literal">ListenerContainerIdleEvent</code> (see <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#idle-containers" title="Detecting Idle Asynchronous Consumers">the section called “Detecting Idle Asynchronous Consumers”</a>)
</li></ul></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="consumerTags" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#consumerTags"></a>Consumer Tags</h4></div></div></div>
<p>Starting with <span class="emphasis"><em>version 1.4.5</em></span>, you can now provide a strategy to generate consumer tags.
By default, the consumer tag will be generated by the broker.</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> ConsumerTagStrategy {

    String createConsumerTag(String queue);

}</pre>
<p>The queue is made available so it can (optionally) be used in the tag.</p>
<p>See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#containerAttributes" title="3.1.15 Message Listener Container Configuration">Section&nbsp;3.1.15, “Message Listener Container Configuration”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="async-annotation-driven" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#async-annotation-driven"></a>Annotation-driven Listener Endpoints</h4></div></div></div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_introduction_8" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction_8"></a>Introduction</h5></div></div></div>
<p>Starting with <span class="emphasis"><em>version 1.4</em></span>, the easiest way to receive a message asynchronously is to use the annotated listener endpoint infrastructure.
In a nutshell, it allows you to expose a method of a managed bean as a Rabbit listener endpoint.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Component</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyService {

    <em><span class="hl-annotation" style="color: gray">@RabbitListener(queues = "myQueue")</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> processOrder(String data) {
        ...
    }

}</pre>
<p>The idea of the example above is that, whenever a message is available on the <code class="literal">org.springframework.amqp.core.Queue</code> "myQueue", the <code class="literal">processOrder</code> method is invoked accordingly (in this case, with the payload of the message).</p>
<p>The annotated endpoint infrastructure creates a message listener container behind the scenes for each annotated method, using a <code class="literal">RabbitListenerContainerFactory</code>.</p>
<p>In the example above, <code class="literal">myQueue</code> must already exist and be bound to some exchange.
Starting with <span class="emphasis"><em>version 1.5.0</em></span>, the queue can be declared and bound automatically, as long as a <code class="literal">RabbitAdmin</code> exists
in the application context.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Property placeholders (<code class="literal">${some.property}</code>) or SpEL expressions (<code class="literal">#{someExpression}</code>) can be specified for the annotation properties (<code class="literal">queues</code> etc).
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#annotation-multiple-queues" title="Listening to Multiple Queues">the section called “Listening to Multiple Queues”</a> for an example of why you might use SpEL instead of a property placeholder.</p>
</td></tr></tbody></table></div>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Component</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyService {

  <em><span class="hl-annotation" style="color: gray">@RabbitListener(bindings = @QueueBinding(
        value = @Queue(value = "myQueue", durable = "true"),
        exchange = @Exchange(value = "auto.exch", ignoreDeclarationExceptions = "true"),
        key = "orderRoutingKey")
  )</span></em>
  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> processOrder(String data) {
    ...
  }

  <em><span class="hl-annotation" style="color: gray">@RabbitListener(bindings = @QueueBinding(
        value = @Queue,
        exchange = @Exchange(value = "auto.exch"),
        key = "invoiceRoutingKey")
  )</span></em>
  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> processInvoice(String data) {
    ...
  }

}</pre>
<p>In the first example, a queue <code class="literal">myQueue</code> will be declared automatically (durable) together with the exchange, if needed,
and bound to the exchange with the routing key.
In the second example, an anonymous (exclusive, auto-delete) queue will be declared and bound.
Multiple <code class="literal">QueueBinding</code> entries can be provided, allowing the listener to listen to multiple queues.</p>
<p>Only DIRECT, FANOUT, TOPIC and HEADERS, exchange types are supported with this mechanism.
Use normal <code class="literal">@Bean</code> definitions when more advanced configuration is required.</p>
<p>Notice <code class="literal">ignoreDeclarationExceptions</code> on the exchange in the first example.
This allows, for example, binding to an existing exchange that might have different settings (such as <code class="literal">internal</code>).
By default the properties of an existing exchange must match.</p>
<p>Starting with <span class="emphasis"><em>version 1.6</em></span>, you can now specify arguments within <code class="literal">@QueueBinding</code> annotations for queues, exchanges
and bindings. For example:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RabbitListener(bindings = @QueueBinding(
        value = @Queue(value = "auto.headers", autoDelete = "true",
                        arguments = @Argument(name = "x-message-ttl", value = "10000",
                                                type = "java.lang.Integer")),
        exchange = @Exchange(value = "auto.headers", type = ExchangeTypes.HEADERS, autoDelete = "true"),
        arguments = {
                @Argument(name = "x-match", value = "all"),
                @Argument(name = "foo", value = "bar"),
                @Argument(name = "baz")
        })
)</span></em>
<span class="hl-keyword">public</span> String handleWithHeadersExchange(String foo) {
    ...
}</pre>
<p>Notice that the <code class="literal">x-message-ttl</code> argument is set to 10 seconds for the queue.
Since the argument type is not <code class="literal">String</code>, we have to specify its type; in this case <code class="literal">Integer</code>.
As with all such declarations, if the queue exists already, the arguments must match those on the queue.
For the header exchange, we set the binding arguments to match messages that have the header <code class="literal">foo</code> set to <code class="literal">bar</code> and
the header <code class="literal">baz</code> must be present with any value.
The <code class="literal">x-match</code> argument means both conditions must be satisfied.</p>
<p>The argument name, value, and type can be property placeholders (<code class="literal">${...}</code>) or SpEL expressions (<code class="literal">#{...}</code>).
The <code class="literal">name</code> must resolve to a <code class="literal">String</code>; the expression for <code class="literal">type</code> must resolve to a <code class="literal">Class</code> or the fully-qualified name of
a class.
The <code class="literal">value</code> must resolve to something that can be converted by the <code class="literal">DefaultConversionService</code> to the type (such as
the <code class="literal">x-message-ttl</code> in the above example).</p>
<p>If a name resolves to <code class="literal">null</code> or an empty <code class="literal">String</code>, that <code class="literal">@Argument</code> is ignored.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="meta-annotation-driven" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#meta-annotation-driven"></a>Meta-Annotations</h5></div></div></div>
<p>Sometimes you may want to use the same configuration for multiple listeners.
To reduce the boilerplate configuration, you can use meta-annotations to create your own listener annotation:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Target({ElementType.TYPE, ElementType.METHOD, ElementType.ANNOTATION_TYPE})</span></em>
<em><span class="hl-annotation" style="color: gray">@Retention(RetentionPolicy.RUNTIME)</span></em>
<em><span class="hl-annotation" style="color: gray">@RabbitListener(bindings = @QueueBinding(
        value = @Queue,
        exchange = @Exchange(value = "metaFanout", type = ExchangeTypes.FANOUT)))</span></em>
<span class="hl-keyword">public</span> <em><span class="hl-annotation" style="color: gray">@interface</span></em> MyAnonFanoutListener {
}

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MetaListener {

    <em><span class="hl-annotation" style="color: gray">@MyAnonFanoutListener</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> handle1(String foo) {
        ...
    }

    <em><span class="hl-annotation" style="color: gray">@MyAnonFanoutListener</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> handle2(String foo) {
        ...
    }

}</pre>
<p>In this example, each listener created by the <code class="literal">@MyAnonFanoutListener</code> annotation will bind an anonymous, auto-delete
queue to the fanout exchange <code class="literal">metaFanout</code>.
The meta-annotation mechanism is simple in that attributes on the user-defined annotation are <span class="strong"><strong>not</strong></span> examined - so
you can’t override settings from the meta-annotation.
Use normal <code class="literal">@Bean</code> definitions when more advanced configuration is required.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="async-annotation-driven-enable" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#async-annotation-driven-enable"></a>Enable Listener Endpoint Annotations</h5></div></div></div>
<p>To enable support for <code class="literal">@RabbitListener</code> annotations add <code class="literal">@EnableRabbit</code> to one of your <code class="literal">@Configuration</code> classes.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableRabbit</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AppConfig {

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory() {
        SimpleRabbitListenerContainerFactory factory = <span class="hl-keyword">new</span> SimpleRabbitListenerContainerFactory();
        factory.setConnectionFactory(connectionFactory());
        factory.setConcurrentConsumers(<span class="hl-number">3</span>);
        factory.setMaxConcurrentConsumers(<span class="hl-number">10</span>);
        <span class="hl-keyword">return</span> factory;
    }
}</pre>
<p>By default, the infrastructure looks for a bean named <code class="literal">rabbitListenerContainerFactory</code> as the source for the factory to use to create message listener containers.
In this case, and ignoring the RabbitMQ infrastructure setup, the <code class="literal">processOrder</code> method can be invoked with a core poll size of 3 threads and a maximum pool size of 10 threads.</p>
<p>It is possible to customize the listener container factory to use per annotation or an explicit default can be configured by implementing the <code class="literal">RabbitListenerConfigurer</code> interface.
The default is only required if at least one endpoint is registered without a specific container factory.
See the javadoc for full details and examples.</p>
<p>If you prefer XML configuration, use the <code class="literal">&lt;rabbit:annotation-driven&gt;</code> element.</p>
<pre class="programlisting"><span class="hl-tag">&lt;rabbit:annotation-driven/&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"rabbitListenerContainerFactory"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.amqp.rabbit.config.SimpleRabbitListenerContainerFactory"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"connectionFactory"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"concurrentConsumers"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"3"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"maxConcurrentConsumers"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"10"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="async-annotation-conversion" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#async-annotation-conversion"></a>Message Conversion for Annotated Methods</h5></div></div></div>
<p>There are two conversion steps in the pipeline before invoking the listener.
The first uses a <code class="literal">MessageConverter</code> to convert the incoming Spring AMQP <code class="literal">Message</code> to a <span class="emphasis"><em>spring-messaging</em></span> <code class="literal">Message</code>.
When the target method is invoked, the message payload is converted, if necessary, to the method parameter type.</p>
<p>The default <code class="literal">MessageConverter</code> for the first step is a Spring AMQP <code class="literal">SimpleMessageConverter</code> that handles conversion to
<code class="literal">String</code> and <code class="literal">java.io.Serializable</code> objects; all others remain as a <code class="literal">byte[]</code>.
In the following discussion, we call this the <span class="emphasis"><em>message converter</em></span>.</p>
<p>The default converter for the second step is a <code class="literal">GenericMessageConverter</code> which delegates to a conversion service
(an instance of <code class="literal">DefaultFormattingConversionService</code>).
In the following discussion, we call this the <span class="emphasis"><em>method argument converter</em></span>.</p>
<p>To change the <span class="emphasis"><em>message converter</em></span>, simply add it as a property to the container factory bean:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory() {
    SimpleRabbitListenerContainerFactory factory = <span class="hl-keyword">new</span> SimpleRabbitListenerContainerFactory();
    ...
    factory.setMessageConverter(<span class="hl-keyword">new</span> Jackson2JsonMessageConverter());
    ...
    <span class="hl-keyword">return</span> factory;
}</pre>
<p>This configures a Jackson2 converter that expects header information to be present to guide the conversion.</p>
<p>You can also consider a <code class="literal">ContentTypeDelegatingMessageConverter</code> which can handle conversion of different content types.</p>
<p>In most cases, it is not necessary to customize the <span class="emphasis"><em>method argument converter</em></span> unless, for example, you want to use
a custom <code class="literal">ConversionService</code>.</p>
<p>In versions prior to <span class="emphasis"><em>1.6</em></span>, the type information to convert the JSON had to be provided in message headers, or a
custom <code class="literal">ClassMapper</code> was required.
Starting with <span class="emphasis"><em>version 1.6</em></span>, if there are no type information headers, the type can be inferred from the target
method arguments.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>This type inference only works for <code class="literal">@RabbitListener</code> at the method level.</p>
</td></tr></tbody></table></div>
<p>See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#json-message-converter" title="Jackson2JsonMessageConverter">the section called “Jackson2JsonMessageConverter”</a> for more information.</p>
<p>If you wish to customize the <span class="emphasis"><em>method argument converter</em></span>, you can do so as follows:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableRabbit</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AppConfig <span class="hl-keyword">implements</span> RabbitListenerConfigurer {

    ...

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> DefaultMessageHandlerMethodFactory myHandlerMethodFactory() {
        DefaultMessageHandlerMethodFactory factory = <span class="hl-keyword">new</span> DefaultMessageHandlerMethodFactory();
        factory.setMessageConverter(<span class="hl-keyword">new</span> GenericMessageConverter(myConversionService()));
        <span class="hl-keyword">return</span> factory;
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> ConversionService myConversionService() {
        DefaultConversionService conv = <span class="hl-keyword">new</span> DefaultConversionService();
        conv.addConverter(mySpecialConverter());
        <span class="hl-keyword">return</span> conv;
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> configureRabbitListeners(RabbitListenerEndpointRegistrar registrar) {
        registrar.setMessageHandlerMethodFactory(myHandlerMethodFactory());
    }

    ...

}</pre>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./Spring AMQP_files/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>for multi-method listeners (see <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#annotation-method-selection" title="Multi-Method Listeners">the section called “Multi-Method Listeners”</a>), the method selection is based on the
payload of the message <span class="strong"><strong>after the message conversion</strong></span>; the <span class="emphasis"><em>method argument converter</em></span> is only called after the method has
been selected.</p>
</td></tr></tbody></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="async-annotation-driven-registration" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#async-annotation-driven-registration"></a>Programmatic Endpoint Registration</h5></div></div></div>
<p><code class="literal">RabbitListenerEndpoint</code> provides a model of a Rabbit endpoint and is responsible for configuring the container for that model.
The infrastructure allows you to configure endpoints programmatically in addition to the ones that are detected by the <code class="literal">RabbitListener</code> annotation.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableRabbit</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AppConfig <span class="hl-keyword">implements</span> RabbitListenerConfigurer {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> configureRabbitListeners(RabbitListenerEndpointRegistrar registrar) {
        SimpleRabbitListenerEndpoint endpoint = <span class="hl-keyword">new</span> SimpleRabbitListenerEndpoint();
        endpoint.setQueueNames(<span class="hl-string">"anotherQueue"</span>);
        endpoint.setMessageListener(message -&gt; {
            <span class="hl-comment">// processing</span>
        });
        registrar.registerEndpoint(endpoint);
    }
}</pre>
<p>In the example above, we used <code class="literal">SimpleRabbitListenerEndpoint</code> which provides the actual <code class="literal">MessageListener</code> to invoke but you could just as well build your own endpoint variant describing a custom invocation mechanism.</p>
<p>It should be noted that you could just as well skip the use of <code class="literal">@RabbitListener</code> altogether and only register your endpoints programmatically through RabbitListenerConfigurer.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="async-annotation-driven-enable-signature" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#async-annotation-driven-enable-signature"></a>Annotated Endpoint Method Signature</h5></div></div></div>
<p>So far, we have been injecting a simple String in our endpoint but it can actually have a very flexible method signature.
Let’s rewrite it to inject the <code class="literal">Order</code> with a custom header:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Component</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyService {

    <em><span class="hl-annotation" style="color: gray">@RabbitListener(queues = "myQueue")</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> processOrder(Order order, <em><span class="hl-annotation" style="color: gray">@Header("order_type")</span></em> String orderType) {
        ...
    }
}</pre>
<p>These are the main elements you can inject in listener endpoints:</p>
<p>The raw <code class="literal">org.springframework.amqp.core.Message</code>.</p>
<p>The <code class="literal">com.rabbitmq.client.Channel</code> on which the message was received</p>
<p>The <code class="literal">org.springframework.messaging.Message</code> representing the incoming AMQP message.
Note that this message holds both the custom and the standard headers (as defined by <code class="literal">AmqpHeaders</code>).</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Starting with <span class="emphasis"><em>version 1.6</em></span>, the inbound <code class="literal">deliveryMode</code> header is now available in the header with name
<code class="literal">AmqpHeaders.RECEIVED_DELIVERY_MODE</code> instead of <code class="literal">AmqpHeaders.DELIVERY_MODE</code>.</p>
</td></tr></tbody></table></div>
<p><code class="literal">@Header</code>-annotated method arguments to extract a specific header value, including standard AMQP headers.</p>
<p><code class="literal">@Headers</code>-annotated argument that must also be assignable to <code class="literal">java.util.Map</code> for getting access to all headers.</p>
<p>A non-annotated element that is not one of the supported types (i.e.
<code class="literal">Message</code> and <code class="literal">Channel</code>) is considered to be the payload.
You can make that explicit by annotating the parameter with <code class="literal">@Payload</code>.
You can also turn on validation by adding an extra <code class="literal">@Valid</code>.</p>
<p>The ability to inject Spring’s Message abstraction is particularly useful to benefit from all the information stored in the transport-specific message without relying on transport-specific API.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RabbitListener(queues = "myQueue")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> processOrder(Message&lt;Order&gt; order) { ...
}</pre>
<p>Handling of method arguments is provided by <code class="literal">DefaultMessageHandlerMethodFactory</code> which can be further customized to support additional method arguments.
The conversion and validation support can be customized there as well.</p>
<p>For instance, if we want to make sure our Order is valid before processing it, we can annotate the payload with <code class="literal">@Valid</code> and configure the necessary validator as follows:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableRabbit</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AppConfig <span class="hl-keyword">implements</span> RabbitListenerConfigurer {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> configureRabbitListeners(RabbitListenerEndpointRegistrar registrar) {
        registrar.setMessageHandlerMethodFactory(myHandlerMethodFactory());
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> DefaultMessageHandlerMethodFactory myHandlerMethodFactory() {
        DefaultMessageHandlerMethodFactory factory = <span class="hl-keyword">new</span> DefaultMessageHandlerMethodFactory();
        factory.setValidator(myValidator());
        <span class="hl-keyword">return</span> factory;
    }
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="annotation-multiple-queues" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#annotation-multiple-queues"></a>Listening to Multiple Queues</h5></div></div></div>
<p>When using the <code class="literal">queues</code> attribute, you can specify that the associated container can listen to multiple queues.
You can use a <code class="literal">@Header</code> annotation to make the queue name from which a message was received available to the POJO
method:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Component</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyService {

    <em><span class="hl-annotation" style="color: gray">@RabbitListener(queues = { "queue1", "queue2" } )</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> processOrder(String data, <em><span class="hl-annotation" style="color: gray">@Header(AmqpHeaders.CONSUMER_QUEUE)</span></em> String queue) {
        ...
    }

}</pre>
<p>Starting with <span class="emphasis"><em>version 1.5</em></span>, you can externalize the queue names using property placeholders, and SpEL:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Component</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyService {

    <em><span class="hl-annotation" style="color: gray">@RabbitListener(queues = "#{'${property.with.comma.delimited.queue.names}'.split(',')}" )</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> processOrder(String data, <em><span class="hl-annotation" style="color: gray">@Header(AmqpHeaders.CONSUMER_QUEUE)</span></em> String queue) {
        ...
    }

}</pre>
<p>Prior to <span class="emphasis"><em>version 1.5</em></span>, only a single queue could be specified this way; each queue needed a separate property.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="async-annotation-driven-reply" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#async-annotation-driven-reply"></a>Reply Management</h5></div></div></div>
<p>The existing support in <code class="literal">MessageListenerAdapter</code> already allows your method to have a non-void return type.
When that’s the case, the result of the invocation is encapsulated in a message sent either in the address specified in the <code class="literal">ReplyToAddress</code> header of the original message or in the default address configured on the listener.
That default address can now be set using the <code class="literal">@SendTo</code> annotation of the messaging abstraction.</p>
<p>Assuming our <code class="literal">processOrder</code> method should now return an <code class="literal">OrderStatus</code>, it is possible to write it as follow to automatically send a reply:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RabbitListener(destination = "myQueue")</span></em>
<em><span class="hl-annotation" style="color: gray">@SendTo("status")</span></em>
<span class="hl-keyword">public</span> OrderStatus processOrder(Order order) {
    <span class="hl-comment">// order processing</span>
    <span class="hl-keyword">return</span> status;
}</pre>
<p>If you need to set additional headers in a transport-independent manner, you could return a <code class="literal">Message</code> instead, something like:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RabbitListener(destination = "myQueue")</span></em>
<em><span class="hl-annotation" style="color: gray">@SendTo("status")</span></em>
<span class="hl-keyword">public</span> Message&lt;OrderStatus&gt; processOrder(Order order) {
    <span class="hl-comment">// order processing</span>
    <span class="hl-keyword">return</span> MessageBuilder
        .withPayload(status)
        .setHeader(<span class="hl-string">"code"</span>, <span class="hl-number">1234</span>)
        .build();
}</pre>
<p>The <code class="literal">@SendTo</code> value is assumed as a reply <code class="literal">exchange</code> and <code class="literal">routingKey</code> pair following the pattern <code class="literal">exchange/routingKey</code>,
where one of those parts can be omitted.
The valid values are:</p>
<p><code class="literal">foo/bar</code> - the replyTo exchange and routingKey.</p>
<p><code class="literal">foo/</code> - the replyTo exchange and default (empty) routingKey.</p>
<p><code class="literal">bar</code> or <code class="literal">/bar</code> - the replyTo routingKey and default (empty) exchange.</p>
<p><code class="literal">/</code> or empty - the replyTo default exchange and default routingKey.</p>
<p>Also <code class="literal">@SendTo</code> can be used without a <code class="literal">value</code> attribute.
This case is equal to an empty sendTo pattern.
<code class="literal">@SendTo</code> is only used if the inbound message does not have a <code class="literal">replyToAddress</code> property.</p>
<p>Starting with <span class="emphasis"><em>version 1.5</em></span>, the <code class="literal">@SendTo</code> value can be a bean initialization SpEL Expression, for example…&#8203;</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RabbitListener(queues = "test.sendTo.spel")</span></em>
<em><span class="hl-annotation" style="color: gray">@SendTo("#{spelReplyTo}")</span></em>
<span class="hl-keyword">public</span> String capitalizeWithSendToSpel(String foo) {
    <span class="hl-keyword">return</span> foo.toUpperCase();
}
...
<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> String spelReplyTo() {
    <span class="hl-keyword">return</span> <span class="hl-string">"test.sendTo.reply.spel"</span>;
}</pre>
<p>The expression must evaluate to a <code class="literal">String</code>, which can be a simple queue name (sent to the default exchange) or with
the form <code class="literal">exchange/routingKey</code> as discussed above.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The <code class="literal">#{...}</code> expression is evaluated once, during initialization.</p>
</td></tr></tbody></table></div>
<p>For dynamic reply routing, the message sender should include a <code class="literal">reply_to</code> message property or use the alternate
runtime SpEL expression described below.</p>
<p>Starting with <span class="emphasis"><em>version 1.6</em></span>, the <code class="literal">@SendTo</code> can be a SpEL expression that is evaluated at runtime against the request
and reply:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RabbitListener(queues = "test.sendTo.spel")</span></em>
<em><span class="hl-annotation" style="color: gray">@SendTo("!{'some.reply.queue.with.' + result.queueName}")</span></em>
<span class="hl-keyword">public</span> Bar capitalizeWithSendToSpel(Foo foo) {
    <span class="hl-keyword">return</span> processTheFooAndReturnABar(foo);
}</pre>
<p>The runtime nature of the SpEL expression is indicated with <code class="literal">!{...}</code> delimiters.
The evaluation context <code class="literal">#root</code> object for the expression has three properties:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">request</code> - the <code class="literal">o.s.amqp.core.Message</code> request object.
</li><li class="listitem">
<code class="literal">source</code> - the <code class="literal">o.s.messaging.Message&lt;?&gt;</code> after conversion.
</li><li class="listitem">
<code class="literal">result</code> - the method result.
</li></ul></div>
<p>The context has a map property accessor, a standard type converter and a bean resolver, allowing other beans in the
context to be referenced (e.g. <code class="literal">@someBeanName.determineReplyQ(request, result)</code>).</p>
<p>In summary, <code class="literal">#{...}</code> is evaluated once during initialization, with the <code class="literal">#root</code> object being the application context;
beans are referenced by their names.
<code class="literal">!{...}</code> is evaluated at runtime for each message with the root object having the properties above and beans are
referenced with their names, prefixed by <code class="literal">@</code>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="annotation-method-selection" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#annotation-method-selection"></a>Multi-Method Listeners</h5></div></div></div>
<p>Starting with <span class="emphasis"><em>version 1.5.0</em></span>, the <code class="literal">@RabbitListener</code> annotation can now be specified at the class level.
Together with the new <code class="literal">@RabbitHandler</code> annotation, this allows a single listener to invoke different methods, based on
the payload type of the incoming message.
This is best described using an example:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RabbitListener(id="multi", queues = "someQueue")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MultiListenerBean {

    <em><span class="hl-annotation" style="color: gray">@RabbitHandler</span></em>
    <em><span class="hl-annotation" style="color: gray">@SendTo("my.reply.queue")</span></em>
    <span class="hl-keyword">public</span> String bar(Bar bar) {
        ...
    }

    <em><span class="hl-annotation" style="color: gray">@RabbitHandler</span></em>
    <span class="hl-keyword">public</span> String baz(Baz baz) {
        ...
    }

    <em><span class="hl-annotation" style="color: gray">@RabbitHandler</span></em>
    <span class="hl-keyword">public</span> String qux(<em><span class="hl-annotation" style="color: gray">@Header("amqp_receivedRoutingKey")</span></em> String rk, <em><span class="hl-annotation" style="color: gray">@Payload</span></em> Qux qux) {
        ...
    }

}</pre>
<p>In this case, the individual <code class="literal">@RabbitHandler</code> methods are invoked if the converted payload is a <code class="literal">Bar</code>, <code class="literal">Baz</code> or <code class="literal">Qux</code>.
It is important to understand that the system must be able to identify a unique method based on the payload type.
The type is checked for assignability to a single parameter that has no annotations, or is annotated with the <code class="literal">@Payload</code> annotation.
Notice that the same method signatures apply as discussed in the method-level <code class="literal">@RabbitListener</code> described above.</p>
<p>Notice that the <code class="literal">@SendTo</code> must be specified on each method (if needed); it is not supported at the class level.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="repeatable-rabbit-listener" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#repeatable-rabbit-listener"></a>@Repeatable @RabbitListener</h5></div></div></div>
<p>Starting with <span class="emphasis"><em>version 1.6</em></span>, the <code class="literal">@RabbitListener</code> annotation is marked with <code class="literal">@Repeatable</code>.
This means that the annotation can appear on the same annotated element (method or class) multiple times.
In this case, a separate listener container is created for each annotation, each of which invokes the same listener
<code class="literal">@Bean</code>.
Repeatable annotations can be used with Java 8 or above; when using Java 7 or earlier, the same effect can be achieved
by using the <code class="literal">@RabbitListeners</code> "container" annotation, with an array of <code class="literal">@RabbitListener</code> annotations.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_proxy_rabbitlistener_and_generics" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_proxy_rabbitlistener_and_generics"></a>Proxy @RabbitListener and Generics</h5></div></div></div>
<p>If your service is intended to be proxied (e.g. in case of <code class="literal">@Transactional</code>) there are some considerations when
the interface has generic parameters.
With a generic interface and a particular implementation, e.g.:</p>
<pre class="programlisting"><span class="hl-keyword">interface</span> TxService&lt;P&gt; {

   String handle(P payload, String header);

}

<span class="hl-keyword">static</span> <span class="hl-keyword">class</span> TxServiceImpl <span class="hl-keyword">implements</span> TxService&lt;Foo&gt; {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <em><span class="hl-annotation" style="color: gray">@RabbitListener(...)</span></em>
    <span class="hl-keyword">public</span> String handle(Foo foo, String rk) {
         ...
    }

}</pre>
<p>you are forced to switch to the CGLIB target class proxy because the actual implementation of the interface
<code class="literal">handle</code> method is a bridge method.
In the case of transaction management, the use of CGLIB is configured using
an annotation option - <code class="literal">@EnableTransactionManagement(proxyTargetClass = true)</code>.
And in this case, all annotations have to be declared on the target method in the implementation:</p>
<pre class="programlisting"><span class="hl-keyword">static</span> <span class="hl-keyword">class</span> TxServiceImpl <span class="hl-keyword">implements</span> TxService&lt;Foo&gt; {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <em><span class="hl-annotation" style="color: gray">@Transactional</span></em>
    <em><span class="hl-annotation" style="color: gray">@RabbitListener(...)</span></em>
    <span class="hl-keyword">public</span> String handle(<em><span class="hl-annotation" style="color: gray">@Payload</span></em> Foo foo, <em><span class="hl-annotation" style="color: gray">@Header("amqp_receivedRoutingKey")</span></em> String rk) {
        ...
    }

}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_container_management" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_container_management"></a>Container Management</h5></div></div></div>
<p>Containers created for annotations are not registered with the application context.
You can obtain a collection of all containers by invoking <code class="literal">getListenerContainers()</code> on the
<code class="literal">RabbitListenerEndpointRegistry</code> bean.
You can then iterate over this collection, for example, to stop/start all containers or invoke the <code class="literal">Lifecycle</code> methods
on the registry itself which will invoke the operations on each container.</p>
<p>You can also get a reference to an individual container using its <code class="literal">id</code>, using <code class="literal">getListenerContainer(String id)</code>; for
example <code class="literal">registry.getListenerContainer("multi")</code> for the container created by the snippet above.</p>
<p>Starting with version <span class="emphasis"><em>1.5.2</em></span>, you can obtain the <code class="literal">id</code> s of the registered containers with <code class="literal">getListenerContainerIds()</code>.</p>
<p>Starting with <span class="emphasis"><em>version 1.5</em></span>, you can now assign a <code class="literal">group</code> to the container on the <code class="literal">RabbitListener</code> endpoint.
This provides a mechanism to get a reference to a subset of containers; adding a <code class="literal">group</code> attribute causes a
bean of type <code class="literal">Collection&lt;MessageListenerContainer&gt;</code> to be registered with the context with the group name.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="threading" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#threading"></a>Threading and Asynchronous Consumers</h4></div></div></div>
<p>A number of different threads are involved with asynchronous consumers.</p>
<p>Threads from the <code class="literal">TaskExecutor</code> configured in the <code class="literal">SimpleMessageListener</code> are used to invoke the <code class="literal">MessageListener</code> when a new message is delivered by <code class="literal">RabbitMQ Client</code>.
If not configured, a <code class="literal">SimpleAsyncTaskExecutor</code> is used.
If a pooled executor is used, ensure the pool size is sufficient to handle the configured concurrency.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>When using the default <code class="literal">SimpleAsyncTaskExecutor</code>, for the threads the listener is invoked on, the listener
container <code class="literal">beanName</code> is used as the <code class="literal">threadNamePrefix</code>.
This is useful for log analysis; it’s generally recommended to always include the thread name in the logging appender
configuration.
When a <code class="literal">TaskExecutor</code> is specifically provided via the <code class="literal">taskExecutor</code> property on the <code class="literal">SimpleMessageListenerContainer</code>,
it is used as is, without modification.
It is recommended that you use a similar technique to name the threads created by a custom <code class="literal">TaskExecutor</code> bean
definition, to aid with thread identification in log messages.</p>
</td></tr></tbody></table></div>
<p>The <code class="literal">Executor</code> configured in the <code class="literal">CachingConnectionFactory</code> is passed into the <code class="literal">RabbitMQ Client</code> when creating the connection, and its threads are used to deliver new messages to the listener container.
At the time of writing, if this is not configured, the client uses an internal thread pool executor with a pool size of 5.</p>
<p>The <code class="literal">RabbitMQ client</code> uses a <code class="literal">ThreadFactory</code> to create threads for low-level I/O (socket) operations.
To modify this factory, you need to configure the underlying RabbitMQ <code class="literal">ConnectionFactory</code>, as discussed in <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#connection-factory" title="Configuring the Underlying Client Connection Factory">the section called “Configuring the Underlying Client Connection Factory”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idle-containers" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#idle-containers"></a>Detecting Idle Asynchronous Consumers</h4></div></div></div>
<p>While efficient, one problem with asynchronous consumers is detecting when they are idle - users might want to take
some action if no messages arrive for some period of time.</p>
<p>Starting with <span class="emphasis"><em>version 1.6</em></span>, it is now possible to configure the listener container to publish a
<code class="literal">ListenerContainerIdleEvent</code> when some time passes with no message delivery.
While the container is idle, an event will be published every <code class="literal">idleEventInterval</code> milliseconds.</p>
<p>To configure this feature, set the <code class="literal">idleEventInterval</code> on the container:</p>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_xml" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_xml"></a>xml</h5></div></div></div>
<pre class="programlisting"><span class="hl-tag">&lt;rabbit:listener-container</span> <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"connectionFactory"</span>
        <span class="hl-attribute">...</span>
        <span class="hl-attribute">idle-event-interval</span>=<span class="hl-value">"60000"</span>
        <span class="hl-attribute">...</span><span class="hl-tag">
        &gt;</span>
    <span class="hl-tag">&lt;rabbit:listener</span> <span class="hl-attribute">id</span>=<span class="hl-value">"container1"</span> <span class="hl-attribute">queue-names</span>=<span class="hl-value">"foo"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myListener"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"handle"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/rabbit:listener-container&gt;</span></pre>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_java" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_java"></a>Java</h5></div></div></div>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> SimpleMessageListenerContainer(ConnectionFactory connectionFactory) {
    SimpleMessageListenerContainer container = <span class="hl-keyword">new</span> SimpleMessageListenerContainer(connectionFactory);
    ...
    container.setIdleEventInterval(<span class="hl-number">60000L</span>);
    ...
    <span class="hl-keyword">return</span> container;
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="__rabbitlistener" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#__rabbitlistener"></a>@RabbitListener</h5></div></div></div>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory() {
    SimpleRabbitListenerContainerFactory factory = <span class="hl-keyword">new</span> SimpleRabbitListenerContainerFactory();
    factory.setConnectionFactory(rabbitConnectionFactory());
    factory.setIdleEventInterval(<span class="hl-number">60000L</span>);
    ...
    <span class="hl-keyword">return</span> factory;
}</pre>
<p>In each of these cases, an event will be published once per minute while the container is idle.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_event_consumption" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_event_consumption"></a>Event Consumption</h5></div></div></div>
<p>You can capture these events by implementing <code class="literal">ApplicationListener</code> - either a general listener, or one narrowed to only
receive this specific event.
You can also use <code class="literal">@EventListener</code>, introduced in Spring Framework 4.2.</p>
<p>The following example combines the <code class="literal">@RabbitListener</code> and <code class="literal">@EventListener</code> into a single class.
It’s important to understand that the application listener will get events for all containers so you may need to
check the listener id if you want to take specific action based on which container is idle.
You can also use the <code class="literal">@EventListener</code> <code class="literal">condition</code> for this purpose.</p>
<p>The events have 4 properties:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">source</code> - the listener container instance
</li><li class="listitem">
<code class="literal">id</code> - the listener id (or container bean name)
</li><li class="listitem">
<code class="literal">idleTime</code> - the time the container had been idle when the event was published
</li><li class="listitem">
<code class="literal">queueNames</code> - the names of the queue(s) that the container listens to
</li></ul></div>
<pre class="programlisting">public class Listener {

    @RabbitListener(id="foo", queues="#{queue.name}")
    public String listen(String foo) {
        return foo.toUpperCase();
    }

    @EventListener(condition = "event.listenerId == 'foo'")
    public void onApplicationEvent(ListenerContainerIdleEvent event) {
        ...
    }

}</pre>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./Spring AMQP_files/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Event listeners will see events for all containers; so, in the example above, we narrow the events received
based on the listener ID.</p>
</td></tr></tbody></table></div>
<div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Caution"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="./Spring AMQP_files/caution.png"></td><th align="left">Caution</th></tr><tr><td align="left" valign="top">
<p>If you wish to use the idle event to stop the lister container, you should not call <code class="literal">container.stop()</code> on the
thread that calls the listener - it will cause delays and unnecessary log messages.
Instead, you should hand off the event to a different thread that can then stop the container.</p>
</td></tr></tbody></table></div>
</div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="message-converters" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#message-converters"></a>3.1.7&nbsp;Message Converters</h3></div></div></div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_introduction_9" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction_9"></a>Introduction</h4></div></div></div>
<p>The <code class="literal">AmqpTemplate</code> also defines several methods for sending and receiving Messages that will delegate to a <code class="literal">MessageConverter</code>.
The <code class="literal">MessageConverter</code> itself is quite straightforward.
It provides a single method for each direction: one for converting <span class="strong"><strong>to</strong></span> a Message and another for converting <span class="strong"><strong>from</strong></span> a Message.
Notice that when converting to a Message, you may also provide properties in addition to the object.
The "object" parameter typically corresponds to the Message body.</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> MessageConverter {

    Message toMessage(Object object, MessageProperties messageProperties)
            <span class="hl-keyword">throws</span> MessageConversionException;

    Object fromMessage(Message message) <span class="hl-keyword">throws</span> MessageConversionException;

}</pre>
<p>The relevant Message-sending methods on the <code class="literal">AmqpTemplate</code> are listed below.
They are simpler than the methods we discussed previously because they do not require the <code class="literal">Message</code> instance.
Instead, the <code class="literal">MessageConverter</code> is responsible for "creating" each <code class="literal">Message</code> by converting the provided object to the byte array for the <code class="literal">Message</code> body and then adding any provided <code class="literal">MessageProperties</code>.</p>
<pre class="programlisting"><span class="hl-keyword">void</span> convertAndSend(Object message) <span class="hl-keyword">throws</span> AmqpException;

<span class="hl-keyword">void</span> convertAndSend(String routingKey, Object message) <span class="hl-keyword">throws</span> AmqpException;

<span class="hl-keyword">void</span> convertAndSend(String exchange, String routingKey, Object message)
    <span class="hl-keyword">throws</span> AmqpException;

<span class="hl-keyword">void</span> convertAndSend(Object message, MessagePostProcessor messagePostProcessor)
    <span class="hl-keyword">throws</span> AmqpException;

<span class="hl-keyword">void</span> convertAndSend(String routingKey, Object message,
    MessagePostProcessor messagePostProcessor) <span class="hl-keyword">throws</span> AmqpException;

<span class="hl-keyword">void</span> convertAndSend(String exchange, String routingKey, Object message,
    MessagePostProcessor messagePostProcessor) <span class="hl-keyword">throws</span> AmqpException;</pre>
<p>On the receiving side, there are only two methods: one that accepts the queue name and one that relies on the template’s "queue" property having been set.</p>
<pre class="programlisting">Object receiveAndConvert() <span class="hl-keyword">throws</span> AmqpException;

Object receiveAndConvert(String queueName) <span class="hl-keyword">throws</span> AmqpException;</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The <code class="literal">MessageListenerAdapter</code> mentioned in <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#async-consumer" title="Asynchronous Consumer">the section called “Asynchronous Consumer”</a> also uses a <code class="literal">MessageConverter</code>.</p>
</td></tr></tbody></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="simple-message-converter" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#simple-message-converter"></a>SimpleMessageConverter</h4></div></div></div>
<p>The default implementation of the <code class="literal">MessageConverter</code> strategy is called <code class="literal">SimpleMessageConverter</code>.
This is the converter that will be used by an instance of RabbitTemplate if you do not explicitly configure an alternative.
It handles text-based content, serialized Java objects, and simple byte arrays.</p>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_converting_from_a_message" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_converting_from_a_message"></a>Converting From a Message</h5></div></div></div>
<p>If the content type of the input Message begins with "text" (e.g.
"text/plain"), it will also check for the content-encoding property to determine the charset to be used when converting the Message body byte array to a Java String.
If no content-encoding property had been set on the input Message, it will use the "UTF-8" charset by default.
If you need to override that default setting, you can configure an instance of <code class="literal">SimpleMessageConverter</code>, set its "defaultCharset" property and then inject that into a <code class="literal">RabbitTemplate</code> instance.</p>
<p>If the content-type property value of the input Message is set to "application/x-java-serialized-object", the <code class="literal">SimpleMessageConverter</code> will attempt to deserialize (rehydrate) the byte array into a Java object.
While that might be useful for simple prototyping, it’s generally not recommended to rely on Java serialization since it leads to tight coupling between the producer and consumer.
Of course, it also rules out usage of non-Java systems on either side.
With AMQP being a wire-level protocol, it would be unfortunate to lose much of that advantage with such restrictions.
In the next two sections, we’ll explore some alternatives for passing rich domain object content without relying on Java serialization.</p>
<p>For all other content-types, the <code class="literal">SimpleMessageConverter</code> will return the Message body content directly as a byte array.</p>
<p>See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#java-deserialization" title="Java Deserialization">the section called “Java Deserialization”</a> for important information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_converting_to_a_message" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_converting_to_a_message"></a>Converting To a Message</h5></div></div></div>
<p>When converting to a Message from an arbitrary Java Object, the <code class="literal">SimpleMessageConverter</code> likewise deals with byte arrays, Strings, and Serializable instances.
It will convert each of these to bytes (in the case of byte arrays, there is nothing to convert), and it will set the content-type property accordingly.
If the Object to be converted does not match one of those types, the Message body will be null.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="serializer-message-converter" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#serializer-message-converter"></a>SerializerMessageConverter</h4></div></div></div>
<p>This converter is similar to the <code class="literal">SimpleMessageConverter</code> except it can be configured with other Spring Framework
<code class="literal">Serializer</code> and <code class="literal">Deserializer</code> implementations for <code class="literal">application/x-java-serialized-object</code> conversions.</p>
<p>See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#java-deserialization" title="Java Deserialization">the section called “Java Deserialization”</a> for important information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="json-message-converter" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#json-message-converter"></a>Jackson2JsonMessageConverter</h4></div></div></div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_converting_to_a_message_2" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_converting_to_a_message_2"></a>Converting to a Message</h5></div></div></div>
<p>As mentioned in the previous section, relying on Java serialization is generally not recommended.
One rather common alternative that is more flexible and portable across different languages and platforms is JSON
(JavaScript Object Notation).
The converter can be configured on any <code class="literal">RabbitTemplate</code> instance to override its usage of the <code class="literal">SimpleMessageConverter</code>
default.
The <code class="literal">Jackson2JsonMessageConverter</code> uses the <code class="literal">com.fasterxml.jackson</code> 2.x library.</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.amqp.rabbit.core.RabbitTemplate"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"rabbitConnectionFactory"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"messageConverter"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.amqp.support.converter.Jackson2JsonMessageConverter"</span><span class="hl-tag">&gt;</span>
            <span class="hl-comment">&lt;!-- if necessary, override the DefaultClassMapper --&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"classMapper"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"customClassMapper"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/bean&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>As shown above, <code class="literal">Jackson2JsonMessageConverter</code> uses a <code class="literal">DefaultClassMapper</code> by default.
Type information is added to (and retrieved from) the <code class="literal">MessageProperties</code>.
If an inbound message does not contain type information in the <code class="literal">MessageProperties</code>, but you know the expected type, you
can configure a static type using the <code class="literal">defaultType</code> property</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"jsonConverterWithDefaultType"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.amqp.support.converter.Jackson2JsonMessageConverter"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"classMapper"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.amqp.support.converter.DefaultClassMapper"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"defaultType"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"foo.PurchaseOrder"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/bean&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_converting_from_a_message_2" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_converting_from_a_message_2"></a>Converting from a Message</h5></div></div></div>
<p>Inbound messages are converted to objects according to the type information added to headers by the sending system.</p>
<p>In versions prior to <span class="emphasis"><em>1.6</em></span>, if type information is not present, conversion would fail.
Starting with <span class="emphasis"><em>version 1.6</em></span>, if type information is missing, the converter will convert the JSON using Jackson
defaults (usually a map).</p>
<p>Also, starting with <span class="emphasis"><em>version 1.6</em></span>, when using <code class="literal">@RabbitListener</code> annotations (on methods), the inferred type information
is added to the <code class="literal">MessageProperties</code>; this allows the converter to convert to the argument type of the target method.
This only applies if there is one parameter with no annotations or a single parameter with the <code class="literal">@Payload</code> annotation.
Parameters of type <code class="literal">Message</code> are ignored during the analysis.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./Spring AMQP_files/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>By default, the inferred type information will override the inbound <code class="literal">__TypeId__</code> and related headers created
by the sending system.
This allows the receiving system to automatically convert to a different domain object.
This applies only if the parameter type is concrete (not abstract or an interface) or it is from the <code class="literal">java.util</code>
package.
In all other cases, the <code class="literal">__TypeId__</code> and related headers will be used.
There are cases where you might wish to override the default behavior and always use the <code class="literal">__TypeId__</code> information.
For example, let’s say you have a <code class="literal">@RabbitListener</code> that takes a <code class="literal">Foo</code> argument but the message contains a <code class="literal">Bar</code> which
is a subclass of <code class="literal">Foo</code> (which is concrete).
The inferred type would be incorrect.
To handle this situation, set the <code class="literal">TypePrecedence</code> property on the <code class="literal">Jackson2JsonMessageConverter</code> to <code class="literal">TYPE_ID</code> instead
of the default <code class="literal">INFERRED</code>.
The property is actually on the converter’s <code class="literal">DefaultJackson2JavaTypeMapper</code> but a setter is provided on the converter
for convenience.
If you inject a custom type mapper, you should set the property on the mapper instead.</p>
</td></tr></tbody></table></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>When converting from the <code class="literal">Message</code>, an incoming <code class="literal">MessageProperties.getContentType()</code> must be JSON-compliant (the logic <code class="literal">contentType.contains("json")</code> is used).
Otherwise, a <code class="literal">WARN</code> log message <code class="literal">Could not convert incoming message with content-type [...]</code>, is emitted and <code class="literal">message.getBody()</code> is returned as is - as a <code class="literal">byte[]</code>.
So, to meet the <code class="literal">Jackson2JsonMessageConverter</code> requirements on the consumer side, the producer must add the <code class="literal">contentType</code> message property, e.g. as <code class="literal">application/json</code>, <code class="literal">text/x-json</code> or simply use the <code class="literal">Jackson2JsonMessageConverter</code>, which will set the header automatically.</p>
</td></tr></tbody></table></div>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RabbitListener</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> foo(Foo foo) {...}

<em><span class="hl-annotation" style="color: gray">@RabbitListener</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> foo(<em><span class="hl-annotation" style="color: gray">@Payload</span></em> Foo foo, <em><span class="hl-annotation" style="color: gray">@Header("amqp_consumerQueue")</span></em> String queue) {...}

<em><span class="hl-annotation" style="color: gray">@RabbitListener</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> foo(Foo foo, o.s.amqp.core.Message message) {...}

<em><span class="hl-annotation" style="color: gray">@RabbitListener</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> foo(Foo foo, o.s.messaging.Message&lt;Foo&gt; message) {...}

<em><span class="hl-annotation" style="color: gray">@RabbitListener</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> foo(Foo foo, String bar) {...}

<em><span class="hl-annotation" style="color: gray">@RabbitListener</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> foo(Foo foo, o.s.messaging.Message&lt;?&gt; message) {...}</pre>
<p>In the first four cases above the converter will attempt to convert to the <code class="literal">Foo</code> type.
The fifth example is invalid because we can’t determine which argument should receive the message payload.
With the sixth example, the Jackson defaults will apply due to the generic type being a <code class="literal">WildcardType</code>.</p>
<p>You can, however, create a custom converter and use the <code class="literal">targetMethod</code> message property to decide which type to convert
the JSON to.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>This type inference can only be achieved when the <code class="literal">@RabbitListener</code> annotation is declared at the method level.
With class-level <code class="literal">@RabbitListener</code>, the converted type is used to select which <code class="literal">@RabbitHandler</code> method to invoke.
For this reason, the infrastructure provides the <code class="literal">targetObject</code> message property which can be used by a custom
converter to determine the type.</p>
</td></tr></tbody></table></div>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./Spring AMQP_files/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Starting with <span class="emphasis"><em>version 1.6.11</em></span>, the <code class="literal">Jackson2JsonMessageConverter</code> and, therefore, <code class="literal">DefaultJackson2JavaTypeMapper</code> (<code class="literal">DefaultClassMapper</code>) provide the <code class="literal">trustedPackages</code> option to overcome <a class="ulink" href="https://pivotal.io/security/cve-2017-4995" target="_top">Serialization Gadgets</a> vulnerability.
By default, for backward compatiblity the <code class="literal">Jackson2JsonMessageConverter</code> trusts all packages - use <code class="literal">*</code> for the option.</p>
</td></tr></tbody></table></div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_marshallingmessageconverter" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_marshallingmessageconverter"></a>MarshallingMessageConverter</h4></div></div></div>
<p>Yet another option is the <code class="literal">MarshallingMessageConverter</code>.
It delegates to the Spring OXM library’s implementations of the <code class="literal">Marshaller</code> and <code class="literal">Unmarshaller</code> strategy interfaces.
You can read more about that library <a class="ulink" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/oxm.html" target="_top">here</a>.
In terms of configuration, it’s most common to provide the constructor argument only since most implementations of <code class="literal">Marshaller</code> will also implement <code class="literal">Unmarshaller</code>.</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.amqp.rabbit.core.RabbitTemplate"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"rabbitConnectionFactory"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"messageConverter"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.amqp.support.converter.MarshallingMessageConverter"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"someImplemenationOfMarshallerAndUnmarshaller"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/bean&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_contenttypedelegatingmessageconverter" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_contenttypedelegatingmessageconverter"></a>ContentTypeDelegatingMessageConverter</h4></div></div></div>
<p>This class was introduced in <span class="emphasis"><em>version 1.4.2</em></span> and allows delegation to a specific <code class="literal">MessageConverter</code> based on the content type property in the <code class="literal">MessageProperties</code>.
By default, it will delegate to a <code class="literal">SimpleMessageConverter</code> if there is no <code class="literal">contentType</code> property, or a value that matches none of the configured converters.</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"contentTypeConverter"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"ContentTypeDelegatingMessageConverter"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"delegates"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;map&gt;</span>
            <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"application/json"</span> <span class="hl-attribute">value-ref</span>=<span class="hl-value">"jsonMessageConverter"</span><span class="hl-tag"> /&gt;</span>
            <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"application/xml"</span> <span class="hl-attribute">value-ref</span>=<span class="hl-value">"xmlMessageConverter"</span><span class="hl-tag"> /&gt;</span>
        <span class="hl-tag">&lt;/map&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="java-deserialization" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#java-deserialization"></a>Java Deserialization</h4></div></div></div>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./Spring AMQP_files/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>There is a possible vulnerability when deserializing java objects from untrusted sources.</p>
<p>If you accept messages from untrusted sources with a <code class="literal">content-type</code> <code class="literal">application/x-java-serialized-object</code>, you should
consider configuring which packages/classes are allowed to be deserialized.
This applies to both the <code class="literal">SimpleMessageConverter</code> and <code class="literal">SerializerMessageConverter</code> when it is configured to use a
<code class="literal">DefaultDeserializer</code> - either implicitly, or via configuration.</p>
<p>By default, the white list is empty, meaning all classes will be deserialized.</p>
<p>You can set a list of patterns, such as <code class="literal">foo.*</code>, <code class="literal">foo.bar.Baz</code> or <code class="literal">*.MySafeClass</code>.</p>
<p>The patterns will be checked in order until a match is found.
If there is no match, a <code class="literal">SecurityException</code> is thrown.</p>
<p>Set the patterns using the <code class="literal">whiteListPatterns</code> property on these converters.</p>
</td></tr></tbody></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="message-properties-converters" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#message-properties-converters"></a>Message Properties Converters</h4></div></div></div>
<p>The <code class="literal">MessagePropertiesConverter</code> strategy interface is used to convert between the Rabbit Client
<code class="literal">BasicProperties</code> and Spring AMQP <code class="literal">MessageProperties</code>. The default implementation
(<code class="literal">DefaultMessagePropertiesConverter</code>) is usually sufficient for most purposes but you can implement your own if needed.
The default properties converter will convert <code class="literal">BasicProperties</code> elements of type <code class="literal">LongString</code> to <code class="literal">String</code> s
when the size is not greater than <code class="literal">1024</code> bytes. Larger <code class="literal">LongString</code> s are not converted (see below).
This limit can be overridden with a constructor argument.</p>
<p>Starting with <span class="emphasis"><em>version 1.6</em></span>, headers longer than the long string limit (default 1024) are now left as
<code class="literal">LongString</code> s by default by the <code class="literal">DefaultMessagePropertiesConverter</code>.
You can access the contents via the <code class="literal">getBytes[]</code>, <code class="literal">toString()</code>, or <code class="literal">getStream()</code> methods.</p>
<p>Previously, the <code class="literal">DefaultMessagePropertiesConverter</code> "converted" such headers to a <code class="literal">DataInputStream</code> (actually it just
referenced the <code class="literal">LongString</code>'s <code class="literal">DataInputStream</code>).
On output, this header was not converted (except to a String, e.g. <code class="literal">java.io.DataInputStream@1d057a39</code> by calling
<code class="literal">toString()</code> on the stream).</p>
<p>Large incoming <code class="literal">LongString</code> headers are now correctly "converted" on output too (by default).</p>
<p>A new constructor is provided to allow you to configure the converter to work as before:</p>
<pre class="programlisting"><strong class="hl-tag" style="color: blue">/**
 * Construct an instance where LongStrings will be returned
 * unconverted or as a java.io.DataInputStream when longer than this limit.
 * Use this constructor with 'true' to restore pre-1.6 behavior.
 * @param longStringLimit the limit.
 * @param convertLongLongStrings LongString when false,
 * DataInputStream when true.
 * @since 1.6
 */</strong>
<span class="hl-keyword">public</span> DefaultMessagePropertiesConverter(<span class="hl-keyword">int</span> longStringLimit, <span class="hl-keyword">boolean</span> convertLongLongStrings) { ... }</pre>
<p>Also starting with <span class="emphasis"><em>version 1.6</em></span>, a new property <code class="literal">correlationIdString</code> has been added to <code class="literal">MessageProperties</code>.
Previously, when converting to/from <code class="literal">BasicProperties</code> used by the RabbitMQ client, an unnecessary <code class="literal">byte[] &lt;-&gt; String</code>
conversion was performed because <code class="literal">MessageProperties.correlationId</code> is a <code class="literal">byte[]</code> but <code class="literal">BasicProperties</code> uses a
<code class="literal">String</code>. (Ultimately, the RabbitMQ client uses UTF-8 to convert the String to bytes to put in the protocol message).</p>
<p>To provide maximum backwards compatibility, a new property <code class="literal">correlationIdPolicy</code> has been added to the
<code class="literal">DefaultMessagePropertiesConverter</code>.
This takes an <code class="literal">DefaultMessagePropertiesConverter.CorrelationIdPolicy</code> enum argument.
By default it is set to <code class="literal">BYTES</code> which replicates the previous behavior.</p>
<p>For inbound messages:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">STRING</code> - just the <code class="literal">correlationIdString</code> property is mapped
</li><li class="listitem">
<code class="literal">BYTES</code> - just the <code class="literal">correlationId</code> property is mapped
</li><li class="listitem">
<code class="literal">BOTH</code> - both properties are mapped
</li></ul></div>
<p>For outbound messages:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">STRING</code> - just the <code class="literal">correlationIdString</code> property is mapped
</li><li class="listitem">
<code class="literal">BYTES</code> - just the <code class="literal">correlationId</code> property is mapped
</li><li class="listitem">
<code class="literal">BOTH</code> - Both properties will be considered, with the String property taking precedence
</li></ul></div>
<p>Also starting with <span class="emphasis"><em>version 1.6</em></span>, the inbound <code class="literal">deliveryMode</code> property is no longer mapped to <code class="literal">MessageProperties.deliveryMode</code>, it is mapped to <code class="literal">MessageProperties.receivedDeliveryMode</code> instead.
Also, the inbound <code class="literal">userId</code> property is no longer mapped to <code class="literal">MessageProperties.userId</code>, it is mapped to <code class="literal">MessageProperties.receivedUserId</code> instead.
These changes are to avoid unexpected propagation of these properties if the same <code class="literal">MessageProperties</code> object is used for an outbound message.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="post-processing" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#post-processing"></a>3.1.8&nbsp;Modifying Messages - Compression and More</h3></div></div></div>
<p>A number of extension points exist where you can perform some processing on a message, either before it is sent to RabbitMQ, or immediately after it is received.</p>
<p>As can be seen in <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#message-converters" title="3.1.7 Message Converters">Section&nbsp;3.1.7, “Message Converters”</a>, one such extension point is in the <code class="literal">AmqpTemplate</code> <code class="literal">convertAndReceive</code> operations, where you can provide a <code class="literal">MessagePostProcessor</code>.
For example, after your POJO has been converted, the <code class="literal">MessagePostProcessor</code> enables you to set custom headers or properties on the <code class="literal">Message</code>.</p>
<p>Starting with <span class="emphasis"><em>version 1.4.2</em></span>, additional extension points have been added to the <code class="literal">RabbitTemplate</code> - <code class="literal">setBeforePublishPostProcessors()</code> and <code class="literal">setAfterReceivePostProcessors()</code>.
The first enables a post processor to run immediately before sending to RabbitMQ. When using batching (see <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#template-batching" title="Batching">the section called “Batching”</a>), this is invoked after the batch is assembled and before the batch is sent. The second is invoked immediately after a message is received.</p>
<p>These extension points are used for such features as compression and, for this purpose, several <code class="literal">MessagePostProcessor</code> s are provided:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
GZipPostProcessor
</li><li class="listitem">
ZipPostProcessor
</li></ul></div>
<p>for compressing messages before sending, and</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
GUnzipPostProcessor
</li><li class="listitem">
UnzipPostProcessor
</li></ul></div>
<p>for decompressing received messages.</p>
<p>Similarly, the <code class="literal">SimpleMessageListenerContainer</code> also has a <code class="literal">setAfterReceivePostProcessors()</code> method, allowing the decompression to be performed after messages are received by the container.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="request-reply" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#request-reply"></a>3.1.9&nbsp;Request/Reply Messaging</h3></div></div></div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_introduction_10" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction_10"></a>Introduction</h4></div></div></div>
<p>The <code class="literal">AmqpTemplate</code> also provides a variety of <code class="literal">sendAndReceive</code> methods that accept the same argument options that you have seen above for the one-way send operations (exchange, routingKey, and Message).
Those methods are quite useful for request/reply scenarios since they handle the configuration of the necessary "reply-to" property before sending and can listen for the reply message on an exclusive Queue that is created internally for that purpose.</p>
<p>Similar request/reply methods are also available where the <code class="literal">MessageConverter</code> is applied to both the request and reply.
Those methods are named <code class="literal">convertSendAndReceive</code>.
See the Javadoc of <code class="literal">AmqpTemplate</code> for more detail.</p>
<p>Starting with <span class="emphasis"><em>version 1.5.0</em></span>, each of the <code class="literal">sendAndReceive</code> method variants has an overloaded version that takes <code class="literal">CorrelationData</code>.
Together with a properly configured connection factory, this enables the receipt of publisher confirms for the send side of the operation.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#template-confirms" title="Publisher Confirms and Returns">the section called “Publisher Confirms and Returns”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="reply-timeout" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#reply-timeout"></a>Reply Timeout</h4></div></div></div>
<p>By default, the send and receive methods will timeout after 5 seconds and return null.
This can be modified by setting the <code class="literal">replyTimeout</code> property.
Starting with <span class="emphasis"><em>version 1.5</em></span>, if you set the <code class="literal">mandatory</code> property to true (or the <code class="literal">mandatory-expression</code> evaluates to
<code class="literal">true</code> for a particular message), if the message cannot be delivered to a queue an <code class="literal">AmqpMessageReturnedException</code> will
be thrown.
This exception has <code class="literal">returnedMessage</code>, <code class="literal">replyCode</code>, <code class="literal">replyText</code> properties, as well as the <code class="literal">exchange</code> and
<code class="literal">routingKey</code> used for the send.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>This feature uses publisher returns and is enabled by setting <code class="literal">publisherReturns</code> to true on the
<code class="literal">CachingConnectionFactory</code> (see <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#cf-pub-conf-ret" title="Publisher Confirms and Returns">the section called “Publisher Confirms and Returns”</a>).
Also, you must not have registered your own <code class="literal">ReturnCallback</code> with the <code class="literal">RabbitTemplate</code>.</p>
</td></tr></tbody></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="direct-reply-to" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#direct-reply-to"></a>RabbitMQ Direct reply-to</h4></div></div></div>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./Spring AMQP_files/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Starting with <span class="emphasis"><em>version 3.4.0</em></span>, the RabbitMQ server now supports <a class="ulink" href="https://www.rabbitmq.com/direct-reply-to.html" target="_top">Direct reply-to</a>; this eliminates the main reason for a fixed reply queue (to avoid the need to create a temporary queue for each request).
Starting with <span class="strong"><strong>Spring AMQP version 1.4.1</strong></span> Direct reply-to will be used by default (if supported by the server) instead of creating temporary reply queues.
When no <code class="literal">replyQueue</code> is provided (or it is set with the name <code class="literal">amq.rabbitmq.reply-to</code>), the <code class="literal">RabbitTemplate</code> will automatically detect whether Direct reply-to is supported and either use it or fall back to using a temporary reply queue.
When using Direct reply-to, a <code class="literal">reply-listener</code> is not required and should not be configured.</p>
</td></tr></tbody></table></div>
<p>Reply listeners are still supported with named queues (other than <code class="literal">amq.rabbitmq.reply-to</code>), allowing control of reply concurrency etc.</p>
<p>Starting with <span class="emphasis"><em>version 1.6</em></span> if, for some reason, you wish to use a temporary, exclusive, auto-delete queue for each
reply, set the <code class="literal">useTemporaryReplyQueues</code> property to <code class="literal">true</code>.
This property is ignored if you you set a <code class="literal">replyAddress</code>.</p>
<p>The decision whether or not to use direct reply-to can be changed to use different criteria by subclassing
<code class="literal">RabbitTemplate</code> and overriding <code class="literal">useDirectReplyTo()</code>.
The method is called once only; when the first request is sent.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_message_correlation_with_a_reply_queue" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_message_correlation_with_a_reply_queue"></a>Message Correlation With A Reply Queue</h4></div></div></div>
<p>When using a fixed reply queue (other than <code class="literal">amq.rabbitmq.reply-to</code>), it is necessary to provide correlation data so that replies can be correlated to requests.
See <a class="ulink" href="https://www.rabbitmq.com/tutorials/tutorial-six-java.html" target="_top">RabbitMQ Remote Procedure Call (RPC)</a>.
By default, the standard <code class="literal">correlationId</code> property will be used to hold the correlation data.
However, if you wish to use a custom property to hold correlation data, you can set the <code class="literal">correlation-key</code> attribute on the &lt;rabbit-template/&gt;.
Explicitly setting the attribute to <code class="literal">correlationId</code> is the same as omitting the attribute.
Of course, the client and server must use the same header for correlation data.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Spring AMQP version 1.1 used a custom property <code class="literal">spring_reply_correlation</code> for this data.
If you wish to revert to this behavior with the current version, perhaps to maintain compatibility with another application using 1.1, you must set the attribute to <code class="literal">spring_reply_correlation</code>.</p>
</td></tr></tbody></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="reply-listener" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#reply-listener"></a>Reply Listener Container</h4></div></div></div>
<p>When using RabbitMQ versions prior to <span class="emphasis"><em>3.4.0</em></span>, a new temporary queue is used for each reply.
However, a single reply queue can be configured on the template, which can be more efficient,
and also allows you to set arguments on that queue.
In this case, however, you must also provide a &lt;reply-listener/&gt; sub element.
This element provides a listener container for the reply queue, with the template being the listener.
All of the <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#containerAttributes" title="3.1.15 Message Listener Container Configuration">Section&nbsp;3.1.15, “Message Listener Container Configuration”</a> attributes allowed on a &lt;listener-container/&gt; are allowed on the element, except for
connection-factory and message-converter, which are inherited from the template’s configuration.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./Spring AMQP_files/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>If you run multiple instances of your application or use multiple <code class="literal">RabbitTemplate</code> s, you <span class="strong"><strong>MUST</strong></span> use a
unique reply queue for each - RabbitMQ has no capability to select messages from a queue so, if they all use the same
queue, each instance would compete for replies and not necessarily receive their own.</p>
</td></tr></tbody></table></div>
<pre class="programlisting"><span class="hl-tag">&lt;rabbit:template</span> <span class="hl-attribute">id</span>=<span class="hl-value">"amqpTemplate"</span>
        <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"connectionFactory"</span>
        <span class="hl-attribute">reply-queue</span>=<span class="hl-value">"replies"</span>
        <span class="hl-attribute">reply-address</span>=<span class="hl-value">"replyEx/routeReply"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;rabbit:reply-listener/&gt;</span>
<span class="hl-tag">&lt;/rabbit:template&gt;</span></pre>
<p>While the container and template share a connection factory, they do not share a channel and therefore requests and replies are not performed within the same transaction (if transactional).</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Prior to <span class="emphasis"><em>version 1.5.0</em></span>, the <code class="literal">reply-address</code> attribute was not available, replies were always routed using the
default exchange and the <code class="literal">reply-queue</code> name as the routing key.
This is still the default but you can now specify the new <code class="literal">reply-address</code> attribute.
The <code class="literal">reply-address</code> can contain an address with the form <code class="literal">&lt;exchange&gt;/&lt;routingKey&gt;</code> and the reply will be routed to the
specified <span class="strong"><strong>exchange</strong></span> and routed to a queue bound with the <span class="strong"><strong>routing key</strong></span>.
The <code class="literal">reply-address</code> has precedence over <code class="literal">reply-queue</code>. The <code class="literal">&lt;reply-listener&gt;</code> must be configured as a separate
<code class="literal">&lt;listener-container&gt;</code> component, when only <code class="literal">reply-address</code> is in use, anyway <code class="literal">reply-address</code> and <code class="literal">reply-queue</code>
(or <code class="literal">queues</code> attribute on the <code class="literal">&lt;listener-container&gt;</code>) must refer to the same queue logically.</p>
</td></tr></tbody></table></div>
<p>With this configuration, a <code class="literal">SimpleListenerContainer</code> is used to receive the replies; with the <code class="literal">RabbitTemplate</code> being the <code class="literal">MessageListener</code>.
When defining a template with the <code class="literal">&lt;rabbit:template/&gt;</code> namespace element, as shown above, the parser defines the container and wires in the template as the listener.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>When the template does not use a fixed <code class="literal">replyQueue</code> (or is using Direct reply-to - see <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#direct-reply-to" title="RabbitMQ Direct reply-to">the section called “RabbitMQ Direct reply-to”</a>) a listener container is not needed. Direct <code class="literal">reply-to</code> is the preferred mechanism when using RabbitMQ <span class="emphasis"><em>3.4.0</em></span> or later.</p>
</td></tr></tbody></table></div>
<p>If you define your <code class="literal">RabbitTemplate</code> as a <code class="literal">&lt;bean/&gt;</code>, or using an <code class="literal">@Configuration</code> class to define it as an <code class="literal">@Bean</code>, or when creating the template programmatically, you will need to define and wire up the reply listener container yourself.
If you fail to do this, the template will never receive the replies and will eventually time out and return null as the reply to a call to a <code class="literal">sendAndReceive</code> method.</p>
<p>Starting with <span class="emphasis"><em>version 1.5</em></span>, the <code class="literal">RabbitTemplate</code> will detect if it has been
configured as a <code class="literal">MessageListener</code> to receive replies.
If not, attempts to send and receive messages with a reply address
will fail with an <code class="literal">IllegalStateException</code> (because the replies will never be received).</p>
<p>Further, if a simple <code class="literal">replyAddress</code> (queue name) is used, the reply listener container will verify that it is listening
to a queue with the same name.
This check cannot be performed if the reply address is an exchange and routing key and a debug log message will be
written.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./Spring AMQP_files/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>When wiring the reply listener and template yourself, it is important to ensure that the template’s <code class="literal">replyQueue</code> and the container’s <code class="literal">queues</code> (or <code class="literal">queueNames</code>) properties refer to the same queue.
The template inserts the reply queue into the outbound message <code class="literal">replyTo</code> property.</p>
</td></tr></tbody></table></div>
<p>The following are examples of how to manually wire up the beans.</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"amqpTemplate"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.amqp.rabbit.core.RabbitTemplate"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"connectionFactory"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"exchange"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"foo.exchange"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"routingKey"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"foo"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"replyQueue"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"replyQ"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"replyTimeout"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"600000"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"connectionFactory"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"queues"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"replyQ"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"messageListener"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"amqpTemplate"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;rabbit:queue</span> <span class="hl-attribute">id</span>=<span class="hl-value">"replyQ"</span> <span class="hl-attribute">name</span>=<span class="hl-value">"my.reply.queue"</span><span class="hl-tag"> /&gt;</span></pre>
<pre class="programlisting">    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> RabbitTemplate amqpTemplate() {
        RabbitTemplate rabbitTemplate = <span class="hl-keyword">new</span> RabbitTemplate(connectionFactory());
        rabbitTemplate.setMessageConverter(msgConv());
        rabbitTemplate.setReplyQueue(replyQueue());
        rabbitTemplate.setReplyTimeout(<span class="hl-number">60000</span>);
        <span class="hl-keyword">return</span> rabbitTemplate;
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> SimpleMessageListenerContainer replyListenerContainer() {
        SimpleMessageListenerContainer container = <span class="hl-keyword">new</span> SimpleMessageListenerContainer();
        container.setConnectionFactory(connectionFactory());
        container.setQueues(replyQueue());
        container.setMessageListener(amqpTemplate());
        <span class="hl-keyword">return</span> container;
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> Queue replyQueue() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> Queue(<span class="hl-string">"my.reply.queue"</span>);
    }</pre>
<p>A complete example of a <code class="literal">RabbitTemplate</code> wired with a fixed reply queue, together with a "remote" listener container that handles the request and returns the reply is shown in <a class="ulink" href="https://github.com/spring-projects/spring-amqp/tree/master/spring-rabbit/src/test/java/org/springframework/amqp/rabbit/listener/JavaConfigFixedReplyQueueTests.java" target="_top">this test case</a>.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./Spring AMQP_files/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>When the reply times out (<code class="literal">replyTimeout</code>), the <code class="literal">sendAndReceive()</code> methods return null.</p>
</td></tr></tbody></table></div>
<p>Prior to <span class="emphasis"><em>version 1.3.6</em></span>, late replies for timed out messages were simply logged.
Now, if a late reply is received, it is rejected (the template throws an <code class="literal">AmqpRejectAndDontRequeueException</code>).
If the reply queue is configured to send rejected messages to a dead letter exchange, the reply can be retrieved for later analysis.
Simply bind a queue to the configured dead letter exchange with a routing key equal to the reply queue’s name.</p>
<p>Refer to the <a class="ulink" href="https://www.rabbitmq.com/dlx.html" target="_top">RabbitMQ Dead Letter Documentation</a> for more information about configuring dead lettering.
You can also take a look at the <code class="literal">FixedReplyQueueDeadLetterTests</code> test case for an example.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="async-template" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#async-template"></a>AsyncRabbitTemplate</h4></div></div></div>
<p><span class="emphasis"><em>Version 1.6</em></span> introduced the <code class="literal">AsyncRabbitTemplate</code>.
This has similar <code class="literal">sendAndReceive</code> (and <code class="literal">convertSendAndReceive</code>) methods to those on the <a class="ulink" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#amqp-template" target="_top">AmqpTemplate</a>
but instead of blocking, they return a <code class="literal">ListenableFuture</code>.</p>
<p>The <code class="literal">sendAndReceive</code> methods return a <code class="literal">RabbitMessageFuture</code>; the <code class="literal">convertSendAndReceive</code> methods return a
<code class="literal">RabbitConverterFuture</code>.</p>
<p>You can either synchronously retrieve the result later, by invoking <code class="literal">get()</code> on the future, or you can register a
callback which will be called asynchronously with the result.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
<span class="hl-keyword">private</span> AsyncRabbitTemplate template;

...

<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doSomeWorkAndGetResultLater() {

    ...

    ListenableFuture&lt;String&gt; future = <span class="hl-keyword">this</span>.template.convertSendAndReceive(<span class="hl-string">"foo"</span>);

    <span class="hl-comment">// do some more work</span>

    String reply = null;
    <span class="hl-keyword">try</span> {
        reply = future.get();
    }
    <span class="hl-keyword">catch</span> (ExecutionException e) {
        ...
    }

    ...

}

<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doSomeWorkAndGetResultAsync() {

    ...

    RabbitConverterFuture&lt;String&gt; future = <span class="hl-keyword">this</span>.template.convertSendAndReceive(<span class="hl-string">"foo"</span>);
    future.addCallback(<span class="hl-keyword">new</span> ListenableFutureCallback&lt;String&gt;() {

        <em><span class="hl-annotation" style="color: gray">@Override</span></em>
        <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> onSuccess(String result) {
            ...
        }

        <em><span class="hl-annotation" style="color: gray">@Override</span></em>
        <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> onFailure(Throwable ex) {
            ...
        }

    });

    ...

}</pre>
<p>If <code class="literal">mandatory</code> is set, and the message can’t be delivered, the future will throw an <code class="literal">ExecutionException</code> with a cause of
<code class="literal">AmqpMessageReturnedException</code> which encapsulates the returned message and information about the return.</p>
<p>If <code class="literal">enableConfirms</code> is set, the future will have a property <code class="literal">confirm</code> which is itself a <code class="literal">ListenableFuture&lt;Boolean&gt;</code>
with <code class="literal">true</code> indicating a successful publish.
If the confirm future is false, the <code class="literal">RabbitFuture</code> will have a further property <code class="literal">nackCause</code> - the reason for the
failure, if available.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./Spring AMQP_files/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>The publisher confirm is discarded if it is received after the reply - since the reply implies a successful
publish.</p>
</td></tr></tbody></table></div>
<p>Set the <code class="literal">receiveTimeout</code> property on the template to time out replies (it defaults to <code class="literal">30000</code> - 30 seconds).
If a timeout occurs, the future will be completed with an <code class="literal">AmqpReplyTimeoutException</code>.</p>
<p>The template implements <code class="literal">SmartLifecycle</code>; stopping the template while there are pending replies will cause the
pending <code class="literal">Future</code> s to be canceled.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="remoting" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#remoting"></a>Spring Remoting with AMQP</h4></div></div></div>
<p>The Spring Framework has a general remoting capability, allowing <a class="ulink" href="http://static.springsource.org/spring/docs/current/spring-framework-reference/html/remoting.html" target="_top">Remote Procedure Calls (RPC)</a> using various transports.
Spring-AMQP supports a similar mechanism with a <code class="literal">AmqpProxyFactoryBean</code> on the client and a <code class="literal">AmqpInvokerServiceExporter</code> on the server.
This provides RPC over AMQP.
On the client side, a <code class="literal">RabbitTemplate</code> is used as described above; on the server side, the invoker (configured as a <code class="literal">MessageListener</code>) receives the message, invokes the configured service, and returns the reply using the inbound message’s <code class="literal">replyTo</code> information.</p>
<p>The client factory bean can be injected into any bean (using its <code class="literal">serviceInterface</code>); the client can then invoke methods on the proxy, resulting in remote execution over AMQP.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>With the default <code class="literal">MessageConverter</code> s, the method parameters and returned value must be instances of <code class="literal">Serializable</code>.</p>
</td></tr></tbody></table></div>
<p>On the server side, the <code class="literal">AmqpInvokerServiceExporter</code> has both <code class="literal">AmqpTemplate</code> and <code class="literal">MessageConverter</code> properties.
Currently, the template’s <code class="literal">MessageConverter</code> is not used.
If you need to supply a custom message converter, then you should provide it using the <code class="literal">messageConverter</code> property.
On the client side, a custom message converter can be added to the <code class="literal">AmqpTemplate</code> which is provided to the <code class="literal">AmqpProxyFactoryBean</code> using its <code class="literal">amqpTemplate</code> property.</p>
<p>Sample client and server configurations are shown below.</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"client"</span>
	<span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.amqp.remoting.client.AmqpProxyFactoryBean"</span><span class="hl-tag">&gt;</span>
	<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"amqpTemplate"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"template"</span><span class="hl-tag"> /&gt;</span>
	<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"serviceInterface"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"foo.ServiceInterface"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;rabbit:connection-factory</span> <span class="hl-attribute">id</span>=<span class="hl-value">"connectionFactory"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;rabbit:template</span> <span class="hl-attribute">id</span>=<span class="hl-value">"template"</span> <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">reply-timeout</span>=<span class="hl-value">"2000"</span>
	<span class="hl-attribute">routing-key</span>=<span class="hl-value">"remoting.binding"</span> <span class="hl-attribute">exchange</span>=<span class="hl-value">"remoting.exchange"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;rabbit:admin</span> <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"connectionFactory"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;rabbit:queue</span> <span class="hl-attribute">name</span>=<span class="hl-value">"remoting.queue"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;rabbit:direct-exchange</span> <span class="hl-attribute">name</span>=<span class="hl-value">"remoting.exchange"</span><span class="hl-tag">&gt;</span>
	<span class="hl-tag">&lt;rabbit:bindings&gt;</span>
		<span class="hl-tag">&lt;rabbit:binding</span> <span class="hl-attribute">queue</span>=<span class="hl-value">"remoting.queue"</span> <span class="hl-attribute">key</span>=<span class="hl-value">"remoting.binding"</span><span class="hl-tag"> /&gt;</span>
	<span class="hl-tag">&lt;/rabbit:bindings&gt;</span>
<span class="hl-tag">&lt;/rabbit:direct-exchange&gt;</span></pre>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"listener"</span>
	<span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.amqp.remoting.service.AmqpInvokerServiceExporter"</span><span class="hl-tag">&gt;</span>
	<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"serviceInterface"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"foo.ServiceInterface"</span><span class="hl-tag"> /&gt;</span>
	<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"service"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"service"</span><span class="hl-tag"> /&gt;</span>
	<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"amqpTemplate"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"template"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"service"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"foo.ServiceImpl"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;rabbit:connection-factory</span> <span class="hl-attribute">id</span>=<span class="hl-value">"connectionFactory"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;rabbit:template</span> <span class="hl-attribute">id</span>=<span class="hl-value">"template"</span> <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"connectionFactory"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;rabbit:queue</span> <span class="hl-attribute">name</span>=<span class="hl-value">"remoting.queue"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;rabbit:listener-container</span> <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"connectionFactory"</span><span class="hl-tag">&gt;</span>
	<span class="hl-tag">&lt;rabbit:listener</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"listener"</span> <span class="hl-attribute">queue-names</span>=<span class="hl-value">"remoting.queue"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/rabbit:listener-container&gt;</span></pre>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./Spring AMQP_files/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>The <code class="literal">AmqpInvokerServiceExporter</code> can only process properly formed messages, such as those sent from the <code class="literal">AmqpProxyFactoryBean</code>.
If it receives a message that it cannot interpret, a serialized <code class="literal">RuntimeException</code> will be sent as a reply.
If the message has no <code class="literal">replyToAddress</code> property, the message will be rejected and permanently lost if no Dead Letter Exchange has been configured.</p>
</td></tr></tbody></table></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>By default, if the request message cannot be delivered, the calling thread will eventually timeout and a
<code class="literal">RemoteProxyFailureException</code> will be thrown.
The timeout is 5 seconds by default, and can be modified by setting the <code class="literal">replyTimeout</code> property on the
<code class="literal">RabbitTemplate</code>.
Starting with <span class="emphasis"><em>version 1.5</em></span>, setting the <code class="literal">mandatory</code> property to true, and enabling returns on the connection
factory (see <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#cf-pub-conf-ret" title="Publisher Confirms and Returns">the section called “Publisher Confirms and Returns”</a>), the calling thread will throw an <code class="literal">AmqpMessageReturnedException</code>.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#reply-timeout" title="Reply Timeout">the section called “Reply Timeout”</a> for more information.</p>
</td></tr></tbody></table></div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="broker-configuration" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#broker-configuration"></a>3.1.10&nbsp;Configuring the broker</h3></div></div></div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_introduction_11" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction_11"></a>Introduction</h4></div></div></div>
<p>The AMQP specification describes how the protocol can be used to configure Queues, Exchanges and Bindings on the broker.
These operations which are portable from the 0.8 specification and higher are present in the <code class="literal">AmqpAdmin</code> interface in the <code class="literal">org.springframework.amqp.core</code> package.
The RabbitMQ implementation of that class is <code class="literal">RabbitAdmin</code> located in the <code class="literal">org.springframework.amqp.rabbit.core</code> package.</p>
<p>The AmqpAdmin interface is based on using the Spring AMQP domain abstractions and is shown below:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> AmqpAdmin {

    <span class="hl-comment">// Exchange Operations</span>

    <span class="hl-keyword">void</span> declareExchange(Exchange exchange);

    <span class="hl-keyword">void</span> deleteExchange(String exchangeName);

    <span class="hl-comment">// Queue Operations</span>

    Queue declareQueue();

    String declareQueue(Queue queue);

    <span class="hl-keyword">void</span> deleteQueue(String queueName);

    <span class="hl-keyword">void</span> deleteQueue(String queueName, <span class="hl-keyword">boolean</span> unused, <span class="hl-keyword">boolean</span> empty);

    <span class="hl-keyword">void</span> purgeQueue(String queueName, <span class="hl-keyword">boolean</span> noWait);

    <span class="hl-comment">// Binding Operations</span>

    <span class="hl-keyword">void</span> declareBinding(Binding binding);

    <span class="hl-keyword">void</span> removeBinding(Binding binding);

    Properties getQueueProperties(String queueName);

}</pre>
<p>The <code class="literal">getQueueProperties()</code> method returns some limited information about the queue (message count and consumer count).
The keys for the properties returned are available as constants in the <code class="literal">RabbitTemplate</code> (<code class="literal">QUEUE_NAME</code>,
<code class="literal">QUEUE_MESSAGE_COUNT</code>, <code class="literal">QUEUE_CONSUMER_COUNT</code>).
The <a class="link" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#management-template" title="3.1.12 RabbitMQ REST API">RabbitMQ REST API</a> provides much more information in the <code class="literal">QueueInfo</code> object.</p>
<p>The no-arg <code class="literal">declareQueue()</code> method defines a queue on the broker with a name that is automatically generated.
The additional properties of this auto-generated queue are <code class="literal">exclusive=true</code>, <code class="literal">autoDelete=true</code>, and <code class="literal">durable=false</code>.</p>
<p>The <code class="literal">declareQueue(Queue queue)</code> method takes a <code class="literal">Queue</code> object and returns the name of the declared queue.
If the provided <code class="literal">Queue</code>'s <code class="literal">name</code> property is an empty String, the broker declares the queue with a generated name and
that name is returned to the caller.
The <code class="literal">Queue</code> object itself is not changed.
This functionality can only be used programmatically by invoking the <code class="literal">RabbitAdmin</code> directly.
It is not supported for auto-declaration by the admin by defining a queue declaratively in the application context.</p>
<p>This is in contrast to an <code class="literal">AnonymousQueue</code> where the framework generates a unique (<code class="literal">UUID</code>) name and sets <code class="literal">durable</code> to
<code class="literal">false</code> and <code class="literal">exclusive</code>, <code class="literal">autoDelete</code> to <code class="literal">true</code>.
A <code class="literal">&lt;rabbit:queue/&gt;</code> with an empty, or missing, <code class="literal">name</code> attribute will always create an <code class="literal">AnonymousQueue</code>.</p>
<p>See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#anonymous-queue" title="AnonymousQueue">the section called “AnonymousQueue”</a> to understand why <code class="literal">AnonymousQueue</code> is preferred over broker-generated queue names, as well as
how to control the format of the name.
Declarative queues must have fixed names because they might be referenced elsewhere in the context, for example, in a
listener:</p>
<pre class="programlisting"><span class="hl-tag">&lt;rabbit:listener-container&gt;</span>
    <span class="hl-tag">&lt;rabbit:listener</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"listener"</span> <span class="hl-attribute">queue-names</span>=<span class="hl-value">"#{someQueue.name}"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/rabbit:listener-container&gt;</span></pre>
<p>See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#automatic-declaration" title="Automatic Declaration of Exchanges, Queues and Bindings">the section called “Automatic Declaration of Exchanges, Queues and Bindings”</a>.</p>
<p>The RabbitMQ implementation of this interface is RabbitAdmin which when configured using Spring XML would look like this:</p>
<pre class="programlisting"><span class="hl-tag">&lt;rabbit:connection-factory</span> <span class="hl-attribute">id</span>=<span class="hl-value">"connectionFactory"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;rabbit:admin</span> <span class="hl-attribute">id</span>=<span class="hl-value">"amqpAdmin"</span> <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"connectionFactory"</span><span class="hl-tag">/&gt;</span></pre>
<p>When the <code class="literal">CachingConnectionFactory</code> cache mode is <code class="literal">CHANNEL</code> (the default), the <code class="literal">RabbitAdmin</code> implementation does automatic lazy declaration of <code class="literal">Queues</code>, <code class="literal">Exchanges</code> and <code class="literal">Bindings</code> declared in the same <code class="literal">ApplicationContext</code>.
These components will be declared as s0on as a <code class="literal">Connection</code> is opened to the broker.
There are some namespace features that make this very convenient, e.g.
in the Stocks sample application we have:</p>
<pre class="programlisting"><span class="hl-tag">&lt;rabbit:queue</span> <span class="hl-attribute">id</span>=<span class="hl-value">"tradeQueue"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;rabbit:queue</span> <span class="hl-attribute">id</span>=<span class="hl-value">"marketDataQueue"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;fanout-exchange</span> <span class="hl-attribute">name</span>=<span class="hl-value">"broadcast.responses"</span>
                 <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/rabbit"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;bindings&gt;</span>
        <span class="hl-tag">&lt;binding</span> <span class="hl-attribute">queue</span>=<span class="hl-value">"tradeQueue"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bindings&gt;</span>
<span class="hl-tag">&lt;/fanout-exchange&gt;</span>

<span class="hl-tag">&lt;topic-exchange</span> <span class="hl-attribute">name</span>=<span class="hl-value">"app.stock.marketdata"</span>
                <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/rabbit"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;bindings&gt;</span>
        <span class="hl-tag">&lt;binding</span> <span class="hl-attribute">queue</span>=<span class="hl-value">"marketDataQueue"</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"${stocks.quote.pattern}"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bindings&gt;</span>
<span class="hl-tag">&lt;/topic-exchange&gt;</span></pre>
<p>In the example above we are using anonymous Queues (actually internally just Queues with names generated by the framework, not by the broker) and refer to them by ID.
We can also declare Queues with explicit names, which also serve as identifiers for their bean definitions in the context.
E.g.</p>
<pre class="programlisting"><span class="hl-tag">&lt;rabbit:queue</span> <span class="hl-attribute">name</span>=<span class="hl-value">"stocks.trade.queue"</span><span class="hl-tag">/&gt;</span></pre>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="./Spring AMQP_files/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>You can provide both an <span class="strong"><strong>id</strong></span> and a <span class="strong"><strong>name</strong></span> attribute.
This allows you to refer to the queue (for example in a binding) by an id that is independent of the queue name.
It also allows standard Spring features such as property placeholders, and SpEL expressions for the queue name; these features are not available when using the name as the bean identifier.</p>
</td></tr></tbody></table></div>
<p>Queues can be configured with additional arguments, for example, <span class="emphasis"><em>x-message-ttl</em></span> or <span class="emphasis"><em>x-ha-policy</em></span>.
Using the namespace support, they are provided in the form of a Map of argument name/argument value pairs, using the <code class="literal">&lt;rabbit:queue-arguments&gt;</code> element.</p>
<pre class="programlisting"><span class="hl-tag">&lt;rabbit:queue</span> <span class="hl-attribute">name</span>=<span class="hl-value">"withArguments"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;rabbit:queue-arguments&gt;</span>
        <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"x-ha-policy"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"all"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/rabbit:queue-arguments&gt;</span>
<span class="hl-tag">&lt;/rabbit:queue&gt;</span></pre>
<p>By default, the arguments are assumed to be strings.
For arguments of other types, the type needs to be provided.</p>
<pre class="programlisting"><span class="hl-tag">&lt;rabbit:queue</span> <span class="hl-attribute">name</span>=<span class="hl-value">"withArguments"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;rabbit:queue-arguments</span> <span class="hl-attribute">value-type</span>=<span class="hl-value">"java.lang.Long"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"x-message-ttl"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"100"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/rabbit:queue-arguments&gt;</span>
<span class="hl-tag">&lt;/rabbit:queue&gt;</span></pre>
<p>When providing arguments of mixed types, the type is provided for each entry element:</p>
<pre class="programlisting"><span class="hl-tag">&lt;rabbit:queue</span> <span class="hl-attribute">name</span>=<span class="hl-value">"withArguments"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;rabbit:queue-arguments&gt;</span>
        <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"x-message-ttl"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;value</span> <span class="hl-attribute">type</span>=<span class="hl-value">"java.lang.Long"</span><span class="hl-tag">&gt;</span>100<span class="hl-tag">&lt;/value&gt;</span>
        <span class="hl-tag">&lt;/entry&gt;</span>
        <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"x-ha-policy"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"all"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/rabbit:queue-arguments&gt;</span>
<span class="hl-tag">&lt;/rabbit:queue&gt;</span></pre>
<p>With Spring Framework 3.2 and later, this can be declared a little more succinctly:</p>
<pre class="programlisting"><span class="hl-tag">&lt;rabbit:queue</span> <span class="hl-attribute">name</span>=<span class="hl-value">"withArguments"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;rabbit:queue-arguments&gt;</span>
        <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"x-message-ttl"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"100"</span> <span class="hl-attribute">value-type</span>=<span class="hl-value">"java.lang.Long"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"x-ha-policy"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"all"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/rabbit:queue-arguments&gt;</span>
<span class="hl-tag">&lt;/rabbit:queue&gt;</span></pre>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./Spring AMQP_files/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>The RabbitMQ broker will not allow declaration of a queue with mismatched arguments.
For example, if a <code class="literal">queue</code> already exists with no <code class="literal">time to live</code> argument, and you attempt to declare it with, say, <code class="literal">key="x-message-ttl" value="100"</code>, an exception will be thrown.</p>
</td></tr></tbody></table></div>
<p>By default, the <code class="literal">RabbitAdmin</code> will immediately stop processing all declarations when any exception occurs; this could cause downstream issues - such as a <span class="strong"><strong>listener container</strong></span> failing to initialize because another queue (defined after the one in error) is not declared.</p>
<p>This behavior can be modified by setting the <code class="literal">ignore-declaration-exceptions</code> attribute to <code class="literal">true</code> on the <code class="literal">RabbitAdmin</code>.
This option instructs the <code class="literal">RabbitAdmin</code> to log the exception, and continue declaring other elements.
When configuring the <code class="literal">RabbitAdmin</code> using java, this property is <code class="literal">ignoreDeclarationExceptions</code>.
This is a global setting which applies to all elements, queues, exchanges and bindings have a similar property which
applies to just those elements.</p>
<p>Prior to <span class="emphasis"><em>version 1.6</em></span>, this property only took effect if an <code class="literal">IOException</code> occurred on the channel - such as when there
is a mismatch between current and desired properties.
Now, this property takes effect on any exception, including <code class="literal">TimeoutException</code> etc.</p>
<p>In addition, any declaration exceptions result in the publishing of a <code class="literal">DeclarationExceptionEvent</code>, which is an
<code class="literal">ApplicationEvent</code> that can be consumed by any <code class="literal">ApplicationListener</code> in the context.
The event contains a reference to the admin, the element that was being declared, and the <code class="literal">Throwable</code>.</p>
<p><a name="headers-exchange" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#headers-exchange"></a>Starting with <span class="emphasis"><em>version 1.3</em></span> the <code class="literal">HeadersExchange</code> can be configured to match on multiple headers; you can also specify whether any or all headers must match:</p>
<pre class="programlisting"><span class="hl-tag">&lt;rabbit:headers-exchange</span> <span class="hl-attribute">name</span>=<span class="hl-value">"headers-test"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;rabbit:bindings&gt;</span>
        <span class="hl-tag">&lt;rabbit:binding</span> <span class="hl-attribute">queue</span>=<span class="hl-value">"bucket"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;rabbit:binding-arguments&gt;</span>
                <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"foo"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"bar"</span><span class="hl-tag">/&gt;</span>
                <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"baz"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"qux"</span><span class="hl-tag">/&gt;</span>
                <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"x-match"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"all"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;/rabbit:binding-arguments&gt;</span>
        <span class="hl-tag">&lt;/rabbit:binding&gt;</span>
    <span class="hl-tag">&lt;/rabbit:bindings&gt;</span>
<span class="hl-tag">&lt;/rabbit:headers-exchange&gt;</span></pre>
<p>Starting with <span class="emphasis"><em>version 1.6</em></span> <code class="literal">Exchanges</code> can be configured with an <code class="literal">internal</code> flag (defaults to <code class="literal">false</code>) and such an
<code class="literal">Exchange</code> will be properly configured on the Broker via a <code class="literal">RabbitAdmin</code> (if one is present in the application context).
If the <code class="literal">internal</code> flag is <code class="literal">true</code> for an exchange, RabbitMQ will not allow clients to use the exchange.
This is useful for a dead letter exchange, or exchange-to-exchange binding, where you don’t wish the exchange to be used
directly by publishers.</p>
<p>To see how to use Java to configure the AMQP infrastructure, look at the Stock sample application,
where there is the <code class="literal">@Configuration</code> class <code class="literal">AbstractStockRabbitConfiguration</code> which in turn has
<code class="literal">RabbitClientConfiguration</code> and <code class="literal">RabbitServerConfiguration</code> subclasses.
The code for <code class="literal">AbstractStockRabbitConfiguration</code> is shown below</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">abstract</span> <span class="hl-keyword">class</span> AbstractStockAppRabbitConfiguration {

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> ConnectionFactory connectionFactory() {
        CachingConnectionFactory connectionFactory =
            <span class="hl-keyword">new</span> CachingConnectionFactory(<span class="hl-string">"localhost"</span>);
        connectionFactory.setUsername(<span class="hl-string">"guest"</span>);
        connectionFactory.setPassword(<span class="hl-string">"guest"</span>);
        <span class="hl-keyword">return</span> connectionFactory;
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> RabbitTemplate rabbitTemplate() {
        RabbitTemplate template = <span class="hl-keyword">new</span> RabbitTemplate(connectionFactory());
        template.setMessageConverter(jsonMessageConverter());
        configureRabbitTemplate(template);
        <span class="hl-keyword">return</span> template;
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> MessageConverter jsonMessageConverter() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> JsonMessageConverter();
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> TopicExchange marketDataExchange() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> TopicExchange(<span class="hl-string">"app.stock.marketdata"</span>);
    }

    <span class="hl-comment">// additional code omitted for brevity</span>

}</pre>
<p>In the Stock application, the server is configured using the following @Configuration class:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> RabbitServerConfiguration <span class="hl-keyword">extends</span> AbstractStockAppRabbitConfiguration  {

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> Queue stockRequestQueue() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> Queue(<span class="hl-string">"app.stock.request"</span>);
    }
}</pre>
<p>This is the end of the whole inheritance chain of <code class="literal">@Configuration</code> classes.
The end result is the the TopicExchange and Queue will be declared to the broker upon application startup.
There is no binding of the TopicExchange to a queue in the server configuration, as that is done in the client application.
The stock request queue however is automatically bound to the AMQP default exchange - this behavior is defined by the specification.</p>
<p>The client <code class="literal">@Configuration</code> class is a little more interesting and is shown below.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> RabbitClientConfiguration <span class="hl-keyword">extends</span> AbstractStockAppRabbitConfiguration {

    <em><span class="hl-annotation" style="color: gray">@Value("${stocks.quote.pattern}")</span></em>
    <span class="hl-keyword">private</span> String marketDataRoutingKey;

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> Queue marketDataQueue() {
        <span class="hl-keyword">return</span> amqpAdmin().declareQueue();
    }

    <strong class="hl-tag" style="color: blue">/**
     * Binds to the market data exchange.
     * Interested in any stock quotes
     * that match its routing key.
     */</strong>
    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> Binding marketDataBinding() {
        <span class="hl-keyword">return</span> BindingBuilder.bind(
                marketDataQueue()).to(marketDataExchange()).with(marketDataRoutingKey);
    }

    <span class="hl-comment">// additional code omitted for brevity</span>

}</pre>
<p>The client is declaring another queue via the <code class="literal">declareQueue()</code> method on the <code class="literal">AmqpAdmin</code>, and it binds that queue to the market data exchange with a routing pattern that is externalized in a properties file.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="builder-api" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#builder-api"></a>Builder API for Queues and Exchanges</h4></div></div></div>
<p><span class="emphasis"><em>Version 1.6</em></span> introduces a convenient fluent API for configuring <code class="literal">Queue</code> and <code class="literal">Exchange</code> objects when using Java configuration:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> Queue queue() {
    <span class="hl-keyword">return</span> QueueBuilder.nonDurable(<span class="hl-string">"foo"</span>)
        .autoDelete()
        .exclusive()
        .withArgument(<span class="hl-string">"foo"</span>, <span class="hl-string">"bar"</span>)
        .build();
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> Exchange exchange() {
  <span class="hl-keyword">return</span> ExchangeBuilder.directExchange(<span class="hl-string">"foo"</span>)
      .autoDelete()
      .internal()
      .withArgument(<span class="hl-string">"foo"</span>, <span class="hl-string">"bar"</span>)
      .build();
}</pre>
<p>See the javadocs for <code class="literal">org.springframework.amqp.core.QueueBuilder</code> and <code class="literal">org.springframework.amqp.core.ExchangeBuilder</code> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="collection-declaration" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#collection-declaration"></a>Declaring Collections of Exchanges, Queues, Bindings</h4></div></div></div>
<p>Starting with <span class="emphasis"><em>version 1.5</em></span>, it is now possible to declare multiple entities with one <code class="literal">@Bean</code>, by returing a
collection.</p>
<p>Only collections where the first element is a <code class="literal">Declarable</code> are considered, and only <code class="literal">Declarable</code> elements from such
collections are processed.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">class</span> Config {

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> ConnectionFactory cf() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> CachingConnectionFactory(<span class="hl-string">"localhost"</span>);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> RabbitAdmin admin(ConnectionFactory cf) {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> RabbitAdmin(cf);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> DirectExchange e1() {
    	<span class="hl-keyword">return</span> <span class="hl-keyword">new</span> DirectExchange(<span class="hl-string">"e1"</span>, false, true);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> Queue q1() {
    	<span class="hl-keyword">return</span> <span class="hl-keyword">new</span> Queue(<span class="hl-string">"q1"</span>, false, false, true);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> Binding b1() {
    	<span class="hl-keyword">return</span> BindingBuilder.bind(q1()).to(e1()).with(<span class="hl-string">"k1"</span>);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> List&lt;Exchange&gt; es() {
    	<span class="hl-keyword">return</span> Arrays.&lt;Exchange&gt;asList(
    			<span class="hl-keyword">new</span> DirectExchange(<span class="hl-string">"e2"</span>, false, true),
    			<span class="hl-keyword">new</span> DirectExchange(<span class="hl-string">"e3"</span>, false, true)
    	);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> List&lt;Queue&gt; qs() {
    	<span class="hl-keyword">return</span> Arrays.asList(
    			<span class="hl-keyword">new</span> Queue(<span class="hl-string">"q2"</span>, false, false, true),
    			<span class="hl-keyword">new</span> Queue(<span class="hl-string">"q3"</span>, false, false, true)
    	);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> List&lt;Binding&gt; bs() {
    	<span class="hl-keyword">return</span> Arrays.asList(
    			<span class="hl-keyword">new</span> Binding(<span class="hl-string">"q2"</span>, DestinationType.QUEUE, <span class="hl-string">"e2"</span>, <span class="hl-string">"k2"</span>, null),
    			<span class="hl-keyword">new</span> Binding(<span class="hl-string">"q3"</span>, DestinationType.QUEUE, <span class="hl-string">"e3"</span>, <span class="hl-string">"k3"</span>, null)
    	);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> List&lt;Declarable&gt; ds() {
    	<span class="hl-keyword">return</span> Arrays.&lt;Declarable&gt;asList(
    			<span class="hl-keyword">new</span> DirectExchange(<span class="hl-string">"e4"</span>, false, true),
    			<span class="hl-keyword">new</span> Queue(<span class="hl-string">"q4"</span>, false, false, true),
    			<span class="hl-keyword">new</span> Binding(<span class="hl-string">"q4"</span>, DestinationType.QUEUE, <span class="hl-string">"e4"</span>, <span class="hl-string">"k4"</span>, null)
    	);
    }

}</pre>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./Spring AMQP_files/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>This feature can cause undesirable side effects in some cases, because the admin has to iterate over all <code class="literal">Collection&lt;?&gt;</code> beans.
Starting with <span class="emphasis"><em>versions 1.7.7, 2.0.4</em></span>, this feature can be disabled by setting the admin property <code class="literal">declareCollections</code> to <code class="literal">false</code>.</p>
</td></tr></tbody></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="conditional-declaration" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#conditional-declaration"></a>Conditional Declaration</h4></div></div></div>
<p>By default, all queues, exchanges, and bindings are declared by all <code class="literal">RabbitAdmin</code> instances (that have <code class="literal">auto-startup="true"</code>) in the application context.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Starting with the 1.2 release, it is possible to conditionally declare these elements.
This is particularly useful when an application connects to multiple brokers and needs to specify with which broker(s) a particular element should be declared.</p>
</td></tr></tbody></table></div>
<p>The classes representing these elements implement <code class="literal">Declarable</code> which has two methods: <code class="literal">shouldDeclare()</code> and <code class="literal">getDeclaringAdmins()</code>.
The <code class="literal">RabbitAdmin</code> uses these methods to determine whether a particular instance should actually process the declarations on its <code class="literal">Connection</code>.</p>
<p>The properties are available as attributes in the namespace, as shown in the following examples.</p>
<pre class="programlisting"><span class="hl-tag">&lt;rabbit:admin</span> <span class="hl-attribute">id</span>=<span class="hl-value">"admin1"</span> <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"CF1"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;rabbit:admin</span> <span class="hl-attribute">id</span>=<span class="hl-value">"admin2"</span> <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"CF2"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;rabbit:queue</span> <span class="hl-attribute">id</span>=<span class="hl-value">"declaredByBothAdminsImplicitly"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;rabbit:queue</span> <span class="hl-attribute">id</span>=<span class="hl-value">"declaredByBothAdmins"</span> <span class="hl-attribute">declared-by</span>=<span class="hl-value">"admin1, admin2"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;rabbit:queue</span> <span class="hl-attribute">id</span>=<span class="hl-value">"declaredByAdmin1Only"</span> <span class="hl-attribute">declared-by</span>=<span class="hl-value">"admin1"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;rabbit:queue</span> <span class="hl-attribute">id</span>=<span class="hl-value">"notDeclaredByAny"</span> <span class="hl-attribute">auto-declare</span>=<span class="hl-value">"false"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;rabbit:direct-exchange</span> <span class="hl-attribute">name</span>=<span class="hl-value">"direct"</span> <span class="hl-attribute">declared-by</span>=<span class="hl-value">"admin1, admin2"</span><span class="hl-tag">&gt;</span>
	<span class="hl-tag">&lt;rabbit:bindings&gt;</span>
		<span class="hl-tag">&lt;rabbit:binding</span> <span class="hl-attribute">key</span>=<span class="hl-value">"foo"</span> <span class="hl-attribute">queue</span>=<span class="hl-value">"bar"</span><span class="hl-tag">/&gt;</span>
	<span class="hl-tag">&lt;/rabbit:bindings&gt;</span>
<span class="hl-tag">&lt;/rabbit:direct-exchange&gt;</span></pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The <code class="literal">auto-declare</code> attribute is <code class="literal">true</code> by default and if the <code class="literal">declared-by</code> is not supplied (or is empty) then all <code class="literal">RabbitAdmin</code> s will declare the object (as long as the admin’s <code class="literal">auto-startup</code> attribute is true; the default).</p>
</td></tr></tbody></table></div>
<p>Similarly, you can use Java-based <code class="literal">@Configuration</code> to achieve the same effect.
In this example, the components will be declared by <code class="literal">admin1</code> but not <code class="literal">admin2</code>:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> RabbitAdmin admin() {
    RabbitAdmin rabbitAdmin = <span class="hl-keyword">new</span> RabbitAdmin(cf1());
    rabbitAdmin.afterPropertiesSet();
    <span class="hl-keyword">return</span> rabbitAdmin;
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> RabbitAdmin admin2() {
    RabbitAdmin rabbitAdmin = <span class="hl-keyword">new</span> RabbitAdmin(cf2());
    rabbitAdmin.afterPropertiesSet();
    <span class="hl-keyword">return</span> rabbitAdmin;
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> Queue queue() {
    Queue queue = <span class="hl-keyword">new</span> Queue(<span class="hl-string">"foo"</span>);
    queue.setAdminsThatShouldDeclare(admin());
    <span class="hl-keyword">return</span> queue;
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> Exchange exchange() {
    DirectExchange exchange = <span class="hl-keyword">new</span> DirectExchange(<span class="hl-string">"bar"</span>);
    exchange.setAdminsThatShouldDeclare(admin());
    <span class="hl-keyword">return</span> exchange;
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> Binding binding() {
    Binding binding = <span class="hl-keyword">new</span> Binding(<span class="hl-string">"foo"</span>, DestinationType.QUEUE, exchange().getName(), <span class="hl-string">"foo"</span>, null);
    binding.setAdminsThatShouldDeclare(admin());
    <span class="hl-keyword">return</span> binding;
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="anonymous-queue" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#anonymous-queue"></a>AnonymousQueue</h4></div></div></div>
<p>In general, when needing a uniquely-named, exclusive, auto-delete queue, it is recommended that the <code class="literal">AnonymousQueue</code> is
used instead of broker-defined queue names (using <code class="literal">""</code> as a <code class="literal">Queue</code> name will cause the broker to generate the queue
name).</p>
<p>This is because:</p>
<div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
The queues are actually declared when the connection to the broker is established; this is long after the beans are
created and wired together; beans using the queue need to know its name.
In fact, the broker might not even be running when the app is started.
</li><li class="listitem">
If the connection to the broker is lost for some reason, the admin will re-declare the <code class="literal">AnonymousQueue</code> with the same
name.
If we used broker-declared queues, the queue name would change.
</li></ol></div>
<p>Starting with <span class="emphasis"><em>version 1.5.3</em></span>, you can control the format of the queue name used by <code class="literal">AnonymousQueue</code> s.</p>
<p>By default, the queue name is the String representation of a <code class="literal">UUID</code>; for example:
<code class="literal">07afcfe9-fe77-4983-8645-0061ec61a47a</code>.</p>
<p>You can now provide an <code class="literal">AnonymousQueue.NamingStrategy</code> implementation in a constructor argument:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> Queue anon1() {
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> AnonymousQueue(<span class="hl-keyword">new</span> AnonymousQueue.Base64UrlNamingStrategy());
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> Queue anon2() {
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> AnonymousQueue(<span class="hl-keyword">new</span> AnonymousQueue.Base64UrlNamingStrategy(<span class="hl-string">"foo-"</span>));
}</pre>
<p>The first will generate a queue name prefixed by <code class="literal">spring.gen-</code> followed by a base64 representation of the <code class="literal">UUID</code>, for
example: <code class="literal">spring.gen-MRBv9sqISkuCiPfOYfpo4g</code>.
The second will generate a queue name prefixed by <code class="literal">foo-</code> followed by a base64 representation of the <code class="literal">UUID</code>.</p>
<p>The base64 encoding uses the "URL and Filename Safe Alphabet" from RFC 4648; trailing padding characters (<code class="literal">=</code>) are
removed.</p>
<p>You can provide your own naming strategy, whereby you can include other information (e.g. application, client host) in
the queue name.</p>
<p>Starting with <span class="emphasis"><em>version 1.6</em></span>, the naming strategy can be specified when using XML configuration;
the <code class="literal">naming-strategy</code> attribute is present on the <code class="literal">&lt;rabbit:queue&gt;</code> element
for a bean reference that implements <code class="literal">AnonymousQueue.NamingStrategy</code>.</p>
<pre class="programlisting"><span class="hl-tag">&lt;rabbit:queue</span> <span class="hl-attribute">id</span>=<span class="hl-value">"uuidAnon"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;rabbit:queue</span> <span class="hl-attribute">id</span>=<span class="hl-value">"springAnon"</span> <span class="hl-attribute">naming-strategy</span>=<span class="hl-value">"springNamer"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;rabbit:queue</span> <span class="hl-attribute">id</span>=<span class="hl-value">"customAnon"</span> <span class="hl-attribute">naming-strategy</span>=<span class="hl-value">"customNamer"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"springNamer"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.amqp.core.AnonymousQueue.Base64UrlNamingStrategy"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"customNamer"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.amqp.core.AnonymousQueue.Base64UrlNamingStrategy"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"custom.gen-"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>The first creates names with a String representation of a UUID.
The second creates names like <code class="literal">spring.gen-MRBv9sqISkuCiPfOYfpo4g</code>.
The third creates names like <code class="literal">custom.gen-MRBv9sqISkuCiPfOYfpo4g</code>.</p>
<p>Of course, you can provide your own naming strategy bean.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="delayed-message-exchange" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#delayed-message-exchange"></a>3.1.11&nbsp;Delayed Message Exchange</h3></div></div></div>
<p><span class="emphasis"><em>Version 1.6</em></span> introduces support for the
<a class="ulink" href="https://www.rabbitmq.com/blog/2015/04/16/scheduling-messages-with-rabbitmq/" target="_top">Delayed Message Exchange Plugin</a></p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The plugin is currently marked as experimental but has been available for over a year (at the time of writing).
If changes to the plugin make it necessary, we will add support for such changes as soon as practical.
For that reason, this support in Spring AMQP should be considered experimental, too.
This functionality was tested with RabbitMQ 3.6.0 and version 0.0.1 of the plugin.</p>
</td></tr></tbody></table></div>
<p>To use a <code class="literal">RabbitAdmin</code> to declare an exchange as delayed, simply set the <code class="literal">delayed</code> property on the exchange bean to
true.
The <code class="literal">RabbitAdmin</code> will use the exchange type (<code class="literal">Direct</code>, <code class="literal">Fanout</code> etc) to set the <code class="literal">x-delayed-type</code> argument and
declare the exchange with type <code class="literal">x-delayed-message</code>.</p>
<p>The <code class="literal">delayed</code> property (default <code class="literal">false</code>) is also available when configuring exchange beans using XML.</p>
<pre class="programlisting"><span class="hl-tag">&lt;rabbit:topic-exchange</span> <span class="hl-attribute">name</span>=<span class="hl-value">"topic"</span> <span class="hl-attribute">delayed</span>=<span class="hl-value">"true"</span><span class="hl-tag"> /&gt;</span></pre>
<p>To send a delayed message, it’s simply a matter of setting the <code class="literal">x-delay</code> header, via the <code class="literal">MessageProperties</code>:</p>
<pre class="programlisting">MessageProperties properties = <span class="hl-keyword">new</span> MessageProperties();
properties.setDelay(<span class="hl-number">15000</span>);
template.send(exchange, routingKey,
        MessageBuilder.withBody(<span class="hl-string">"foo"</span>.getBytes()).andProperties(properties).build());</pre>
<p>or</p>
<pre class="programlisting">rabbitTemplate.convertAndSend(exchange, routingKey, <span class="hl-string">"foo"</span>, <span class="hl-keyword">new</span> MessagePostProcessor() {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">public</span> Message postProcessMessage(Message message) <span class="hl-keyword">throws</span> AmqpException {
        message.getMessageProperties().setDelay(<span class="hl-number">15000</span>);
        <span class="hl-keyword">return</span> message;
    }

});</pre>
<p>To check if a message was delayed, use the <code class="literal">getReceivedDelay()</code> method on the <code class="literal">MessageProperties</code>.
It is a separate property to avoid unintended propagation to an output message generated from an input message.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="management-template" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#management-template"></a>3.1.12&nbsp;RabbitMQ REST API</h3></div></div></div>
<p>When the management plugin is enabled, the RabbitMQ server exposes a REST API to monitor and configure the broker.
A <a class="ulink" href="https://github.com/rabbitmq/hop" target="_top">Java Binding for the API</a> is now provided.
In general, you can use that API directly, but a convenience wrapper is provided to use the familiar Spring AMQP <code class="literal">Queue</code>, <code class="literal">Exchange</code>, and <code class="literal">Binding</code> domain objects with the API.
Much more information is available for these objects when using the <code class="literal">com.rabbitmq.http.client.Client</code> API directly
(<code class="literal">QueueInfo</code>, <code class="literal">ExchangeInfo</code>, and <code class="literal">BindingInfo</code> respectively).
The following operations are available on the <code class="literal">RabbitManagementTemplate</code>:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> AmqpManagementOperations {

    <span class="hl-keyword">void</span> addExchange(Exchange exchange);

    <span class="hl-keyword">void</span> addExchange(String vhost, Exchange exchange);

    <span class="hl-keyword">void</span> purgeQueue(Queue queue);

    <span class="hl-keyword">void</span> purgeQueue(String vhost, Queue queue);

    <span class="hl-keyword">void</span> deleteQueue(Queue queue);

    <span class="hl-keyword">void</span> deleteQueue(String vhost, Queue queue);

    Queue getQueue(String name);

    Queue getQueue(String vhost, String name);

    List&lt;Queue&gt; getQueues();

    List&lt;Queue&gt; getQueues(String vhost);

    <span class="hl-keyword">void</span> addQueue(Queue queue);

    <span class="hl-keyword">void</span> addQueue(String vhost, Queue queue);

    <span class="hl-keyword">void</span> deleteExchange(Exchange exchange);

    <span class="hl-keyword">void</span> deleteExchange(String vhost, Exchange exchange);

    Exchange getExchange(String name);

    Exchange getExchange(String vhost, String name);

    List&lt;Exchange&gt; getExchanges();

    List&lt;Exchange&gt; getExchanges(String vhost);

    List&lt;Binding&gt; getBindings();

    List&lt;Binding&gt; getBindings(String vhost);

    List&lt;Binding&gt; getBindingsForExchange(String vhost, String exchange);

}</pre>
<p>Refer to the javadocs for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="exception-handling" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#exception-handling"></a>3.1.13&nbsp;Exception Handling</h3></div></div></div>
<p>Many operations with the RabbitMQ Java client can throw checked Exceptions.
For example, there are a lot of cases where IOExceptions may be thrown.
The RabbitTemplate, SimpleMessageListenerContainer, and other Spring AMQP components will catch those Exceptions and convert into one of the Exceptions within our runtime hierarchy.
Those are defined in the <span class="emphasis"><em>org.springframework.amqp</em></span> package, and AmqpException is the base of the hierarchy.</p>
<p>When a listener throws an exception, it is wrapped in a <code class="literal">ListenerExecutionFailedException</code> and, normally the message is
rejected and requeued by the broker.
Setting <code class="literal">defaultRequeueRejected</code> to false will cause messages to be discarded (or routed to a dead letter exchange).
As discussed in <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#async-listeners" title="Message Listeners and the Asynchronous Case">the section called “Message Listeners and the Asynchronous Case”</a>, the listener can throw an <code class="literal">AmqpRejectAndDontRequeueException</code> to conditionally
control this behavior.</p>
<p>However, there is a class of errors where the listener cannot control the behavior.
When a message that cannot be converted is encountered (for example an invalid <code class="literal">content_encoding</code> header), some
exceptions are thrown before the message reaches user code.
With <code class="literal">defaultRequeueRejected</code> set to <code class="literal">true</code> (default), such messages would be redelivered over and over.
Before <span class="emphasis"><em>version 1.3.2</em></span>, users needed to write a custom <code class="literal">ErrorHandler</code>, as discussed in <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#exception-handling" title="3.1.13 Exception Handling">Section&nbsp;3.1.13, “Exception Handling”</a> to avoid
this situation.</p>
<p>Starting with <span class="emphasis"><em>version 1.3.2</em></span>, the default <code class="literal">ErrorHandler</code> is now a <code class="literal">ConditionalRejectingErrorHandler</code> which will reject
(and not requeue) messages that fail with an irrecoverable error:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">o.s.amqp...MessageConversionException</code>
</li><li class="listitem">
<code class="literal">o.s.messaging...MessageConversionException</code>
</li><li class="listitem">
<code class="literal">o.s.messaging...MethodArgumentNotValidException</code>
</li><li class="listitem">
<code class="literal">o.s.messaging...MethodArgumentTypeMismatchException</code>
</li><li class="listitem">
<code class="literal">java.lang.NoSuchMethodException</code>
</li><li class="listitem">
<code class="literal">java.lang.ClassCastException</code>
</li></ul></div>
<p>The first can be thrown when converting the incoming message payload using a <code class="literal">MessageConverter</code>.
The second may be thrown by the conversion service if additional conversion is required when mapping to a
<code class="literal">@RabbitListener</code> method.
The third may be thrown if validation (e.g. <code class="literal">@Valid</code>) is used in the listener and the validation fails.
The fourth may be thrown if the inbound message was converted to a type that is not correct for the target method.
For example, the parameter is declared as <code class="literal">Message&lt;Foo&gt;</code> but <code class="literal">Message&lt;Bar&gt;</code> is received.</p>
<p>The fifth and sixth were added in <span class="emphasis"><em>version 1.6.3</em></span>.</p>
<p>An instance of this error handler can be configured with a <code class="literal">FatalExceptionStrategy</code> so users can provide their own rules
for conditional message rejection, e.g.
a delegate implementation to the <code class="literal">BinaryExceptionClassifier</code> from Spring Retry (<a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#async-listeners" title="Message Listeners and the Asynchronous Case">the section called “Message Listeners and the Asynchronous Case”</a>).
In addition, the <code class="literal">ListenerExecutionFailedException</code> now has a <code class="literal">failedMessage</code> property which can be used in the decision.
If the <code class="literal">FatalExceptionStrategy.isFatal()</code> method returns <code class="literal">true</code>, the error handler throws an <code class="literal">AmqpRejectAndDontRequeueException</code>.
The default <code class="literal">FatalExceptionStrategy</code> logs a warning message when an exception is determined to be fatal.</p>
<p>Since <span class="emphasis"><em>version 1.6.3</em></span> a convenient way to add user exceptions to the fatal list is to subclass <code class="literal">ConditionalRejectingErrorHandler.DefaultExceptionStrategy</code> and override the method <code class="literal">isUserCauseFatal(Throwable cause)</code> to return true for fatal exceptions.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="transactions" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#transactions"></a>3.1.14&nbsp;Transactions</h3></div></div></div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_introduction_12" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction_12"></a>Introduction</h4></div></div></div>
<p>The Spring Rabbit framework has support for automatic transaction management in the synchronous and asynchronous use cases with a number of different semantics that can be selected declaratively, as is familiar to existing users of Spring transactions.
This makes many if not most common messaging patterns very easy to implement.</p>
<p>There are two ways to signal the desired transaction semantics to the framework.
In both the <code class="literal">RabbitTemplate</code> and <code class="literal">SimpleMessageListenerContainer</code> there is a flag <code class="literal">channelTransacted</code> which, if true, tells the framework to use a transactional channel and to end all operations (send or receive) with a commit or rollback depending on the outcome, with an exception signaling a rollback.
Another signal is to provide an external transaction with one of Spring’s <code class="literal">PlatformTransactionManager</code> implementations as a context for the ongoing operation.
If there is already a transaction in progress when the framework is sending or receiving a message, and the <code class="literal">channelTransacted</code> flag is true, then the commit or rollback of the messaging transaction will be deferred until the end of the current transaction.
If the <code class="literal">channelTransacted</code> flag is false, then no transaction semantics apply to the messaging operation (it is auto-acked).</p>
<p>The <code class="literal">channelTransacted</code> flag is a configuration time setting: it is declared and processed once when the AMQP components are created, usually at application startup.
The external transaction is more dynamic in principle because the system responds to the current Thread state at runtime, but in practice is often also a configuration setting, when the transactions are layered onto an application declaratively.</p>
<p>For synchronous use cases with <code class="literal">RabbitTemplate</code> the external transaction is provided by the caller, either declaratively or imperatively according to taste (the usual Spring transaction model).
An example of a declarative approach (usually preferred because it is non-invasive), where the template has been configured with <code class="literal">channelTransacted=true</code>:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Transactional</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doSomething() {
    String incoming = rabbitTemplate.receiveAndConvert();
    <span class="hl-comment">// do some more database processing...</span>
    String outgoing = processInDatabaseAndExtractReply(incoming);
    rabbitTemplate.convertAndSend(outgoing);
}</pre>
<p>A String payload is received, converted and sent as a message body inside a method marked as @Transactional, so if the database processing fails with an exception, the incoming message will be returned to the broker, and the outgoing message will not be sent.
This applies to any operations with the <code class="literal">RabbitTemplate</code> inside a chain of transactional methods (unless the <code class="literal">Channel</code> is directly manipulated to commit the transaction early for instance).</p>
<p>For asynchronous use cases with <code class="literal">SimpleMessageListenerContainer</code> if an external transaction is needed it has to be requested by the container when it sets up the listener.
To signal that an external transaction is required the user provides an implementation of <code class="literal">PlatformTransactionManager</code> to the container when it is configured.
For example:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ExampleExternalTransactionAmqpConfiguration {

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> SimpleMessageListenerContainer messageListenerContainer() {
        SimpleMessageListenerContainer container = <span class="hl-keyword">new</span> SimpleMessageListenerContainer();
        container.setConnectionFactory(rabbitConnectionFactory());
        container.setTransactionManager(transactionManager());
        container.setChannelTransacted(true);
        container.setQueueName(<span class="hl-string">"some.queue"</span>);
        container.setMessageListener(exampleListener());
        <span class="hl-keyword">return</span> container;
    }

}</pre>
<p>In the example above, the transaction manager is added as a dependency injected from another bean definition (not shown), and the <code class="literal">channelTransacted</code> flag is also set to true.
The effect is that if the listener fails with an exception the transaction will be rolled back, and the message will also be returned to the broker.
Significantly, if the transaction fails to commit (e.g.
a database constraint error, or connectivity problem), then the AMQP transaction will also be rolled back, and the message will be returned to the broker.
This is sometimes known as a Best Efforts 1 Phase Commit, and is a very powerful pattern for reliable messaging.
If the <code class="literal">channelTransacted</code> flag was set to false in the example above, which is the default, then the external transaction would still be provided for the listener, but all messaging operations would be auto-acked, so the effect is to commit the messaging operations even on a rollback of the business operation.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="conditional-rollback" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#conditional-rollback"></a>Conditional Rollback</h4></div></div></div>
<p>Prior to <span class="emphasis"><em>version 1.6.6</em></span>, adding a rollback rule to a container’s <code class="literal">transactionAttribute</code>, when using an external transaction manager (e.g. JDBC) had no effect; exceptions always rolled back the transaction.</p>
<p>Also, when using a <a class="ulink" href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/transaction.html#transaction-declarative" target="_top">transaction advice</a> in the container’s advice chain, conditional rollback was not very useful because all listener exceptions are wrapped in a <code class="literal">ListenerExecutionFailedException</code>.</p>
<p>The first problem has been corrected and the rules are now applied properly.
Further, the <code class="literal">ListenerFailedRuleBasedTransactionAttribute</code> is now provided; it is a subclass of <code class="literal">RuleBasedTransactionAttribute</code>, with the only difference being that it is aware of the <code class="literal">ListenerExecutionFailedException</code> and uses the cause of such exceptions for the rule.
This transaction attribute can be used directly in the container, or via a transaction advice.</p>
<p>An example of using this rule follows:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> AbstractMessageListenerContainer container() {
    ...
    container.setTransactionManager(transactionManager);
    RuleBasedTransactionAttribute transactionAttribute =
        <span class="hl-keyword">new</span> ListenerFailedRuleBasedTransactionAttribute();
    transactionAttribute.setRollbackRules(Collections.singletonList(
        <span class="hl-keyword">new</span> NoRollbackRuleAttribute(DontRollBackException.<span class="hl-keyword">class</span>)));
    container.setTransactionAttribute(transactionAttribute);
    ...
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="transaction-rollback" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#transaction-rollback"></a>A note on Rollback of Received Messages</h4></div></div></div>
<p>AMQP transactions only apply to messages and acks sent to the broker, so when there is a rollback of a Spring transaction and a message has been received, what Spring AMQP has to do is not just rollback the transaction, but also manually reject the message (sort of a nack, but that’s not what the specification calls it).
The action taken on message rejection is independent of transactions and depends on the <code class="literal">defaultRequeueRejected</code> property (default <code class="literal">true</code>).
For more information about rejecting failed messages, see <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#async-listeners" title="Message Listeners and the Asynchronous Case">the section called “Message Listeners and the Asynchronous Case”</a>.</p>
<p>For more information about RabbitMQ transactions, and their limitations, refer to <a class="ulink" href="https://www.rabbitmq.com/semantics.html" target="_top">RabbitMQ Broker Semantics</a>.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Prior to <span class="strong"><strong>RabbitMQ 2.7.0</strong></span>, such messages (and any that are unacked when a channel is closed or aborts) went to the back of the queue on a Rabbit broker, since 2.7.0, rejected messages go to the front of the queue, in a similar manner to JMS rolled back messages.</p>
</td></tr></tbody></table></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Message requeue on transaction rollback is inconsistent between local transactions and when a <code class="literal">TransactionManager</code> is provided.
In the former case, the normal requeue logic (<code class="literal">AmqpRejectAndDontRequeueException</code> or <code class="literal">defaultRequeueRejected=false</code>) applies (see <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#async-listeners" title="Message Listeners and the Asynchronous Case">the section called “Message Listeners and the Asynchronous Case”</a>); with a transaction manager, the message is unconditionally requeued on rollback.
Starting with <span class="emphasis"><em>version 1.7.1</em></span>, you can enable the consistent behavior by setting the container’s <code class="literal">alwaysRequeueWithTxManagerRollback</code> property to <code class="literal">false</code>; it will be <code class="literal">false</code> by default in 2.0.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#containerAttributes" title="3.1.15 Message Listener Container Configuration">Section&nbsp;3.1.15, “Message Listener Container Configuration”</a>.</p>
</td></tr></tbody></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_using_the_rabbittransactionmanager" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_using_the_rabbittransactionmanager"></a>Using the RabbitTransactionManager</h4></div></div></div>
<p>The <a class="ulink" href="http://static.springsource.org/spring-amqp/docs/latest_ga/api/org/springframework/amqp/rabbit/transaction/RabbitTransactionManager.html" target="_top">RabbitTransactionManager</a> is an alternative to executing Rabbit operations within, and synchronized with, external transactions.
This Transaction Manager is an implementation of the <a class="ulink" href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/transaction/PlatformTransactionManager.html" target="_top">PlatformTransactionManager</a> interface and should be used with a single Rabbit ConnectionFactory.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./Spring AMQP_files/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>This strategy is not able to provide XA transactions, for example in order to share transactions between messaging and database access.</p>
</td></tr></tbody></table></div>
<p>Application code is required to retrieve the transactional Rabbit resources via <code class="literal">ConnectionFactoryUtils.getTransactionalResourceHolder(ConnectionFactory, boolean)</code> instead of a standard <code class="literal">Connection.createChannel()</code> call with subsequent Channel creation.
When using Spring AMQP’s <a class="ulink" href="http://static.springsource.org/spring-amqp/docs/latest_ga/api/org/springframework/amqp/rabbit/core/RabbitTemplate.html" target="_top">RabbitTemplate</a>, it will autodetect a thread-bound Channel and automatically participate in its transaction.</p>
<p>With Java Configuration you can setup a new RabbitTransactionManager using:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> RabbitTransactionManager rabbitTransactionManager() {
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> RabbitTransactionManager(connectionFactory);
}</pre>
<p>If you prefer using XML configuration, declare the following bean in your XML Application Context file:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"rabbitTxManager"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.amqp.rabbit.transaction.RabbitTransactionManager"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"connectionFactory"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="containerAttributes" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#containerAttributes"></a>3.1.15&nbsp;Message Listener Container Configuration</h3></div></div></div>
<p>There are quite a few options for configuring a <code class="literal">SimpleMessageListenerContainer</code> related to transactions and quality of service, and some of them interact with each other.</p>
<p>The table below shows the container property names and their equivalent attribute names (in parentheses) when using the namespace to configure a <code class="literal">&lt;rabbit:listener-container/&gt;</code>.</p>
<p>Some properties are not exposed by the namespace; indicated by <code class="literal">N/A</code> for the attribute.</p>
<div class="table"><a name="d5e2418" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#d5e2418"></a><p class="title"><b>Table&nbsp;3.3.&nbsp;Configuration options for a message listener container</b></p><div class="table-contents">
<table summary="Configuration options for a message listener container" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Property
(Attribute)</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">(group)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>This is only available when using the namespace.
When specified, a bean of type <code class="literal">Collection&lt;MessageListenerContainer&gt;</code> is registered with this name, and the
container for each <code class="literal">&lt;listener/&gt;</code> element is added to the collection.
This allows, for example, starting/stopping the group of containers by iterating over the collection.
If multiple <code class="literal">&lt;listener-container/&gt;</code> elements have the same group value, the containers in the collection is
an aggregate of all containers so designated.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">channelTransacted
(channel-transacted)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Boolean flag to signal that all messages should be acknowledged in a transaction (either manually or automatically)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">acknowledgeMode
(acknowledge)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">NONE</code> = no acks will be sent (incompatible with <code class="literal">channelTransacted=true</code>).
RabbitMQ calls this "autoack" because the broker assumes all messages are acked without any action from the consumer.
</li><li class="listitem">
<code class="literal">MANUAL</code> = the listener must acknowledge all messages by calling <code class="literal">Channel.basicAck()</code>.
</li><li class="listitem">
<code class="literal">AUTO</code> = the container will acknowledge the message automatically, unless the <code class="literal">MessageListener</code> throws an exception.
Note that <code class="literal">acknowledgeMode</code> is complementary to channelTransacted - if the channel is transacted then the broker requires a commit notification in addition to the ack.
This is the default mode.
See also <code class="literal">txSize</code>.
</li></ul></div></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">transactionManager
(transaction-manager)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>External transaction manager for the operation of the listener.
Also complementary to channelTransacted - if the <code class="literal">Channel</code> is transacted then its transaction will be synchronized with the external transaction.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">prefetchCount
(prefetch)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The number of messages to accept from the broker in one socket frame.
The higher this is the faster the messages can be delivered, but the higher the risk of non-sequential processing.
Ignored if the <code class="literal">acknowledgeMode</code> is NONE.
This will be increased, if necessary, to match the <code class="literal">txSize</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">shutdownTimeout
(N/A)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>When a container shuts down (e.g.
if its enclosing <code class="literal">ApplicationContext</code> is closed) it waits for in-flight messages to be processed up to this limit.
Defaults to 5 seconds.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><div class="informalfigure">
<div class="mediaobject"><img src="./Spring AMQP_files/tickmark.png" alt="tickmark"></div>
</div></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><div class="informalfigure">
<div class="mediaobject"><img src="./Spring AMQP_files/tickmark.png" alt="tickmark"></div>
</div></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">forceCloseChannel
(N/A)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>If the consumers don’t respond to a shutdown within <code class="literal">shutdownTimeout</code>, if this is <code class="literal">true</code>, the channel will be closed, causing any unacked messages to be requeued.
Default <code class="literal">false</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">txSize
(transaction-size)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>When used with <code class="literal">acknowledgeMode</code> AUTO, the container will attempt to process up to this number of messages before sending an ack (waiting for each one up to the receive timeout setting).
This is also when a transactional channel is committed.
If the <code class="literal">prefetchCount</code> is less than the <code class="literal">txSize</code>, it will be increased to match the <code class="literal">txSize</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">receiveTimeout
(receive-timeout)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The maximum time to wait for each message.
If acknowledgeMode=NONE this has very little effect - the container just spins round and asks for another message.
It has the biggest effect for a transactional <code class="literal">Channel</code> with <code class="literal">txSize &gt; 1</code>, since it can cause messages already consumed not to be acknowledged until the timeout expires.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">autoStartup
(auto-startup)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Flag to indicate that the container should start when the <code class="literal">ApplicationContext</code> does (as part of the <code class="literal">SmartLifecycle</code> callbacks which happen after all beans are initialized).
Defaults to true, but set it to false if your broker might not be available on startup, and then call <code class="literal">start()</code> later manually when you know the broker is ready.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">phase
(phase)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>When autoStartup is true, the lifecycle phase within which this container should start and stop.
The lower the value the earlier this container will start and the later it will stop.
The default is Integer.MAX_VALUE meaning the container will start as late as possible and stop as soon as possible.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">adviceChain
(advice-chain)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>An array of AOP Advice to apply to the listener execution.
This can be used to apply additional cross cutting concerns such as automatic retry in the event of broker death.
Note that simple re-connection after an AMQP error is handled by the <code class="literal">CachingConnectionFactory</code>, as long as the broker is still alive.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">taskExecutor
(task-executor)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>A reference to a Spring TaskExecutor (or standard JDK 1.5+ Executor) for executing listener invokers.
Default is a SimpleAsyncTaskExecutor, using internally managed threads.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">errorHandler
(error-handler)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>A reference to an ErrorHandler strategy for handling any uncaught Exceptions that may occur during the execution of the MessageListener.
Default: <code class="literal">ConditionalRejectingErrorHandler</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">concurrentConsumers
(concurrency)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The number of concurrent consumers to initially start for each listener.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#listener-concurrency" title="3.1.16 Listener Concurrency">Section&nbsp;3.1.16, “Listener Concurrency”</a>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">maxConcurrentConsumers
(max-concurrency)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The maximum number of concurrent consumers to start, if needed, on demand.
Must be greater than or equal to <span class="emphasis"><em>concurrentConsumers</em></span>.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#listener-concurrency" title="3.1.16 Listener Concurrency">Section&nbsp;3.1.16, “Listener Concurrency”</a>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">concurrency
(N/A)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">m-n</code> The range of concurrent consumers for each listener (min, max).
If only <code class="literal">n</code> is provided, <code class="literal">n</code> is a fixed number of consumers.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#listener-concurrency" title="3.1.16 Listener Concurrency">Section&nbsp;3.1.16, “Listener Concurrency”</a>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">consumerStartTimeout
(N/A)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The time in milliseconds to wait for a consumer thread to start.
If this time elapses an error log is written; an example of when this might happen is if a <code class="literal">taskExecutor</code> was configured that has insufficient threads to support the container <code class="literal">concurrentConsumers</code>.
</p><p>See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#threading" title="Threading and Asynchronous Consumers">the section called “Threading and Asynchronous Consumers”</a>.
Default 60000 (60 seconds).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">startConsumerMin
Interval
(min-start-interval)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The time in milliseconds which must elapse before each new consumer is started on demand.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#listener-concurrency" title="3.1.16 Listener Concurrency">Section&nbsp;3.1.16, “Listener Concurrency”</a>.
Default 10000 (10 seconds).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">stopConsumerMinInterval
(min-stop-interval)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The time in milliseconds which must elapse before a consumer is stopped, since the last consumer was stopped, when an idle consumer is detected.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#listener-concurrency" title="3.1.16 Listener Concurrency">Section&nbsp;3.1.16, “Listener Concurrency”</a>.
Default 60000 (1 minute).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">consecutiveActiveTrigger
(min-consecutive-active)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The minimum number of consecutive messages received by a consumer, without a receive timeout occurring, when considering starting a new consumer.
Also impacted by <span class="emphasis"><em>txSize</em></span>.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#listener-concurrency" title="3.1.16 Listener Concurrency">Section&nbsp;3.1.16, “Listener Concurrency”</a>.
Default 10.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">consecutiveIdleTrigger
(min-consecutive-idle)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The minimum number of receive timeouts a consumer must experience before considering stopping a consumer.
Also impacted by <span class="emphasis"><em>txSize</em></span>.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#listener-concurrency" title="3.1.16 Listener Concurrency">Section&nbsp;3.1.16, “Listener Concurrency”</a>.
Default 10.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">connectionFactory
(connection-factory)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>A reference to the <code class="literal">ConnectionFactory</code>; when configuring using the XML namespace, the default referenced bean name is "rabbitConnectionFactory".</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">defaultRequeueRejected
(requeue-rejected)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Determines whether messages that are rejected because the listener threw an exception should be requeued or not.
Default <span class="emphasis"><em>true</em></span>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">recoveryInterval
(recovery-interval)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Determines the time in milliseconds between attempts to start a consumer if it fails to start for non-fatal reasons.
Default <span class="emphasis"><em>5000</em></span>.
Mutually exclusive with <code class="literal">recoveryBackOff</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">recoveryBackOff
(recovery-back-off)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Specifies the <code class="literal">BackOff</code> for intervals between attempts to start a consumer if it fails to start for non-fatal reasons.
Default is <code class="literal">FixedBackOff</code> with unlimited retries every 5 seconds.
Mutually exclusive with <code class="literal">recoveryInterval</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">exclusive
(exclusive)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Determines whether the single consumer in this container has exclusive access to the queue(s).
The concurrency of the container must be 1 when this is true.
If another consumer has exclusive access, the container will attempt to recover the consumer, according to the
<code class="literal">recovery-interval</code> or <code class="literal">recovery-back-off</code>.
When using the namespace, this attribute appears on the &lt;rabbit:listener/&gt; element along with the queue names.
Default <span class="emphasis"><em>false</em></span>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">rabbitAdmin
(admin)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>When a listener container listens to at least one auto-delete queue and it is found to be missing during startup, the container uses a <code class="literal">RabbitAdmin</code> to declare the queue and any related bindings and exchanges.
If such elements are configured to use conditional declaration (see <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#conditional-declaration" title="Conditional Declaration">the section called “Conditional Declaration”</a>), the container must use the admin that was configured to declare those elements.
Specify that admin here; only required when using auto-delete queues with conditional declaration.
If you do not wish the auto-delete queue(s) to be declared until the container is started, set <code class="literal">auto-startup</code> to <code class="literal">false</code> on the admin.
Defaults to a <code class="literal">RabbitAdmin</code> that will declare all non-conditional elements.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">missingQueuesFatal
(missing-queues-fatal)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Starting with <span class="emphasis"><em>version 1.3.5</em></span>, <code class="literal">SimpleMessageListenerContainer</code> has this new property.</p>
<p>When set to <code class="literal">true</code> (default), if none of the configured queues are available on the broker, it is considered fatal.
This causes the application context to fail to initialize during startup; also, when the queues are deleted while the container is running, by default, the consumers make 3 retries to connect to the queues (at 5 second intervals) and stop the container if these attempts fail.</p>
<p>This was not configurable in previous versions.</p>
<p>When set to <code class="literal">false</code>, after making the 3 retries, the container will go into recovery mode, as with other problems, such as the broker being down.
The container will attempt to recover according to the <code class="literal">recoveryInterval</code> property.
During each recovery attempt, each consumer will again try 4 times to passively declare the queues at 5 second intervals.
This process will continue indefinitely.</p>
<p>You can also use a properties bean to set the property globally for all containers, as follows:</p>
<pre class="programlisting"><span class="hl-tag">&lt;util:properties</span> <span class="hl-attribute">id</span>=<span class="hl-value">"spring.amqp.global.properties"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;prop</span> <span class="hl-attribute">key</span>=<span class="hl-value">"smlc.missing.queues.fatal"</span><span class="hl-tag">&gt;</span>false<span class="hl-tag">&lt;/prop&gt;</span>
<span class="hl-tag">&lt;/util:properties&gt;</span></pre>
<p>This global property will not be applied to any containers that have an explicit <code class="literal">missingQueuesFatal</code> property set.</p>
<p>The default retry properties (3 retries at 5 second intervals) can be overridden using the properties below.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">mismatchedQueuesFatal
(mismatched-queues-fatal)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>This was added in <span class="emphasis"><em>version 1.6</em></span>.
When the container starts, if this property is true (default: false), the container checks that all queues declared in
the context are compatible with queues already on the broker.
If mismatched properties (e.g. <code class="literal">auto-delete</code>) or arguments (e.g. <code class="literal">x-message-ttl</code>) exist, the container
(and application context) will fail to start with a fatal exception.</p>
<p>If the problem is detected during recovery (e.g. after a lost connection), the container will be stopped.</p>
<p>There must be a single <code class="literal">RabbitAdmin</code> in the application context (or one specifically configured on the container
using the <code class="literal">rabbitAdmin</code> property); otherwise this property must be <code class="literal">false</code>.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>If the broker is not available during initial startup, the container will start and the conditions will be
checked when the connection is established.</p>
</td></tr></tbody></table></div>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./Spring AMQP_files/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>the check is done against all queues in the context, not just the queues that a particular listener
is configured to use.
If you wish to limit the checks to just those queues used by a container, you should configure a separate
<code class="literal">RabbitAdmin</code> for the container, and provide a reference to it using the <code class="literal">rabbitAdmin</code> property.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#conditional-declaration" title="Conditional Declaration">the section called “Conditional Declaration”</a> for more information.</p>
</td></tr></tbody></table></div></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">possibleAuthenticationFailureFatal
(possible-authentication-failure-fatal)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>When set to <code class="literal">true</code> (default), if a <code class="literal">PossibleAuthenticationFailureException</code> is thrown during connection, it is considered fatal.
This causes the application context to fail to initialize during startup.</p>
<p>Since <span class="emphasis"><em>version 1.7.4</em></span>.</p>
<p>When set to <code class="literal">false</code>, after making the 3 retries, the container will go into recovery mode, as with other problems, such as the broker being down.
The container will attempt to recover according to the <code class="literal">recoveryInterval</code> property.
During each recovery attempt, each consumer will again try 4 times to start.
This process will continue indefinitely.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">autoDeclare
(auto-declare)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Starting with <span class="emphasis"><em>version 1.4</em></span>, <code class="literal">SimpleMessageListenerContainer</code> has this new property.</p>
<p>When set to <code class="literal">true</code> (default), the container will use a <code class="literal">RabbitAdmin</code> to redeclare all AMQP objects (Queues, Exchanges,
Bindings), if it detects that at least one of its queues is missing during startup, perhaps because it’s an
<code class="literal">auto-delete</code> or an expired queue, but the redeclaration will proceed if the queue is missing for any reason.
To disable this behavior, set this property to <code class="literal">false</code>.
Note that the container will fail to start if all of its queues are missing.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Prior to <span class="emphasis"><em>version 1.6</em></span>, if there was more than one admin in the context, the container would randomly select one.
If there were no admins, it would create one internally.
In either case, this could cause unexpected results.
Starting with <span class="emphasis"><em>version 1.6</em></span>, for <code class="literal">autoDeclare</code> to work, there must be exactly one <code class="literal">RabbitAdmin</code> in the context, or
a reference to a specific instance must be configured on the container using the <code class="literal">rabbitAdmin</code> property.</p>
</td></tr></tbody></table></div></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">declarationRetries
(declaration-retries)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Starting with <span class="emphasis"><em>versions 1.4.3, 1.3.9</em></span>, <code class="literal">SimpleMessageListenerContainer</code> has this new property.
The namespace attribute is available in <span class="emphasis"><em>version 1.5.x</em></span>
</p><p>The number of retry attempts when passive queue declaration fails.
Passive queue declaration occurs when the consumer starts or, when consuming from multiple queues, when not all queues were available during initialization.
When none of the configured queues can be passively declared (for any reason) after the retries are exhausted, the container behavior is controlled by the 'missingQueuesFatal` property above.
Default: 3 retries (4 attempts).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">failedDeclarationRetryInterval
(failed-declaration-retry-
interval)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Starting with <span class="emphasis"><em>versions 1.4.3, 1.3.9</em></span>, <code class="literal">SimpleMessageListenerContainer</code> has this new property.
The namespace attribute is available in <span class="emphasis"><em>version 1.5.x</em></span>
</p><p>The interval between passive queue declaration retry attempts.
Passive queue declaration occurs when the consumer starts or, when consuming from multiple queues, when not all queues were available during initialization.
Default: 5000 (5 seconds).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">retryDeclarationInterval
(missing-queue-retry-
interval)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Starting with <span class="emphasis"><em>versions 1.4.3, 1.3.9</em></span>, <code class="literal">SimpleMessageListenerContainer</code> has this new property.
The namespace attribute is available in <span class="emphasis"><em>version 1.5.x</em></span>
</p><p>If a subset of the configured queues are available during consumer initialization, the consumer starts consuming from those queues.
The consumer will attempt to passively declare the missing queues using this interval.
When this interval elapses, the <span class="emphasis"><em>declarationRetries</em></span> and <span class="emphasis"><em>failedDeclarationRetryInterval</em></span> will again be used.
If there are still missing queues, the consumer will again wait for this interval before trying again.
This process will continue indefinitely until all queues are available.
Default: 60000 (1 minute).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">consumerTagStrategy
(consumer-tag-strategy)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Starting with <span class="emphasis"><em>version 1.4.5</em></span>, <code class="literal">SimpleMessageListenerContainer</code> has this new property.
The namespace attribute is available in <span class="emphasis"><em>version 1.5.x</em></span>
</p><p>Previously, only broker-generated consumer tags can be used; while this is still the default, you can now provide
an implementation of <a class="link" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#consumerTags" title="Consumer Tags">ConsumerTagStrategy</a>, enabling the creation of a (unique) tag for each consumer.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">idleEventInterval
(idle-event-integer)</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Starting with <span class="emphasis"><em>version 1.6</em></span>, <code class="literal">SimpleMessageListenerContainer</code> has this new property.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#idle-containers" title="Detecting Idle Asynchronous Consumers">the section called “Detecting Idle Asynchronous Consumers”</a>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">alwaysRequeueWithTx
ManagerRollback
(N/A)</pre></td><td style="" align="left" valign="top"><p>Set to <code class="literal">true</code> to always requeue messages on rollback when a transaction manager is configured (default).
Set to <code class="literal">false</code> to configure the container to use consistent message rejection behavior regardless of whether a transaction manager is configured.</p></td></tr></tbody></table>
</div></div><br class="table-break">
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="listener-concurrency" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#listener-concurrency"></a>3.1.16&nbsp;Listener Concurrency</h3></div></div></div>
<p>By default, the listener container will start a single consumer which will receive messages from the queue(s).</p>
<p>When examining the table in the previous section, you will see a number of properties/attributes that control concurrency.
The simplest is <code class="literal">concurrentConsumers</code>, which simply creates that (fixed) number of consumers which will concurrently process messages.</p>
<p>Prior to <span class="emphasis"><em>version 1.3.0</em></span>, this was the only setting available and the container had to be stopped and started again to change the setting.</p>
<p>Since <span class="emphasis"><em>version 1.3.0</em></span>, you can now dynamically adjust the <code class="literal">concurrentConsumers</code> property.
If it is changed while the container is running, consumers will be added or removed as necessary to adjust to the new setting.</p>
<p>In addition, a new property <code class="literal">maxConcurrentConsumers</code> has been added and the container will dynamically adjust the concurrency based on workload.
This works in conjunction with four additional properties: <code class="literal">consecutiveActiveTrigger</code>, <code class="literal">startConsumerMinInterval</code>, <code class="literal">consecutiveIdleTrigger</code>, <code class="literal">stopConsumerMinInterval</code>.
With the default settings, the algorithm to increase consumers works as follows:</p>
<p>If the <code class="literal">maxConcurrentConsumers</code> has not been reached and an existing consumer is active for 10 consecutive cycles AND at least 10 seconds has elapsed since the last consumer was started, a new consumer is started.
A consumer is considered active if it received at least one message in <code class="literal">txSize</code> * <code class="literal">receiveTimeout</code> milliseconds.</p>
<p>With the default settings, the algorithm to decrease consumers works as follows:</p>
<p>If there are more than <code class="literal">concurrentConsumers</code> running and a consumer detects 10 consecutive timeouts (idle) AND the last consumer was stopped at least 60 seconds ago, a consumer will be stopped.
The timeout depends on the <code class="literal">receiveTimeout</code> and the <code class="literal">txSize</code> properties.
A consumer is considered idle if it receives no messages in <code class="literal">txSize</code> * <code class="literal">receiveTimeout</code> milliseconds.
So, with the default timeout (1 second) and a <code class="literal">txSize</code> of 4, stopping a consumer will be considered after 40 seconds of idle time (4 timeouts correspond to 1 idle detection).</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Practically, consumers will only be stopped if the whole container is idle for some time.
This is because the broker will share its work across all the active consumers.</p>
</td></tr></tbody></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="exclusive-consumer" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#exclusive-consumer"></a>3.1.17&nbsp;Exclusive Consumer</h3></div></div></div>
<p>Also starting with <span class="emphasis"><em>version 1.3</em></span>, the listener container can be configured with a single exclusive consumer; this prevents other containers from consuming from the queue(s) until the current consumer is cancelled.
The concurrency of such a container must be 1.</p>
<p>When using exclusive consumers, other containers will attempt to consume from the queue(s) according to the <code class="literal">recoveryInterval</code> property, and log a WARNing if the attempt fails.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="listener-queues" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#listener-queues"></a>3.1.18&nbsp;Listener Container Queues</h3></div></div></div>
<p><span class="emphasis"><em>version 1.3</em></span> introduced a number of improvements for handling multiple queues in a listener container.</p>
<p>The container must be configured to listen on at least one queue; this was the case previously too, but now queues can be added and removed at runtime.
The container will recycle (cancel and re-create) the consumers when any pre-fetched messages have been processed.
See methods <code class="literal">addQueues</code>, <code class="literal">addQueueNames</code>, <code class="literal">removeQueues</code> and <code class="literal">removeQueueNames</code>.
When removing queues, at least one queue must remain.</p>
<p>A consumer will now start if any of its queues are available - previously the container would stop if any queues were unavailable.
Now, this is only the case if none of the queues are available.
If not all queues are available, the container will attempt to passively declare (and consume from) the missing queue(s) every 60 seconds.</p>
<p>Also, if a consumer receives a cancel from the broker (for example if a queue is deleted) the consumer will attempt to recover and the recovered consumer will continue to process messages from any other configured queues.
Previously a cancel on one queue cancelled the entire consumer and eventually the container would stop due to the missing queue.</p>
<p>If you wish to permanently remove a queue, you should update the container before or after deleting to queue, to avoid future attempts to consume from it.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_resilience_recovering_from_errors_and_broker_failures" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_resilience_recovering_from_errors_and_broker_failures"></a>3.1.19&nbsp;Resilience: Recovering from Errors and Broker Failures</h3></div></div></div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_introduction_13" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction_13"></a>Introduction</h4></div></div></div>
<p>Some of the key (and most popular) high-level features that Spring AMQP provides are to do with recovery and automatic re-connection in the event of a protocol error or broker failure.
We have seen all the relevant components already in this guide, but it should help to bring them all together here and call out the features and recovery scenarios individually.</p>
<p>The primary reconnection features are enabled by the <code class="literal">CachingConnectionFactory</code> itself.
It is also often beneficial to use the <code class="literal">RabbitAdmin</code> auto-declaration features.
In addition, if you care about guaranteed delivery, you probably also need to use the <code class="literal">channelTransacted</code> flag in <code class="literal">RabbitTemplate</code> and <code class="literal">SimpleMessageListenerContainer</code> and also the <code class="literal">AcknowledgeMode.AUTO</code> (or manual if you do the acks yourself) in the <code class="literal">SimpleMessageListenerContainer</code>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="automatic-declaration" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#automatic-declaration"></a>Automatic Declaration of Exchanges, Queues and Bindings</h4></div></div></div>
<p>The <code class="literal">RabbitAdmin</code> component can declare exchanges, queues and bindings on startup.
It does this lazily, through a <code class="literal">ConnectionListener</code>, so if the broker is not present on startup it doesn’t matter.
The first time a <code class="literal">Connection</code> is used (e.g.
by sending a message) the listener will fire and the admin features will be applied.
A further benefit of doing the auto declarations in a listener is that if the connection is dropped for any reason (e.g.
broker death, network glitch, etc.) they will be applied again when the connection is re-established.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Queues declared this way must have fixed names; either explicitly declared, or generated by the framework for <code class="literal">AnonymousQueue</code> s.
Anonymous queues are non-durable, exclusive, and auto-delete.</p>
</td></tr></tbody></table></div>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./Spring AMQP_files/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Automatic declaration is only performed when the <code class="literal">CachingConnectionFactory</code> cache mode is <code class="literal">CHANNEL</code> (the default).
This limitation exists because exclusive and auto-delete queues are bound to the connection.</p>
</td></tr></tbody></table></div>
<p>See also <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#auto-recovery" title="RabbitMQ Automatic Connection/Topology recovery">the section called “RabbitMQ Automatic Connection/Topology recovery”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="retry" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#retry"></a>Failures in Synchronous Operations and Options for Retry</h4></div></div></div>
<p>If you lose your connection to the broker in a synchronous sequence using <code class="literal">RabbitTemplate</code> (for instance), then Spring AMQP will throw an <code class="literal">AmqpException</code> (usually but not always <code class="literal">AmqpIOException</code>).
We don’t try to hide the fact that there was a problem, so you have to be able to catch and respond to the exception.
The easiest thing to do if you suspect that the connection was lost, and it wasn’t your fault, is to simply try the operation again.
You can do this manually, or you could look at using Spring Retry to handle the retry (imperatively or declaratively).</p>
<p>Spring Retry provides a couple of AOP interceptors and a great deal of flexibility to specify the parameters of the retry (number of attempts, exception types, backoff algorithm etc.).
Spring AMQP also provides some convenience factory beans for creating Spring Retry interceptors in a convenient form for AMQP use cases, with strongly typed callback interfaces for you to implement custom recovery logic.
See the Javadocs and properties of <code class="literal">StatefulRetryOperationsInterceptor</code> and <code class="literal">StatelessRetryOperationsInterceptor</code> for more detail.
Stateless retry is appropriate if there is no transaction or if a transaction is started inside the retry callback.
Note that stateless retry is simpler to configure and analyse than stateful retry, but it is not usually appropriate if there is an ongoing transaction which must be rolled back or definitely is going to roll back.
A dropped connection in the middle of a transaction should have the same effect as a rollback, so for reconnection where the transaction is started higher up the stack, stateful retry is usually the best choice.</p>
<p>Starting with <span class="emphasis"><em>version 1.3</em></span>, a builder API is provided to aid in assembling these interceptors using Java (or in <code class="literal">@Configuration</code> classes), for example:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> StatefulRetryOperationsInterceptor interceptor() {
	<span class="hl-keyword">return</span> RetryInterceptorBuilder.stateful()
			.maxAttempts(<span class="hl-number">5</span>)
			.backOffOptions(<span class="hl-number">1000</span>, <span class="hl-number">2.0</span>, <span class="hl-number">10000</span>) <span class="hl-comment">// initialInterval, multiplier, maxInterval</span>
			.build();
}</pre>
<p>Only a subset of retry capabilities can be configured this way; more advanced features would need the configuration of a <code class="literal">RetryTemplate</code> as a Spring bean.
See the <a class="ulink" href="http://static.springsource.org/spring-retry/docs/api/current/" target="_top">Spring Retry Javadocs</a> for complete information about available policies and their configuration.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="async-listeners" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#async-listeners"></a>Message Listeners and the Asynchronous Case</h4></div></div></div>
<p>If a <code class="literal">MessageListener</code> fails because of a business exception, the exception is handled by the message listener container and then it goes back to listening for another message.
If the failure is caused by a dropped connection (not a business exception), then the consumer that is collecting messages for the listener has to be cancelled and restarted.
The <code class="literal">SimpleMessageListenerContainer</code> handles this seamlessly, and it leaves a log to say that the listener is being restarted.
In fact it loops endlessly trying to restart the consumer, and only if the consumer is very badly behaved indeed will it give up.
One side effect is that if the broker is down when the container starts, it will just keep trying until a connection can be established.</p>
<p>Business exception handling, as opposed to protocol errors and dropped connections, might need more thought and some custom configuration, especially if transactions and/or container acks are in use.
Prior to 2.8.x, RabbitMQ had no definition of dead letter behaviour, so by default a message that is rejected or rolled back because of a business exception can be redelivered ad infinitum.
To put a limit in the client on the number of re-deliveries, one choice is a <code class="literal">StatefulRetryOperationsInterceptor</code> in the advice chain of the listener.
The interceptor can have a recovery callback that implements a custom dead letter action: whatever is appropriate for your particular environment.</p>
<p>Another alternative is to set the container’s rejectRequeued property to false.
This causes all failed messages to be discarded.
When using RabbitMQ 2.8.x or higher, this also facilitates delivering the message to a Dead Letter Exchange.</p>
<p>Or, you can throw a <code class="literal">AmqpRejectAndDontRequeueException</code>; this prevents message requeuing, regardless of the setting of the <code class="literal">defaultRequeueRejected</code> property.</p>
<p>Often, a combination of both techniques will be used.
Use a <code class="literal">StatefulRetryOperationsInterceptor</code> in the advice chain, where it’s <code class="literal">MessageRecover</code> throws an <code class="literal">AmqpRejectAndDontRequeueException</code>.
The <code class="literal">MessageRecover</code> is called when all retries have been exhausted.
The default <code class="literal">MessageRecoverer</code> simply consumes the errant message and emits a WARN message.
In which case, the message is ACK’d and won’t be sent to the Dead Letter Exchange, if any.</p>
<p>Starting with <span class="emphasis"><em>version 1.3</em></span>, a new <code class="literal">RepublishMessageRecoverer</code> is provided, to allow publishing of failed messages after
retries are exhausted:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
RetryOperationsInterceptor interceptor() {
	<span class="hl-keyword">return</span> RetryInterceptorBuilder.stateless()
			.maxAttempts(<span class="hl-number">5</span>)
			.recoverer(<span class="hl-keyword">new</span> RepublishMessageRecoverer(amqpTemplate(), <span class="hl-string">"bar"</span>, <span class="hl-string">"baz"</span>))
			.build();
}</pre>
<p>The <code class="literal">RepublishMessageRecoverer</code> publishes the message with additional information in message headers, such as the
exception message, stack trace, original exchange and routing key.
Additional headers can be added by creating a subclass and overriding <code class="literal">additionalHeaders()</code>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_exception_classification_for_retry" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_exception_classification_for_retry"></a>Exception Classification for Retry</h4></div></div></div>
<p>Spring Retry has a great deal of flexibility for determining which exceptions can invoke retry.
The default configuration will retry for all exceptions.
Given that user exceptions will be wrapped in a <code class="literal">ListenerExecutionFailedException</code> we need to ensure that the classification examines the exception causes.
The default classifier just looks at the top level exception.</p>
<p>Since <span class="strong"><strong>Spring Retry 1.0.3</strong></span>, the <code class="literal">BinaryExceptionClassifier</code> has a property <code class="literal">traverseCauses</code> (default <code class="literal">false</code>).
When <code class="literal">true</code> it will traverse exception causes until it finds a match or there is no cause.</p>
<p>To use this classifier for retry, use a <code class="literal">SimpleRetryPolicy</code> created with the constructor that takes the max attempts, the <code class="literal">Map</code> of <code class="literal">Exception</code> s and the boolean (traverseCauses), and inject this policy into the <code class="literal">RetryTemplate</code>.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_debugging" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_debugging"></a>3.1.20&nbsp;Debugging</h3></div></div></div>
<p>Spring AMQP provides extensive logging, especially at <code class="literal">DEBUG</code> level.</p>
<p>If you wish to monitor the AMQP protocol between the application and broker, you could use a tool such as WireShark, which has a plugin to decode the protocol.
Alternatively the RabbitMQ java client comes with a very useful class <code class="literal">Tracer</code>.
When run as a <code class="literal">main</code>, by default, it listens on port 5673 and connects to port 5672 on localhost.
Simply run it, and change your connection factory configuration to connect to port 5673 on localhost.
It displays the decoded protocol on the console.
Refer to the <code class="literal">Tracer</code> javadocs for more information.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="logging" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#logging"></a>3.2&nbsp;Logging Subsystem AMQP Appenders</h2></div></div></div>
<p>The framework provides logging appenders for several popular logging subsystems:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
log4j (since Spring AMQP <span class="emphasis"><em>version 1.1</em></span>) (deprecated)
</li><li class="listitem">
logback (since Spring AMQP <span class="emphasis"><em>version 1.4</em></span>)
</li><li class="listitem">
log4j2 (since Spring AMQP <span class="emphasis"><em>version 1.6</em></span>)
</li></ul></div>
<p>The appenders are configured using the normal mechanisms for the logging subsystem, available properties are specified
in the following sections.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_common_properties" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_common_properties"></a>3.2.1&nbsp;Common properties</h3></div></div></div>
<p>The following properties are available with all appenders:</p>
<div class="table"><a name="d5e2929" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#d5e2929"></a><p class="title"><b>Table&nbsp;3.4.&nbsp;Common Appender Properties</b></p><div class="table-contents">
<table summary="Common Appender Properties" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Property</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Default</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">exchangeName</pre></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">logs</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Name of the exchange to publish log events to.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">exchangeType</pre></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">topic</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Type of the exchange to publish log events to - only needed if the appender declares the exchange.
See <code class="literal">declareExchange</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">routingKeyPattern</pre></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">%c.%p</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Logging subsystem pattern format to use to generate a routing key.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">applicationId</pre></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout"></pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Application ID - added to the routing key if the pattern includes <code class="literal">%X{applicationId}</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">senderPoolSize</pre></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">2</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The number of threads to use to publish log events.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">maxSenderRetries</pre></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">30</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>How many times to retry sending a message if the broker is unavailable or there is some other error.
Retries are delayed like: <code class="literal">N ^ log(N)</code>, where <code class="literal">N</code> is the retry number.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">addresses</pre></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout"></pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>A comma-delimited list of broker addresses: <code class="literal">host:port[,host:port]*</code> - overrides <code class="literal">host</code> and <code class="literal">port</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">host</pre></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">localhost</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>RabbitMQ host to connect to.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">port</pre></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">5672</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>RabbitMQ port to connect to.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">virtualHost</pre></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">/</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>RabbitMQ virtual host to connect to.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">username</pre></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">guest</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>RabbitMQ user to connect as.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">password</pre></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">guest</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>RabbitMQ password for this user.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">contentType</pre></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">text/plain</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">content-type</code> property of log messages.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">contentEncoding</pre></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout"></pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">content-encoding</code> property of log messages.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">declareExchange</pre></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">false</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Whether or not to declare the configured exchange when this appender starts.
Also see <code class="literal">durable</code> and <code class="literal">autoDelete</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">durable</pre></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">true</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>When <code class="literal">declareExchange</code> is <code class="literal">true</code> the durable flag is set to this value.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">autoDelete</pre></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">false</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>When <code class="literal">declareExchange</code> is <code class="literal">true</code> the auto delete flag is set to this value.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">charset</pre></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">null</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Charset to use when converting String to byte[], default null (system default charset used).
If the charset is unsupported on the current platform, we fall back to using the system charset.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">deliveryMode</pre></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">PERSISTENT</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>PERSISTENT or NON_PERSISTENT to determine whether or not RabbitMQ should persist the messages.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">generateId</pre></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">false</pre></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Used to determine whether the <code class="literal">messageId</code> property is set to a unique value.</p></td></tr><tr><td style="border-right: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">clientConnectionProperties</pre></td><td style="border-right: 0.5pt solid ; " align="left" valign="top"><pre class="literallayout">null</pre></td><td style="" align="left" valign="top"><p>A comma-delimited list of <code class="literal">key:value</code> pairs for custom client properties to the RabbitMQ connection.</p></td></tr></tbody></table>
</div></div><br class="table-break">
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_log4j_appender" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_log4j_appender"></a>3.2.2&nbsp;Log4j Appender</h3></div></div></div>
<p>
<b>Example log4j.properties Snippet.&nbsp;</b>
</p><pre class="programlisting">log4j.appender.amqp.addresses=foo:5672,bar:5672
log4j.appender.amqp=org.springframework.amqp.rabbit.log4j.AmqpAppender
log4j.appender.amqp.applicationId=myApplication
log4j.appender.amqp.routingKeyPattern=%X{applicationId}.%c.%p
log4j.appender.amqp.layout=org.apache.log4j.PatternLayout
log4j.appender.amqp.layout.ConversionPattern=%d %p %t [%c] - &lt;%m&gt;%n
log4j.appender.amqp.generateId=true
log4j.appender.amqp.charset=UTF-8
log4j.appender.amqp.durable=false
log4j.appender.amqp.deliveryMode=NON_PERSISTENT
log4j.appender.amqp.declareExchange=true</pre><p>
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring AMQP_files/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>This appender is deprecated and will be removed in <span class="emphasis"><em>version 2.0</em></span>.</p>
</td></tr></tbody></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_log4j2_appender" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_log4j2_appender"></a>3.2.3&nbsp;Log4j2 Appender</h3></div></div></div>
<p>
<b>Example log4j2.xml Snippet.&nbsp;</b>
</p><pre class="programlisting">&lt;Appenders&gt;
    ...
    &lt;RabbitMQ name="rabbitmq"
        addresses="foo:5672,bar:5672" user="guest" password="guest" virtualHost="/"
        exchange="log4j2" exchangeType="topic" declareExchange="true" durable="true" autoDelete="false"
        applicationId="myAppId" routingKeyPattern="%X{applicationId}.%c.%p"
        contentType="text/plain" contentEncoding="UTF-8" generateId="true" deliveryMode="NON_PERSISTENT"
        charset="UTF-8"
        senderPoolSize="3" maxSenderRetries="5"&gt;
    &lt;/RabbitMQ&gt;
&lt;/Appenders&gt;</pre><p>
</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./Spring AMQP_files/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Starting with <span class="emphasis"><em>versions 1.6.10, 1.7.3</em></span>, the log4j2 Appender publishes the messages to RabbitMQ on the calling thread by default.
This is because log4j2 does not create thread-safe events by default.
If the broker is down, the <code class="literal">maxSenderRetries</code> will be used to retry, with no delay between retries.
If you wish to restore the previous behavior of publishing the messages on separate threads (<code class="literal">senderPoolSize</code>), set the <code class="literal">async</code> property to <code class="literal">true</code>.
However, you will also need to configure log4j2 to use the <code class="literal">DefaultLogEventFactory</code> instead of the <code class="literal">ReusableLogEventFactory</code>.
One way to do that is to set the system property <code class="literal">-Dlog4j2.enable.threadlocals=false</code>.
If async publishing is used with the <code class="literal">ReusableLogEventFactory</code>, events will have a high likelihood of being corrupted due to cross-talk.</p>
</td></tr></tbody></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_logback_appender_2" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_logback_appender_2"></a>3.2.4&nbsp;Logback Appender</h3></div></div></div>
<p>
<b>Example logback.xml Snippet.&nbsp;</b>
</p><pre class="programlisting">&lt;appender name="AMQP" class="org.springframework.amqp.rabbit.logback.AmqpAppender"&gt;
    &lt;layout&gt;
        &lt;pattern&gt;&lt;![CDATA[ %d %p %t [%c] - &lt;%m&gt;%n ]]&gt;&lt;/pattern&gt;
    &lt;/layout&gt;
    &lt;addresses&gt;foo:5672,bar:5672&lt;/addresses&gt;
    &lt;abbreviation&gt;36&lt;/abbreviation&gt;
    &lt;includeCallerData&gt;false&lt;/includeCallerData&gt;
    &lt;applicationId&gt;myApplication&lt;/applicationId&gt;
    &lt;routingKeyPattern&gt;%property{applicationId}.%c.%p&lt;/routingKeyPattern&gt;
    &lt;generateId&gt;true&lt;/generateId&gt;
    &lt;charset&gt;UTF-8&lt;/charset&gt;
    &lt;durable&gt;false&lt;/durable&gt;
    &lt;deliveryMode&gt;NON_PERSISTENT&lt;/deliveryMode&gt;
    &lt;declareExchange&gt;true&lt;/declareExchange&gt;
&lt;/appender&gt;</pre><p>
</p>
<p>Starting with <span class="emphasis"><em>version 1.7.1</em></span>, the Logback <code class="literal">AmqpAppender</code> provides an <code class="literal">includeCallerData</code> option which is <code class="literal">false</code> by default.
Extracting caller data can be rather expensive because the log event has to create a throwable and inspect it to determine the calling location.
Therefore, by default, caller data associated with an event is not extracted when the event added to the event queue.
You can configure the appender to include caller data by setting the <code class="literal">includeCallerData</code> property to <code class="literal">true</code>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_customizing_the_messages" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_customizing_the_messages"></a>3.2.5&nbsp;Customizing the Messages</h3></div></div></div>
<p>By default AMQP appenders populates these message properties:
* deliveryMode
* contentType
* contentEncoding if configured
* messageId if <code class="literal">generateId</code> is configured
* timestamp of the log event
* appId if applicationId is configured</p>
<p>In addition they populate headers:
* categoryName of the log event
* level of the log event
* thread the name of the thread where log event happened
* location the stack trace of the log event call
* copy of all the MDC properties</p>
<p>Each of the appenders can be subclassed, allowing you to modify the messages before publishing.</p>
<p>
<b>Customizing the Log Messages.&nbsp;</b>
</p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyEnhancedAppender <span class="hl-keyword">extends</span> AmqpAppender {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">public</span> Message postProcessMessageBeforeSend(Message message, Event event) {
        message.getMessageProperties().setHeader(<span class="hl-string">"foo"</span>, <span class="hl-string">"bar"</span>);
        <span class="hl-keyword">return</span> message;
    }

}</pre><p>
</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_customizing_the_client_properties" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_customizing_the_client_properties"></a>3.2.6&nbsp;Customizing the Client Properties</h3></div></div></div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_simple_string_properties" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_simple_string_properties"></a>Simple String Properties</h4></div></div></div>
<p>Each appender supports adding client properties to the RabbitMQ connection.</p>
<p>
<b>log4j.&nbsp;</b>
</p><pre class="programlisting">log4j.appender.amqp.clientConnectionProperties=foo:bar,baz:qux</pre><p>
</p>
<p>
<b>logback.&nbsp;</b>
</p><pre class="programlisting"><span class="hl-tag">&lt;appender</span> <span class="hl-attribute">name</span>=<span class="hl-value">"AMQP"</span> <span class="hl-attribute">...&gt;</span>
    <span class="hl-attribute">...</span>
    <span class="hl-attribute">&lt;clientConnectionProperties&gt;foo:bar,baz:qux&lt;/clientConnectionProperties&gt;</span>
    <span class="hl-attribute">...</span>
<span class="hl-attribute">&lt;/appender&gt;</span></pre><p>
</p>
<p>
<b>log4j2.&nbsp;</b>
</p><pre class="programlisting"><span class="hl-tag">&lt;Appenders&gt;</span>
    ...
    <span class="hl-tag">&lt;RabbitMQ</span> <span class="hl-attribute">name</span>=<span class="hl-value">"rabbitmq"</span>
        <span class="hl-attribute">...</span>
        <span class="hl-attribute">clientConnectionProperties</span>=<span class="hl-value">"foo:bar,baz:qux"</span>
        <span class="hl-attribute">...</span>
    <span class="hl-attribute">&lt;/RabbitMQ&gt;</span>
<span class="hl-attribute">&lt;/Appenders&gt;</span></pre><p>
</p>
<p>The properties are a comma-delimited list of <code class="literal">key:value</code> pairs; keys and values cannot contain commas or colons.</p>
<p>These properties appear on the RabbitMQ Admin UI when viewing the connection.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_advanced_technique_for_log4j_and_logback" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_advanced_technique_for_log4j_and_logback"></a>Advanced Technique for Log4j and Logback</h4></div></div></div>
<p>With the log4j and logback appenders, the appenders can be subclassed, allowing you to modify the client connection
properties before the connection is established:</p>
<p>
<b>Customizing the Client Connection Properties.&nbsp;</b>
</p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyEnhancedAppender <span class="hl-keyword">extends</span> AmqpAppender {

    <span class="hl-keyword">private</span> String foo;

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> updateConnectionClientProperties(Map&lt;String, Object&gt; clientProperties) {
        clientProperties.put(<span class="hl-string">"foo"</span>, <span class="hl-keyword">this</span>.foo);
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setFoo(String foo) {
        <span class="hl-keyword">this</span>.foo = foo;
    }

}</pre><p>
</p>
<p>For log4j2, add <code class="literal">log4j.appender.amqp.foo=bar</code> to log4j.properties to set the property.
For logback, add <code class="literal">&lt;foo&gt;bar&lt;/foo&gt;</code> to logback.xml.</p>
<p>Of course, for simple String properties like this example, the previous technique can be used; subclasses allow
richer properties (such as adding a <code class="literal">Map</code> or numeric property).</p>
<p>With log4j2, subclasses are not supported, due to the way log4j2 uses static factory methods.</p>
</div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sample-apps" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#sample-apps"></a>3.3&nbsp;Sample Applications</h2></div></div></div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_introduction_14" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction_14"></a>3.3.1&nbsp;Introduction</h3></div></div></div>
<p>The <a class="ulink" href="https://github.com/SpringSource/spring-amqp-samples" target="_top">Spring AMQP Samples</a> project includes two sample applications.
The first is a simple "Hello World" example that demonstrates both synchronous and asynchronous message reception.
It provides an excellent starting point for acquiring an understanding of the essential components.
The second sample is based on a stock-trading use case to demonstrate the types of interaction that would be common in real world applications.
In this chapter, we will provide a quick walk-through of each sample so that you can focus on the most important components.
The samples are both Maven-based, so you should be able to import them directly into any Maven-aware IDE (such as <a class="ulink" href="http://www.springsource.org/sts" target="_top">SpringSource Tool Suite</a>).</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_hello_world" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_hello_world"></a>3.3.2&nbsp;Hello World</h3></div></div></div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_introduction_15" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction_15"></a>Introduction</h4></div></div></div>
<p>The Hello World sample demonstrates both synchronous and asynchronous message reception.
You can import the <span class="emphasis"><em>spring-rabbit-helloworld</em></span> sample into the IDE and then follow the discussion below.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="hello-world-sync" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#hello-world-sync"></a>Synchronous Example</h4></div></div></div>
<p>Within the <span class="emphasis"><em>src/main/java</em></span> directory, navigate to the <span class="emphasis"><em>org.springframework.amqp.helloworld</em></span> package.
Open the HelloWorldConfiguration class and notice that it contains the @Configuration annotation at class-level and some @Bean annotations at method-level.
This is an example of Spring’s Java-based configuration.
You can read more about that <a class="ulink" href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/htmlsingle/spring-framework-reference.html#beans-java" target="_top">here</a>.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> ConnectionFactory connectionFactory() {
    CachingConnectionFactory connectionFactory =
        <span class="hl-keyword">new</span> CachingConnectionFactory(<span class="hl-string">"localhost"</span>);
    connectionFactory.setUsername(<span class="hl-string">"guest"</span>);
    connectionFactory.setPassword(<span class="hl-string">"guest"</span>);
    <span class="hl-keyword">return</span> connectionFactory;
}</pre>
<p>The configuration also contains an instance of <code class="literal">RabbitAdmin</code>, which by default looks for any beans of type Exchange, Queue, or Binding and then declares them on the broker.
In fact, the "helloWorldQueue" bean that is generated in HelloWorldConfiguration is an example simply because it is an instance of Queue.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> Queue helloWorldQueue() {
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> Queue(<span class="hl-keyword">this</span>.helloWorldQueueName);
}</pre>
<p>Looking back at the "rabbitTemplate" bean configuration, you will see that it has the helloWorldQueue’s name set as its "queue" property (for receiving Messages) and for its "routingKey" property (for sending Messages).</p>
<p>Now that we’ve explored the configuration, let’s look at the code that actually uses these components.
First, open the Producer class from within the same package.
It contains a main() method where the Spring ApplicationContext is created.</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {
    ApplicationContext context =
        <span class="hl-keyword">new</span> AnnotationConfigApplicationContext(RabbitConfiguration.<span class="hl-keyword">class</span>);
    AmqpTemplate amqpTemplate = context.getBean(AmqpTemplate.<span class="hl-keyword">class</span>);
    amqpTemplate.convertAndSend(<span class="hl-string">"Hello World"</span>);
    System.out.println(<span class="hl-string">"Sent: Hello World"</span>);
}</pre>
<p>As you can see in the example above, the AmqpTemplate bean is retrieved and used for sending a Message.
Since the client code should rely on interfaces whenever possible, the type is AmqpTemplate rather than RabbitTemplate.
Even though the bean created in HelloWorldConfiguration is an instance of RabbitTemplate, relying on the interface means that this code is more portable (the configuration can be changed independently of the code).
Since the convertAndSend() method is invoked, the template will be delegating to its MessageConverter instance.
In this case, it’s using the default SimpleMessageConverter, but a different implementation could be provided to the "rabbitTemplate" bean as defined in HelloWorldConfiguration.</p>
<p>Now open the Consumer class.
It actually shares the same configuration base class which means it will be sharing the "rabbitTemplate" bean.
That’s why we configured that template with both a "routingKey" (for sending) and "queue" (for receiving).
As you saw in <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#amqp-template" title="3.1.4 AmqpTemplate">Section&nbsp;3.1.4, “AmqpTemplate”</a>, you could instead pass the <span class="emphasis"><em>routingKey</em></span> argument to the send method and the <span class="emphasis"><em>queue</em></span> argument to the receive method.
The Consumer code is basically a mirror image of the Producer, calling receiveAndConvert() rather than convertAndSend().</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {
    ApplicationContext context =
        <span class="hl-keyword">new</span> AnnotationConfigApplicationContext(RabbitConfiguration.<span class="hl-keyword">class</span>);
    AmqpTemplate amqpTemplate = context.getBean(AmqpTemplate.<span class="hl-keyword">class</span>);
    System.out.println(<span class="hl-string">"Received: "</span> + amqpTemplate.receiveAndConvert());
}</pre>
<p>If you run the Producer, and then run the Consumer, you should see the message "Received: Hello World" in the console output.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="hello-world-async" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#hello-world-async"></a>Asynchronous Example</h4></div></div></div>
<p>Now that we’ve walked through the synchronous Hello World sample, it’s time to move on to a slightly more advanced but significantly more powerful option.
With a few modifications, the Hello World sample can provide an example of asynchronous reception, a.k.a.
<span class="strong"><strong>Message-driven POJOs</strong></span>.
In fact, there is a sub-package that provides exactly that: org.springframework.amqp.samples.helloworld.async.</p>
<p>Once again, we will start with the sending side.
Open the ProducerConfiguration class and notice that it creates a "connectionFactory" and "rabbitTemplate" bean.
This time, since the configuration is dedicated to the message sending side, we don’t even need any Queue definitions, and the RabbitTemplate only has the <span class="emphasis"><em>routingKey</em></span> property set.
Recall that messages are sent to an Exchange rather than being sent directly to a Queue.
The AMQP default Exchange is a direct Exchange with no name.
All Queues are bound to that default Exchange with their name as the routing key.
That is why we only need to provide the routing key here.</p>
<pre class="programlisting"><span class="hl-keyword">public</span> RabbitTemplate rabbitTemplate() {
    RabbitTemplate template = <span class="hl-keyword">new</span> RabbitTemplate(connectionFactory());
    template.setRoutingKey(<span class="hl-keyword">this</span>.helloWorldQueueName);
    <span class="hl-keyword">return</span> template;
}</pre>
<p>Since this sample will be demonstrating asynchronous message reception, the producing side is designed to continuously send messages (if it were a message-per-execution model like the synchronous version, it would not be quite so obvious that it is in fact a message-driven consumer).
The component responsible for sending messages continuously is defined as an inner class within the ProducerConfiguration.
It is configured to execute every 3 seconds.</p>
<pre class="programlisting"><span class="hl-keyword">static</span> <span class="hl-keyword">class</span> ScheduledProducer {

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span class="hl-keyword">private</span> <span class="hl-keyword">volatile</span> RabbitTemplate rabbitTemplate;

    <span class="hl-keyword">private</span> <span class="hl-keyword">final</span> AtomicInteger counter = <span class="hl-keyword">new</span> AtomicInteger();

    <em><span class="hl-annotation" style="color: gray">@Scheduled(fixedRate = 3000)</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> sendMessage() {
        rabbitTemplate.convertAndSend(<span class="hl-string">"Hello World "</span> + counter.incrementAndGet());
    }
}</pre>
<p>You don’t need to understand all of the details since the real focus should be on the receiving side (which we will cover momentarily).
However, if you are not yet familiar with Spring 3.0 task scheduling support, you can learn more <a class="ulink" href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/htmlsingle/spring-framework-reference.html#scheduling-annotation-support" target="_top">here</a>.
The short story is that the "postProcessor" bean in the ProducerConfiguration is registering the task with a scheduler.</p>
<p>Now, let’s turn to the receiving side.
To emphasize the Message-driven POJO behavior will start with the component that is reacting to the messages.
The class is called HelloWorldHandler.</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> HelloWorldHandler {

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> handleMessage(String text) {
        System.out.println(<span class="hl-string">"Received: "</span> + text);
    }

}</pre>
<p>Clearly, that <span class="strong"><strong>is</strong></span> a POJO.
It does not extend any base class, it doesn’t implement any interfaces, and it doesn’t even contain any imports.
It is being "adapted" to the MessageListener interface by the Spring AMQP MessageListenerAdapter.
That adapter can then be configured on a SimpleMessageListenerContainer.
For this sample, the container is created in the ConsumerConfiguration class.
You can see the POJO wrapped in the adapter there.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> SimpleMessageListenerContainer listenerContainer() {
    SimpleMessageListenerContainer container = <span class="hl-keyword">new</span> SimpleMessageListenerContainer();
    container.setConnectionFactory(connectionFactory());
    container.setQueueName(<span class="hl-keyword">this</span>.helloWorldQueueName);
    container.setMessageListener(<span class="hl-keyword">new</span> MessageListenerAdapter(<span class="hl-keyword">new</span> HelloWorldHandler()));
    <span class="hl-keyword">return</span> container;
}</pre>
<p>The SimpleMessageListenerContainer is a Spring lifecycle component and will start automatically by default.
If you look in the Consumer class, you will see that its main() method consists of nothing more than a one-line bootstrap to create the ApplicationContext.
The Producer’s main() method is also a one-line bootstrap, since the component whose method is annotated with @Scheduled will also start executing automatically.
You can start the Producer and Consumer in any order, and you should see messages being sent and received every 3 seconds.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_stock_trading" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_stock_trading"></a>3.3.3&nbsp;Stock Trading</h3></div></div></div>
<p>The Stock Trading sample demonstrates more advanced messaging scenarios than the Hello World sample.
However, the configuration is very similar - just a bit more involved.
Since we’ve walked through the Hello World configuration in detail, here we’ll focus on what makes this sample different.
There is a server that pushes market data (stock quotes) to a Topic Exchange.
Then, clients can subscribe to the market data feed by binding a Queue with a routing pattern (e.g.
"app.stock.quotes.nasdaq.*").
The other main feature of this demo is a request-reply "stock trade" interaction that is initiated by the client and handled by the server.
That involves a private "replyTo" Queue that is sent by the client within the order request Message itself.</p>
<p>The Server’s core configuration is in the RabbitServerConfiguration class within the org.springframework.amqp.rabbit.stocks.config.server package.
It extends the AbstractStockAppRabbitConfiguration.
That is where the resources common to the Server and Client(s) are defined, including the market data Topic Exchange (whose name is <span class="emphasis"><em>app.stock.marketdata</em></span>) and the Queue that the Server exposes for stock trades (whose name is <span class="emphasis"><em>app.stock.request</em></span>).
In that common configuration file, you will also see that a JsonMessageConverter is configured on the RabbitTemplate.</p>
<p>The Server-specific configuration consists of 2 things.
First, it configures the market data exchange on the RabbitTemplate so that it does not need to provide that exchange name with every call to send a Message.
It does this within an abstract callback method defined in the base configuration class.</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">void</span> configureRabbitTemplate(RabbitTemplate rabbitTemplate) {
    rabbitTemplate.setExchange(MARKET_DATA_EXCHANGE_NAME);
}</pre>
<p>Secondly, the stock request queue is declared.
It does not require any explicit bindings in this case, because it will be bound to the default no-name exchange with its own name as the routing key.
As mentioned earlier, the AMQP specification defines that behavior.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> Queue stockRequestQueue() {
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> Queue(STOCK_REQUEST_QUEUE_NAME);
}</pre>
<p>Now that you’ve seen the configuration of the Server’s AMQP resources, navigate to the <span class="emphasis"><em>org.springframework.amqp.rabbit.stocks</em></span> package under the <span class="emphasis"><em>src/test/java</em></span> directory.
There you will see the actual Server class that provides a main() method.
It creates an ApplicationContext based on the <span class="emphasis"><em>server-bootstrap.xml</em></span> config file.
In there you will see the scheduled task that publishes dummy market data.
That configuration relies upon Spring 3.0’s "task" namespace support.
The bootstrap config file also imports a few other files.
The most interesting one is <span class="emphasis"><em>server-messaging.xml</em></span> which is directly under <span class="emphasis"><em>src/main/resources</em></span>.
In there you will see the "messageListenerContainer" bean that is responsible for handling the stock trade requests.
Finally have a look at the "serverHandler" bean that is defined in "server-handlers.xml" (also in <span class="emphasis"><em>src/main/resources</em></span>).
That bean is an instance of the ServerHandler class and is a good example of a Message-driven POJO that is also capable of sending reply Messages.
Notice that it is not itself coupled to the framework or any of the AMQP concepts.
It simply accepts a TradeRequest and returns a TradeResponse.</p>
<pre class="programlisting"><span class="hl-keyword">public</span> TradeResponse handleMessage(TradeRequest tradeRequest) { ...
}</pre>
<p>Now that we’ve seen the most important configuration and code for the Server, let’s turn to the Client.
The best starting point is probably RabbitClientConfiguration within the <span class="emphasis"><em>org.springframework.amqp.rabbit.stocks.config.client</em></span> package.
Notice that it declares two queues without providing explicit names.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> Queue marketDataQueue() {
    <span class="hl-keyword">return</span> amqpAdmin().declareQueue();
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> Queue traderJoeQueue() {
    <span class="hl-keyword">return</span> amqpAdmin().declareQueue();
}</pre>
<p>Those are private queues, and unique names will be generated automatically.
The first generated queue is used by the Client to bind to the market data exchange that has been exposed by the Server.
Recall that in AMQP, consumers interact with Queues while producers interact with Exchanges.
The "binding" of Queues to Exchanges is what instructs the broker to deliver, or route, messages from a given Exchange to a Queue.
Since the market data exchange is a Topic Exchange, the binding can be expressed with a routing pattern.
The RabbitClientConfiguration declares that with a Binding object, and that object is generated with the BindingBuilder’s fluent API.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Value("${stocks.quote.pattern}")</span></em>
<span class="hl-keyword">private</span> String marketDataRoutingKey;

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> Binding marketDataBinding() {
    <span class="hl-keyword">return</span> BindingBuilder.bind(
        marketDataQueue()).to(marketDataExchange()).with(marketDataRoutingKey);
}</pre>
<p>Notice that the actual value has been externalized in a properties file ("client.properties" under src/main/resources), and that we are using Spring’s @Value annotation to inject that value.
This is generally a good idea, since otherwise the value would have been hardcoded in a class and unmodifiable without recompilation.
In this case, it makes it much easier to run multiple versions of the Client while making changes to the routing pattern used for binding.
Let’s try that now.</p>
<p>Start by running org.springframework.amqp.rabbit.stocks.Server and then org.springframework.amqp.rabbit.stocks.Client.
You should see dummy quotes for NASDAQ stocks because the current value associated with the <span class="emphasis"><em>stocks.quote.pattern</em></span> key in client.properties is <span class="emphasis"><em>app.stock.quotes.nasdaq.<span class="strong"><strong></strong></span>.
Now, while keeping the existing Server and Client running, change that property value to <span class="emphasis"><em>app.stock.quotes.nyse.</em></span></em></span> and start a second Client instance.
You should see that the first client is still receiving NASDAQ quotes while the second client receives NYSE quotes.
You could instead change the pattern to get all stocks or even an individual ticker.</p>
<p>The final feature we’ll explore is the request-reply interaction from the Client’s perspective.
Recall that we have already seen the ServerHandler that is accepting TradeRequest objects and returning TradeResponse objects.
The corresponding code on the Client side is RabbitStockServiceGateway in the <span class="emphasis"><em>org.springframework.amqp.rabbit.stocks.gateway</em></span> package.
It delegates to the RabbitTemplate in order to send Messages.</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">void</span> send(TradeRequest tradeRequest) {
    getRabbitTemplate().convertAndSend(tradeRequest, <span class="hl-keyword">new</span> MessagePostProcessor() {
        <span class="hl-keyword">public</span> Message postProcessMessage(Message message) <span class="hl-keyword">throws</span> AmqpException {
            message.getMessageProperties().setReplyTo(<span class="hl-keyword">new</span> Address(defaultReplyToQueue));
            <span class="hl-keyword">try</span> {
                message.getMessageProperties().setCorrelationId(
                    UUID.randomUUID().toString().getBytes(<span class="hl-string">"UTF-8"</span>));
            }
            <span class="hl-keyword">catch</span> (UnsupportedEncodingException e) {
                <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> AmqpException(e);
            }
            <span class="hl-keyword">return</span> message;
        }
    });
}</pre>
<p>Notice that prior to sending the message, it sets the "replyTo" address.
It’s providing the queue that was generated by the "traderJoeQueue" bean definition shown above.
Here’s the @Bean definition for the StockServiceGateway class itself.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> StockServiceGateway stockServiceGateway() {
    RabbitStockServiceGateway gateway = <span class="hl-keyword">new</span> RabbitStockServiceGateway();
    gateway.setRabbitTemplate(rabbitTemplate());
    gateway.setDefaultReplyToQueue(traderJoeQueue());
    <span class="hl-keyword">return</span> gateway;
}</pre>
<p>If you are no longer running the Server and Client, start them now.
Try sending a request with the format of <span class="emphasis"><em>100 TCKR</em></span>.
After a brief artificial delay that simulates "processing" of the request, you should see a confirmation message appear on the Client.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="testing" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#testing"></a>3.4&nbsp;Testing Support</h2></div></div></div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_introduction_16" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_introduction_16"></a>3.4.1&nbsp;Introduction</h3></div></div></div>
<p>Writing integration for asynchronous applications is necessarily more complex than testing simpler applications.
This is made more complex when abstractions such as the <code class="literal">@RabbitListener</code> annotations come into the picture.
The question being how to verify that, after sending a message, the listener received the message as expected.</p>
<p>The framework itself has many unit and integration tests; some using mocks, others using integration testing with
a live RabbitMQ broker.
You can consult those tests for some ideas for testing scenarios.</p>
<p>Spring AMQP <span class="emphasis"><em>version 1.6</em></span> introduced the <code class="literal">spring-rabbit-test</code> jar which provides support for testing some of these more
complex scenarios.
It is anticipated that this project will expand over time but we need community feedback to make suggestions for
features needed to help with testing.
Please use <a class="ulink" href="https://jira.spring.io/browse/AMQP" target="_top">JIRA</a> or
<a class="ulink" href="https://github.com/spring-projects/spring-amqp/issues" target="_top">GitHub Issues</a> to provide such feedback.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="mockito-answer" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#mockito-answer"></a>3.4.2&nbsp;Mockito Answer&lt;?&gt; Implementations</h3></div></div></div>
<p>There are currently two <code class="literal">Answer&lt;?&gt;</code> implementations to help with testing:</p>
<p>The first, <code class="literal">LatchCountDownAndCallRealMethodAnswer</code> provides an <code class="literal">Answer&lt;Void&gt;</code> that returns <code class="literal">null</code> and counts down
a latch.</p>
<pre class="programlisting">LatchCountDownAndCallRealMethodAnswer answer = <span class="hl-keyword">new</span> LatchCountDownAndCallRealMethodAnswer(<span class="hl-number">2</span>);
doAnswer(answer)
    .when(listener).foo(anyString(), anyString());

...

assertTrue(answer.getLatch().await(<span class="hl-number">10</span>, TimeUnit.SECONDS));</pre>
<p>The second, <code class="literal">LambdaAnswer&lt;T&gt;</code> provides a mechanism to optionally call the real method and provides an opportunity
to return a custom result, based on the <code class="literal">InvocationOnMock</code> and the result (if any).</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Foo {

    <span class="hl-keyword">public</span> String foo(String foo) {
        <span class="hl-keyword">return</span> foo.toUpperCase();
    }

}</pre>
<pre class="programlisting">Foo foo = spy(<span class="hl-keyword">new</span> Foo());

doAnswer(<span class="hl-keyword">new</span> LambdaAnswer&lt;String&gt;(true, (i, r) -&gt; r + r))
    .when(foo).foo(anyString());
assertEquals(<span class="hl-string">"FOOFOO"</span>, foo.foo(<span class="hl-string">"foo"</span>));

doAnswer(<span class="hl-keyword">new</span> LambdaAnswer&lt;String&gt;(true, (i, r) -&gt; r + i.getArguments()[<span class="hl-number">0</span>]))
    .when(foo).foo(anyString());
assertEquals(<span class="hl-string">"FOOfoo"</span>, foo.foo(<span class="hl-string">"foo"</span>));

doAnswer(<span class="hl-keyword">new</span> LambdaAnswer&lt;String&gt;(false, (i, r) -&gt;
    <span class="hl-string">""</span> + i.getArguments()[<span class="hl-number">0</span>] + i.getArguments()[<span class="hl-number">0</span>])).when(foo).foo(anyString());
assertEquals(<span class="hl-string">"foofoo"</span>, foo.foo(<span class="hl-string">"foo"</span>));</pre>
<p>When using Java 7 or earlier:</p>
<pre class="programlisting">doAnswer(<span class="hl-keyword">new</span> LambdaAnswer&lt;String&gt;(true, <span class="hl-keyword">new</span> ValueToReturn&lt;String&gt;() {
    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">public</span> String apply(InvocationOnMock i, String r) {
        <span class="hl-keyword">return</span> r + r;
    }
})).when(foo).foo(anyString());</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="__rabbitlistenertest_and_rabbitlistenertestharness" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#__rabbitlistenertest_and_rabbitlistenertestharness"></a>3.4.3&nbsp;@RabbitListenerTest and RabbitListenerTestHarness</h3></div></div></div>
<p>Annotating one of your <code class="literal">@Configuration</code> classes with <code class="literal">@RabbitListenerTest</code> will cause the framework to replace the
standard <code class="literal">RabbitListenerAnnotationBeanPostProcessor</code> with a subclass <code class="literal">RabbitListenerTestHarness</code> (it will also enable
<code class="literal">@RabbitListener</code> detection via <code class="literal">@EnableRabbit</code>).</p>
<p>The <code class="literal">RabbitListenerTestHarness</code> enhances the listener in two ways - it wraps it in a <code class="literal">Mockito Spy</code>, enabling normal
<code class="literal">Mockito</code> stubbing and verification operations.
It can also add an <code class="literal">Advice</code> to the listener enabling access to the arguments, result and or exceptions thrown.
You can control which (or both) of these are enabled with attributes on the <code class="literal">@RabbitListenerTest</code>.
The latter is provided for access to lower-level data about the invocation - it also supports blocking the test
thread until the async listener is called.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./Spring AMQP_files/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p><code class="literal">final</code> <code class="literal">@RabbitListener</code> methods cannot be spied or advised; also, only listeners with an <code class="literal">id</code> attribute can
be spied or advised.</p>
</td></tr></tbody></table></div>
<p>Let’s take a look at some examples.</p>
<p>Using spy:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@RabbitListenerTest</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Config {

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> Listener listener() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> Listener();
    }

    ...

}

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Listener {

    <em><span class="hl-annotation" style="color: gray">@RabbitListener(id="foo", queues="#{queue1.name}")</span></em>
    <span class="hl-keyword">public</span> String foo(String foo) {
        <span class="hl-keyword">return</span> foo.toUpperCase();
    }

    <em><span class="hl-annotation" style="color: gray">@RabbitListener(id="bar", queues="#{queue2.name}")</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> foo(<em><span class="hl-annotation" style="color: gray">@Payload</span></em> String foo, <em><span class="hl-annotation" style="color: gray">@Header("amqp_receivedRoutingKey")</span></em> String rk) {
        ...
    }

}

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyTests {

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span class="hl-keyword">private</span> RabbitListenerTestHarness harness; <a name="CO3-1" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO3-1"></a><span><img src="./Spring AMQP_files/1.png" alt="1" border="0"></span>

    <em><span class="hl-annotation" style="color: gray">@Test</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testTwoWay() <span class="hl-keyword">throws</span> Exception {
        assertEquals(<span class="hl-string">"FOO"</span>, <span class="hl-keyword">this</span>.rabbitTemplate.convertSendAndReceive(<span class="hl-keyword">this</span>.queue1.getName(), <span class="hl-string">"foo"</span>));

        Listener listener = <span class="hl-keyword">this</span>.harness.getSpy(<span class="hl-string">"foo"</span>); <a name="CO3-2" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO3-2"></a><span><img src="./Spring AMQP_files/2.png" alt="2" border="0"></span>
        assertNotNull(listener);
        verify(listener).foo(<span class="hl-string">"foo"</span>);
    }

    <em><span class="hl-annotation" style="color: gray">@Test</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testOneWay() <span class="hl-keyword">throws</span> Exception {
        Listener listener = <span class="hl-keyword">this</span>.harness.getSpy(<span class="hl-string">"bar"</span>);
        assertNotNull(listener);

        LatchCountDownAndCallRealMethodAnswer answer = <span class="hl-keyword">new</span> LatchCountDownAndCallRealMethodAnswer(<span class="hl-number">2</span>); <a name="CO3-3" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO3-3"></a><span><img src="./Spring AMQP_files/3.png" alt="3" border="0"></span>
        doAnswer(answer).when(listener).foo(anyString(), anyString()); <a name="CO3-4" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO3-4"></a><span><img src="./Spring AMQP_files/4.png" alt="4" border="0"></span>

        <span class="hl-keyword">this</span>.rabbitTemplate.convertAndSend(<span class="hl-keyword">this</span>.queue2.getName(), <span class="hl-string">"bar"</span>);
        <span class="hl-keyword">this</span>.rabbitTemplate.convertAndSend(<span class="hl-keyword">this</span>.queue2.getName(), <span class="hl-string">"baz"</span>);

        assertTrue(answer.getLatch().await(<span class="hl-number">10</span>, TimeUnit.SECONDS));
        verify(listener).foo(<span class="hl-string">"bar"</span>, <span class="hl-keyword">this</span>.queue2.getName());
        verify(listener).foo(<span class="hl-string">"baz"</span>, <span class="hl-keyword">this</span>.queue2.getName());
    }

}</pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr><td width="5%" valign="top" align="left"><p><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO3-1"><span><img src="./Spring AMQP_files/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Inject the harness into the test case so we can get access to the spy.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO3-2"><span><img src="./Spring AMQP_files/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Get a reference to the spy so we can verify it was invoked as expected.
Since this is a send and receive operation, there is no need to suspend the test thread because it was already
suspended in the <code class="literal">RabbitTemplate</code> waiting for the reply.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO3-3"><span><img src="./Spring AMQP_files/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left">
<p>In this case, we’re only using a send operation so we need a latch to wait for the asynchronous call to the listener
on the container thread.
We use one of the <a class="ulink" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#mockito-answer" target="_top">Answer&lt;?&gt;</a> implementations to help with that.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO3-4"><span><img src="./Spring AMQP_files/4.png" alt="4" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Configure the spy to invoke the <code class="literal">Answer</code>.</p>
</td></tr></tbody></table></div>
<p></p>
<p>Using the capture advice:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@ComponentScan</span></em>
<em><span class="hl-annotation" style="color: gray">@RabbitListenerTest(spy = false, capture = true)</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Config {

}

<em><span class="hl-annotation" style="color: gray">@Service</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Listener {

    <span class="hl-keyword">private</span> <span class="hl-keyword">boolean</span> failed;

    <em><span class="hl-annotation" style="color: gray">@RabbitListener(id="foo", queues="#{queue1.name}")</span></em>
    <span class="hl-keyword">public</span> String foo(String foo) {
        <span class="hl-keyword">return</span> foo.toUpperCase();
    }

    <em><span class="hl-annotation" style="color: gray">@RabbitListener(id="bar", queues="#{queue2.name}")</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> foo(<em><span class="hl-annotation" style="color: gray">@Payload</span></em> String foo, <em><span class="hl-annotation" style="color: gray">@Header("amqp_receivedRoutingKey")</span></em> String rk) {
        <span class="hl-keyword">if</span> (!failed &amp;&amp; foo.equals(<span class="hl-string">"ex"</span>)) {
            failed = true;
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> RuntimeException(foo);
        }
        failed = false;
    }

}

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyTests {

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span class="hl-keyword">private</span> RabbitListenerTestHarness harness; <a name="CO4-1" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO4-1"></a><span><img src="./Spring AMQP_files/1.png" alt="1" border="0"></span>

    <em><span class="hl-annotation" style="color: gray">@Test</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testTwoWay() <span class="hl-keyword">throws</span> Exception {
        assertEquals(<span class="hl-string">"FOO"</span>, <span class="hl-keyword">this</span>.rabbitTemplate.convertSendAndReceive(<span class="hl-keyword">this</span>.queue1.getName(), <span class="hl-string">"foo"</span>));

        InvocationData invocationData =
            <span class="hl-keyword">this</span>.harness.getNextInvocationDataFor(<span class="hl-string">"foo"</span>, <span class="hl-number">0</span>, TimeUnit.SECONDS); <a name="CO4-2" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO4-2"></a><span><img src="./Spring AMQP_files/2.png" alt="2" border="0"></span>
        assertThat(invocationData.getArguments()[<span class="hl-number">0</span>], equalTo(<span class="hl-string">"foo"</span>));     <a name="CO4-3" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO4-3"></a><span><img src="./Spring AMQP_files/3.png" alt="3" border="0"></span>
        assertThat((String) invocationData.getResult(), equalTo(<span class="hl-string">"FOO"</span>));
    }

    <em><span class="hl-annotation" style="color: gray">@Test</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testOneWay() <span class="hl-keyword">throws</span> Exception {
        <span class="hl-keyword">this</span>.rabbitTemplate.convertAndSend(<span class="hl-keyword">this</span>.queue2.getName(), <span class="hl-string">"bar"</span>);
        <span class="hl-keyword">this</span>.rabbitTemplate.convertAndSend(<span class="hl-keyword">this</span>.queue2.getName(), <span class="hl-string">"baz"</span>);
        <span class="hl-keyword">this</span>.rabbitTemplate.convertAndSend(<span class="hl-keyword">this</span>.queue2.getName(), <span class="hl-string">"ex"</span>);

        InvocationData invocationData =
            <span class="hl-keyword">this</span>.harness.getNextInvocationDataFor(<span class="hl-string">"bar"</span>, <span class="hl-number">10</span>, TimeUnit.SECONDS); <a name="CO4-4" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO4-4"></a><span><img src="./Spring AMQP_files/4.png" alt="4" border="0"></span>
        Object[] args = invocationData.getArguments();
        assertThat((String) args[<span class="hl-number">0</span>], equalTo(<span class="hl-string">"bar"</span>));
        assertThat((String) args[<span class="hl-number">1</span>], equalTo(queue2.getName()));

        invocationData = <span class="hl-keyword">this</span>.harness.getNextInvocationDataFor(<span class="hl-string">"bar"</span>, <span class="hl-number">10</span>, TimeUnit.SECONDS);
        args = invocationData.getArguments();
        assertThat((String) args[<span class="hl-number">0</span>], equalTo(<span class="hl-string">"baz"</span>));

        invocationData = <span class="hl-keyword">this</span>.harness.getNextInvocationDataFor(<span class="hl-string">"bar"</span>, <span class="hl-number">10</span>, TimeUnit.SECONDS);
        args = invocationData.getArguments();
        assertThat((String) args[<span class="hl-number">0</span>], equalTo(<span class="hl-string">"ex"</span>));
        assertEquals(<span class="hl-string">"ex"</span>, invocationData.getThrowable().getMessage()); <a name="CO4-5" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO4-5"></a><span><img src="./Spring AMQP_files/5.png" alt="5" border="0"></span>
    }

}</pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr><td width="5%" valign="top" align="left"><p><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO4-1"><span><img src="./Spring AMQP_files/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Inject the harness into the test case so we can get access to the spy.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO4-2"><span><img src="./Spring AMQP_files/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Use <code class="literal">harness.getNextInvocationDataFor()</code> to retrieve the invocation data - in this case since it was a request/reply
scenario there is no need to wait for any time because the test thread was suspended in the <code class="literal">RabbitTemplate</code> waiting
for the result.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO4-3"><span><img src="./Spring AMQP_files/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left">
<p>We can then verify that the argument and result was as expected.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO4-4"><span><img src="./Spring AMQP_files/4.png" alt="4" border="0"></span></a> </p></td><td valign="top" align="left">
<p>This time we need some time to wait for the data, since it’s an async operation on the container thread and we need
to suspend the test thread.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#CO4-5"><span><img src="./Spring AMQP_files/5.png" alt="5" border="0"></span></a> </p></td><td valign="top" align="left">
<p>When the listener throws an exception, it is available in the <code class="literal">throwable</code> property of the invocation data.</p>
</td></tr></tbody></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="junit-rules" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#junit-rules"></a>3.4.4&nbsp;JUnit @Rules</h3></div></div></div>
<p>Spring AMQP <span class="emphasis"><em>version 1.7</em></span> provides an additional jar <code class="literal">spring-rabbit-junit</code>; this jar contains a couple of utility <code class="literal">@Rule</code> s for use when running JUnit tests.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_brokerrunning" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_brokerrunning"></a>BrokerRunning</h4></div></div></div>
<p><code class="literal">BrokerRunning</code> provides a mechanism to allow tests to succeed when a broker is not running (on <code class="literal">localhost</code>, by default).</p>
<p>It also has utility methods to initialize/empty queues, and delete queues and exchanges.</p>
<p>Usage:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@ClassRule</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> BrokerRunning brokerRunning = BrokerRunning.isRunningWithEmptyQueues(<span class="hl-string">"foo"</span>, <span class="hl-string">"bar"</span>);

<em><span class="hl-annotation" style="color: gray">@AfterClass</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> tearDown() {
    brokerRunning.removeTestQueues(<span class="hl-string">"some.other.queue.too"</span>) <span class="hl-comment">// removes foo, bar as well</span>
}</pre>
<p>There are several <code class="literal">isRunning...</code> static methods such as <code class="literal">isBrokerAndManagementRunning()</code> which verifies the broker has the management plugin enabled.</p>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_configuring_the_rule" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_configuring_the_rule"></a>Configuring the Rule</h5></div></div></div>
<p>There are times when you want tests to fail if there is no broker, such as a nightly CI build.
To disable the rule at runtime, set an environment variable <code class="literal">RABBITMQ_SERVER_REQUIRED</code> to <code class="literal">true</code>.</p>
<p>You can override the broker properties, such as hostname in several ways:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Setters
</li></ul></div>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@ClassRule</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> BrokerRunning brokerRunning = BrokerRunning.isRunningWithEmptyQueues(<span class="hl-string">"foo"</span>, <span class="hl-string">"bar"</span>);

<span class="hl-keyword">static</span> {
    brokerRunning.setHostName(<span class="hl-string">"10.0.0.1"</span>)
}

<em><span class="hl-annotation" style="color: gray">@AfterClass</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> tearDown() {
    brokerRunning.removeTestQueues(<span class="hl-string">"some.other.queue.too"</span>) <span class="hl-comment">// removes foo, bar as well</span>
}</pre>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Environment Variables
</li></ul></div>
<p>The following environment variables are provided:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String BROKER_ADMIN_URI = <span class="hl-string">"RABBITMQ_TEST_ADMIN_URI"</span>;
<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String BROKER_HOSTNAME = <span class="hl-string">"RABBITMQ_TEST_HOSTNAME"</span>;
<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String BROKER_PORT = <span class="hl-string">"RABBITMQ_TEST_PORT"</span>;
<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String BROKER_USER = <span class="hl-string">"RABBITMQ_TEST_USER"</span>;
<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String BROKER_PW = <span class="hl-string">"RABBITMQ_TEST_PASSWORD"</span>;
<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String BROKER_ADMIN_USER = <span class="hl-string">"RABBITMQ_TEST_ADMIN_USER"</span>;
<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String BROKER_ADMIN_PW = <span class="hl-string">"RABBITMQ_TEST_ADMIN_PASSWORD"</span>;</pre>
<p>These will override the default settings (<code class="literal">localhost:5672</code> for amqp and <code class="literal">http://localhost:15672/api/</code> for the management REST API).</p>
<p>Changing the host name affects both the amqp and management REST API connection (unless the admin uri is explicitly set).</p>
<p><code class="literal">BrokerRunning</code> also provides a <code class="literal">static</code> method: <code class="literal">setEnvironmentVariableOverrides</code> where you can pass in a map containing these variables; they override system environment variables.
This might be useful if you wish to use different configuration for tests in multiple test suites.
IMPORTANT: The method must be called before invoking any of the <code class="literal">isRunning()</code> static methods that create the rule instance.
Variable values will be applied to all instances created after this.
Invoke <code class="literal">clearEnvironmentVariableOverrides()</code> to reset the rule to use defaults (including any actual environment variables).</p>
<p>In your test cases, you can use those properties when creating the connection factory:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> ConnectionFactory rabbitConnectionFactory() {
    CachingConnectionFactory connectionFactory = <span class="hl-keyword">new</span> CachingConnectionFactory();
    connectionFactory.setHost(brokerRunning.getHostName());
    connectionFactory.setPort(brokerRunning.getPort());
    connectionFactory.setUsername(brokerRunning.getUser());
    connectionFactory.setPassword(brokerRunning.getPassword());
    <span class="hl-keyword">return</span> connectionFactory;
}</pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_longrunningintegrationtest" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_longrunningintegrationtest"></a>LongRunningIntegrationTest</h4></div></div></div>
<p><code class="literal">LongRunningIntegrationTest</code> is a rule that disables long running tests; you might want to use this on a developer system but ensure that the rule is disabled on, for example, nightly CI builds.</p>
<p>Usage:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Rule</span></em>
<span class="hl-keyword">public</span> LongRunningIntegrationTest longTests = <span class="hl-keyword">new</span> LongRunningIntegrationTest();</pre>
<p>To disable the rule at runtime, set an environment variable <code class="literal">RUN_LONG_INTEGRATION_TESTS</code> to <code class="literal">true</code>.</p>
</div>
</div>
</div>
</div>
<div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="_spring_integration_reference" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_spring_integration_reference"></a>4.&nbsp;Spring Integration - Reference</h1></div></div></div>
<p>This part of the reference documentation provides a quick introduction to the AMQP support within the Spring Integration project.</p>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring-integration-amqp" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#spring-integration-amqp"></a>4.1&nbsp;Spring Integration AMQP Support</h2></div></div></div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="spring-integration-amqp-introduction" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#spring-integration-amqp-introduction"></a>4.1.1&nbsp;Introduction</h3></div></div></div>
<p>The <a class="ulink" href="http://www.springsource.org/spring-integration" target="_top">Spring Integration</a> project includes AMQP Channel Adapters and Gateways that build upon the Spring AMQP project.
Those adapters are developed and released in the Spring Integration project.
In Spring Integration, "Channel Adapters" are unidirectional (one-way) whereas "Gateways" are bidirectional (request-reply).
We provide an inbound-channel-adapter, outbound-channel-adapter, inbound-gateway, and outbound-gateway.</p>
<p>Since the AMQP adapters are part of the Spring Integration release, the documentation will be available as part of the Spring Integration distribution.
As a taster, we just provide a quick overview of the main features here.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_inbound_channel_adapter" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_inbound_channel_adapter"></a>4.1.2&nbsp;Inbound Channel Adapter</h3></div></div></div>
<p>To receive AMQP Messages from a Queue, configure an &lt;inbound-channel-adapter&gt;</p>
<pre class="programlisting"><span class="hl-tag">&lt;amqp:inbound-channel-adapter</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"fromAMQP"</span>
                              <span class="hl-attribute">queue-names</span>=<span class="hl-value">"some.queue"</span>
                              <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"rabbitConnectionFactory"</span><span class="hl-tag">/&gt;</span></pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_outbound_channel_adapter" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_outbound_channel_adapter"></a>4.1.3&nbsp;Outbound Channel Adapter</h3></div></div></div>
<p>To send AMQP Messages to an Exchange, configure an &lt;outbound-channel-adapter&gt;.
A <span class="emphasis"><em>routing-key</em></span> may optionally be provided in addition to the exchange name.</p>
<pre class="programlisting"><span class="hl-tag">&lt;amqp:outbound-channel-adapter</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"toAMQP"</span>
                               <span class="hl-attribute">exchange-name</span>=<span class="hl-value">"some.exchange"</span>
                               <span class="hl-attribute">routing-key</span>=<span class="hl-value">"foo"</span>
                               <span class="hl-attribute">amqp-template</span>=<span class="hl-value">"rabbitTemplate"</span><span class="hl-tag">/&gt;</span></pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_inbound_gateway" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_inbound_gateway"></a>4.1.4&nbsp;Inbound Gateway</h3></div></div></div>
<p>To receive an AMQP Message from a Queue, and respond to its reply-to address, configure an &lt;inbound-gateway&gt;.</p>
<pre class="programlisting"><span class="hl-tag">&lt;amqp:inbound-gateway</span> <span class="hl-attribute">request-channel</span>=<span class="hl-value">"fromAMQP"</span>
                      <span class="hl-attribute">reply-channel</span>=<span class="hl-value">"toAMQP"</span>
                      <span class="hl-attribute">queue-names</span>=<span class="hl-value">"some.queue"</span>
                      <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"rabbitConnectionFactory"</span><span class="hl-tag">/&gt;</span></pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_outbound_gateway" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_outbound_gateway"></a>4.1.5&nbsp;Outbound Gateway</h3></div></div></div>
<p>To send AMQP Messages to an Exchange and receive back a response from a remote client, configure an &lt;outbound-gateway&gt;.
A <span class="emphasis"><em>routing-key</em></span> may optionally be provided in addition to the exchange name.</p>
<pre class="programlisting"><span class="hl-tag">&lt;amqp:outbound-gateway</span> <span class="hl-attribute">request-channel</span>=<span class="hl-value">"toAMQP"</span>
                       <span class="hl-attribute">reply-channel</span>=<span class="hl-value">"fromAMQP"</span>
                       <span class="hl-attribute">exchange-name</span>=<span class="hl-value">"some.exchange"</span>
                       <span class="hl-attribute">routing-key</span>=<span class="hl-value">"foo"</span>
                       <span class="hl-attribute">amqp-template</span>=<span class="hl-value">"rabbitTemplate"</span><span class="hl-tag">/&gt;</span></pre>
</div>
</div>
</div>
<div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="resources" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#resources"></a>5.&nbsp;Other Resources</h1></div></div></div>
<p>In addition to this reference documentation, there exist a number of other resources that may help you learn about AMQP.</p>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="further-reading" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#further-reading"></a>5.1&nbsp;Further Reading</h2></div></div></div>
<p>For those who are not familiar with AMQP, the <a class="ulink" href="http://www.amqp.org/resources/download" target="_top">specification</a> is actually quite readable.
It is of course the authoritative source of information, and the Spring AMQP code should be very easy to understand for anyone who is familiar with the spec.
Our current implementation of the RabbitMQ support is based on their 2.8.x version, and it officially supports AMQP 0.8 and 0.9.1.
We recommend reading the 0.9.1 document.</p>
<p>There are many great articles, presentations, and blogs available on the RabbitMQ <a class="ulink" href="https://www.rabbitmq.com/how.html" target="_top">Getting Started</a> page.
Since that is currently the only supported implementation for Spring AMQP, we also recommend that as a general starting point for all broker-related concerns.</p>
</div>
</div>
<div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a name="_change_history" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_change_history"></a>Appendix&nbsp;A.&nbsp;Change History</h1></div></div></div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_current_release" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_current_release"></a>A.1&nbsp;Current Release</h2></div></div></div>
<p>See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#whats-new" title="2.2 What’s New">Section&nbsp;2.2, “What’s New”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="previous-whats-new" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#previous-whats-new"></a>A.2&nbsp;Previous Releases</h2></div></div></div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_changes_in_1_6_since_1_5" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_changes_in_1_6_since_1_5"></a>A.2.1&nbsp;Changes in 1.6 Since 1.5</h3></div></div></div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_testing_support" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_testing_support"></a>Testing Support</h4></div></div></div>
<p>A new testing support library is now provided.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#testing" title="3.4 Testing Support">Section&nbsp;3.4, “Testing Support”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_builder" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_builder"></a>Builder</h4></div></div></div>
<p>Builders are now available providing a fluent API for configuring <code class="literal">Queue</code> and <code class="literal">Exchange</code> objects.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#builder-api" title="Builder API for Queues and Exchanges">the section called “Builder API for Queues and Exchanges”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_namespace_changes" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_namespace_changes"></a>Namespace Changes</h4></div></div></div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_connection_factory" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_connection_factory"></a>Connection Factory</h5></div></div></div>
<p>It is now possible to add a <code class="literal">thread-factory</code> to a connection factory bean declaration, for example to name the threads
created by the <code class="literal">amqp-client</code> library.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#connections" title="3.1.2 Connection and Resource Management">Section&nbsp;3.1.2, “Connection and Resource Management”</a> for more information.</p>
<p>When using <code class="literal">CacheMode.CONNECTION</code>, you can now limit the total number of connections allowed.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#connections" title="3.1.2 Connection and Resource Management">Section&nbsp;3.1.2, “Connection and Resource Management”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_queue_definitions" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_queue_definitions"></a>Queue Definitions</h5></div></div></div>
<p>It is now possible to provide a naming strategy for anonymous queues; see <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#anonymous-queue" title="AnonymousQueue">the section called “AnonymousQueue”</a> for more information.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_listener_container_changes_2" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_listener_container_changes_2"></a>Listener Container Changes</h4></div></div></div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_idle_message_listener_detection" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_idle_message_listener_detection"></a>Idle Message Listener Detection</h5></div></div></div>
<p>It is now possible to configure listener containers to publish <code class="literal">ApplicationEvent</code> s when idle.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#idle-containers" title="Detecting Idle Asynchronous Consumers">the section called “Detecting Idle Asynchronous Consumers”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_mismatched_queue_detection" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_mismatched_queue_detection"></a>Mismatched Queue Detection</h5></div></div></div>
<p>By default, when a listener container starts, if queues with mismatched properties or arguments were detected,
the container would log the exception but continue to listen.
The container now has a property <code class="literal">mismatchedQueuesFatal</code> which will prevent the container (and context) from
starting if the problem is detected during startup.
It will also stop the container if the problem is detected later, such as after recovering from a connection failure.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#containerAttributes" title="3.1.15 Message Listener Container Configuration">Section&nbsp;3.1.15, “Message Listener Container Configuration”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_listener_container_logging" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_listener_container_logging"></a>Listener Container Logging</h5></div></div></div>
<p>Now listener container provides its <code class="literal">beanName</code> into the internal <code class="literal">SimpleAsyncTaskExecutor</code> as a <code class="literal">threadNamePrefix</code>.
It is useful for logs analysis.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_default_error_handler" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_default_error_handler"></a>Default Error Handler</h5></div></div></div>
<p>The default error handler (<code class="literal">ConditionalRejectingErrorHandler</code>) now considers irrecoverable <code class="literal">@RabbitListener</code>
exceptions as fatal.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#exception-handling" title="3.1.13 Exception Handling">Section&nbsp;3.1.13, “Exception Handling”</a> for more information.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_autodeclare_and_rabbitadmins" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_autodeclare_and_rabbitadmins"></a>AutoDeclare and RabbitAdmins</h4></div></div></div>
<p>See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#containerAttributes" title="3.1.15 Message Listener Container Configuration">Section&nbsp;3.1.15, “Message Listener Container Configuration”</a> (<code class="literal">autoDeclare</code>) for some changes to the semantics of that option with respect to the use
of <code class="literal">RabbitAdmin</code> s in the application context.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_amqptemplate_receive_with_timeout" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_amqptemplate_receive_with_timeout"></a>AmqpTemplate: receive with timeout</h4></div></div></div>
<p>A number of new <code class="literal">receive()</code> methods with <code class="literal">timeout</code> have been introduced for the <code class="literal">AmqpTemplate</code>
and its <code class="literal">RabbitTemplate</code> implementation.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#polling-consumer" title="Polling Consumer">the section called “Polling Consumer”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_asyncrabbittemplate" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_asyncrabbittemplate"></a>AsyncRabbitTemplate</h4></div></div></div>
<p>A new <code class="literal">AsyncRabbitTemplate</code> has been introduced.
This template provides a number of send and receive methods, where the return value is a <code class="literal">ListenableFuture</code>, which can
be used later to obtain the result either synchronously, or asynchronously.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#async-template" title="AsyncRabbitTemplate">the section called “AsyncRabbitTemplate”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_rabbittemplate_changes" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbittemplate_changes"></a>RabbitTemplate Changes</h4></div></div></div>
<p>1.4.1 introduced the ability to use <a class="ulink" href="https://www.rabbitmq.com/direct-reply-to.html" target="_top">Direct reply-to</a> when the broker
supports it; it is more efficient than using a temporary queue for each reply.
This version allows you to override this default behavior and use a temporary queue by setting the
<code class="literal">useTemporaryReplyQueues</code> property to <code class="literal">true</code>.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#direct-reply-to" title="RabbitMQ Direct reply-to">the section called “RabbitMQ Direct reply-to”</a> for more information.</p>
<p>The <code class="literal">RabbitTemplate</code> now supports a <code class="literal">user-id-expression</code> (<code class="literal">userIdExpression</code> when using Java configuration).
See <a class="ulink" href="https://www.rabbitmq.com/validated-user-id.html" target="_top">Validated User-ID RabbitMQ documentation</a> and <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#template-user-id" title="Validated User Id">the section called “Validated User Id”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_message_properties" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_message_properties"></a>Message Properties</h4></div></div></div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_correlationid" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_correlationid"></a>CorrelationId</h5></div></div></div>
<p>The <code class="literal">correlationId</code> message property can now be a <code class="literal">String</code>.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#message-properties-converters" title="Message Properties Converters">the section called “Message Properties Converters”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_long_string_headers" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_long_string_headers"></a>Long String Headers</h5></div></div></div>
<p>Previously, the <code class="literal">DefaultMessagePropertiesConverter</code> "converted" headers longer than the long string limit (default 1024)
to a <code class="literal">DataInputStream</code> (actually it just referenced the <code class="literal">LongString</code>'s <code class="literal">DataInputStream</code>).
On output, this header was not converted (except to a String, e.g. <code class="literal">java.io.DataInputStream@1d057a39</code> by calling
<code class="literal">toString()</code> on the stream).</p>
<p>With this release, long <code class="literal">LongString</code> s are now left as <code class="literal">LongString</code> s by default; you can access the contents via
the <code class="literal">getBytes[]</code>, <code class="literal">toString()</code>, or <code class="literal">getStream()</code> methods.
A large incoming <code class="literal">LongString</code> is now correctly "converted" on output too.</p>
<p>See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#message-properties-converters" title="Message Properties Converters">the section called “Message Properties Converters”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_inbound_delivery_mode" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_inbound_delivery_mode"></a>Inbound Delivery Mode</h5></div></div></div>
<p>The <code class="literal">deliveryMode</code> property is no longer mapped to the <code class="literal">MessageProperties.deliveryMode</code>; this is to avoid unintended
propagation if the the same <code class="literal">MessageProperties</code> object is used to send an outbound message.
Instead, the inbound <code class="literal">deliveryMode</code> header is mapped to <code class="literal">MessageProperties.receivedDeliveryMode</code>.</p>
<p>See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#message-properties-converters" title="Message Properties Converters">the section called “Message Properties Converters”</a> for more information.</p>
<p>When using annotated endpoints, the header is provided in the header named <code class="literal">AmqpHeaders.RECEIVED_DELIVERY_MODE</code>.</p>
<p>See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#async-annotation-driven-enable-signature" title="Annotated Endpoint Method Signature">the section called “Annotated Endpoint Method Signature”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_inbound_user_id" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_inbound_user_id"></a>Inbound User ID</h5></div></div></div>
<p>The <code class="literal">user_id</code> property is no longer mapped to the <code class="literal">MessageProperties.userId</code>; this is to avoid unintended
propagation if the the same <code class="literal">MessageProperties</code> object is used to send an outbound message.
Instead, the inbound <code class="literal">userId</code> header is mapped to <code class="literal">MessageProperties.receivedUserId</code>.</p>
<p>See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#message-properties-converters" title="Message Properties Converters">the section called “Message Properties Converters”</a> for more information.</p>
<p>When using annotated endpoints, the header is provided in the header named <code class="literal">AmqpHeaders.RECEIVED_USER_ID</code>.</p>
<p>See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#async-annotation-driven-enable-signature" title="Annotated Endpoint Method Signature">the section called “Annotated Endpoint Method Signature”</a> for more information.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_rabbitadmin_changes" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbitadmin_changes"></a>RabbitAdmin Changes</h4></div></div></div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_declaration_failures" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_declaration_failures"></a>Declaration Failures</h5></div></div></div>
<p>Previously, the <code class="literal">ignoreDeclarationFailures</code> flag only took effect for <code class="literal">IOException</code> on the channel (such as mis-matched
arguments).
It now takes effect for any exception (such as <code class="literal">TimeoutException</code>).
In addition, a <code class="literal">DeclarationExceptionEvent</code> is now published whenever a declaration fails.
The <code class="literal">RabbitAdmin</code> last declaration event is also available as a property <code class="literal">lastDeclarationExceptionEvent</code>.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#broker-configuration" title="3.1.10 Configuring the broker">Section&nbsp;3.1.10, “Configuring the broker”</a> for more information.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="__rabbitlistener_changes" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#__rabbitlistener_changes"></a>@RabbitListener Changes</h4></div></div></div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_multiple_containers_per_bean" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_multiple_containers_per_bean"></a>Multiple Containers per Bean</h5></div></div></div>
<p>When using Java 8 or later, it is now possible to add multiple <code class="literal">@RabbitListener</code> annotations to <code class="literal">@Bean</code> classes or
their methods.
When using Java 7 or earlier, you can use the <code class="literal">@RabbitListeners</code> container annotation to provide the same
functionality.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#repeatable-rabbit-listener" title="@Repeatable @RabbitListener">the section called “@Repeatable @RabbitListener”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="__sendto_spel_expressions" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#__sendto_spel_expressions"></a>@SendTo SpEL Expressions</h5></div></div></div>
<p><code class="literal">@SendTo</code> for routing replies with no <code class="literal">replyTo</code> property can now be SpEL expressions evaluated against the
request/reply.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#async-annotation-driven-reply" title="Reply Management">the section called “Reply Management”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="__queuebinding_improvements" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#__queuebinding_improvements"></a>@QueueBinding Improvements</h5></div></div></div>
<p>You can now specify arguments for queues, exchanges and bindings in <code class="literal">@QueueBinding</code> annotations.
Header exchanges are now supported by <code class="literal">@QueueBinding</code>.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#async-annotation-driven" title="Annotation-driven Listener Endpoints">the section called “Annotation-driven Listener Endpoints”</a> for more information.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_delayed_message_exchange" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_delayed_message_exchange"></a>Delayed Message Exchange</h4></div></div></div>
<p>Spring AMQP now has first class support for the RabbitMQ Delayed Message Exchange plugin.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#delayed-message-exchange" title="3.1.11 Delayed Message Exchange">Section&nbsp;3.1.11, “Delayed Message Exchange”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_exchange_internal_flag" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_exchange_internal_flag"></a>Exchange internal flag</h4></div></div></div>
<p>Any <code class="literal">Exchange</code> definitions can now be marked as <code class="literal">internal</code> and the <code class="literal">RabbitAdmin</code> will pass the value to the broker when
declaring the exchange.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#broker-configuration" title="3.1.10 Configuring the broker">Section&nbsp;3.1.10, “Configuring the broker”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_cachingconnectionfactory_changes" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_cachingconnectionfactory_changes"></a>CachingConnectionFactory Changes</h4></div></div></div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_cachingconnectionfactory_cache_statistics" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_cachingconnectionfactory_cache_statistics"></a>CachingConnectionFactory Cache Statistics</h5></div></div></div>
<p>The <code class="literal">CachingConnectionFactory</code> now provides cache properties at runtime and over JMX.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#runtime-cache-properties" title="Runtime Cache Properties">the section called “Runtime Cache Properties”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_access_the_underlying_rabbitmq_connection_factory" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_access_the_underlying_rabbitmq_connection_factory"></a>Access the Underlying RabbitMQ Connection Factory</h5></div></div></div>
<p>A new getter has been added to provide access to the underlying factory.
This can be used, for example, to add custom connection properties.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#custom-client-props" title="3.1.3 Adding Custom Client Connection Properties">Section&nbsp;3.1.3, “Adding Custom Client Connection Properties”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_channel_cache" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_channel_cache"></a>Channel Cache</h5></div></div></div>
<p>The default channel cache size has been increased from 1 to 25.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#connections" title="3.1.2 Connection and Resource Management">Section&nbsp;3.1.2, “Connection and Resource Management”</a> for more information.</p>
<p>In addition, the <code class="literal">SimpleMessageListenerContainer</code> no longer adjusts the cache size to be at least as large as the number
of <code class="literal">concurrentConsumers</code> - this was superfluous, since the container consumer channels are never cached.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_rabbitconnectionfactorybean" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbitconnectionfactorybean"></a>RabbitConnectionFactoryBean</h4></div></div></div>
<p>The factory bean now exposes a property to add client connection properties to connections made by the resulting
factory.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_java_deserialization" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_java_deserialization"></a>Java Deserialization</h4></div></div></div>
<p>A "white list" of allowable classes can now be configured when using Java deserialization.
It is important to consider creating a white list if you accept messages with serialized java objects from
untrusted sources.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#java-deserialization" title="Java Deserialization">the section called “Java Deserialization”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_json_messageconverter" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_json_messageconverter"></a>JSON MessageConverter</h4></div></div></div>
<p>Improvements to the JSON message converter now allow the consumption of messages that don’t have type information
in message headers.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#async-annotation-conversion" title="Message Conversion for Annotated Methods">the section called “Message Conversion for Annotated Methods”</a> and <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#json-message-converter" title="Jackson2JsonMessageConverter">the section called “Jackson2JsonMessageConverter”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_logging_appenders" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_logging_appenders"></a>Logging Appenders</h4></div></div></div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_log4j2" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_log4j2"></a>Log4j2</h5></div></div></div>
<p>A log4j2 appender has been added, and the appenders can now be configured with an <code class="literal">addresses</code> property to connect
to a broker cluster.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_client_connection_properties" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_client_connection_properties"></a>Client Connection Properties</h5></div></div></div>
<p>You can now add custom client connection properties to RabbitMQ connections.</p>
<p>See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#logging" title="3.2 Logging Subsystem AMQP Appenders">Section&nbsp;3.2, “Logging Subsystem AMQP Appenders”</a> for more information.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_rabbittemplate_changes_2" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbittemplate_changes_2"></a>RabbitTemplate Changes</h4></div></div></div>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./Spring AMQP_files/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Previously, a non-transactional <code class="literal">RabbitTemplate</code> participated in an existing transaction if it ran on a transactional listener container thread.
This was a serious bug; however, users might have relied on this behavior.
Starting with <span class="emphasis"><em>version 1.6.2</em></span>, you must set the <code class="literal">channelTransacted</code> boolean on the template for it to participate in the container transaction.</p>
</td></tr></tbody></table></div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_changes_in_1_5_since_1_4" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_changes_in_1_5_since_1_4"></a>A.2.2&nbsp;Changes in 1.5 Since 1.4</h3></div></div></div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_spring_erlang_is_no_longer_supported" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_spring_erlang_is_no_longer_supported"></a>spring-erlang is No Longer Supported</h4></div></div></div>
<p>The <code class="literal">spring-erlang</code> jar is no longer included in the distribution.
Use <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#management-template" title="3.1.12 RabbitMQ REST API">Section&nbsp;3.1.12, “RabbitMQ REST API”</a> instead.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_cachingconnectionfactory_changes_2" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_cachingconnectionfactory_changes_2"></a>CachingConnectionFactory Changes</h4></div></div></div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_empty_addresses_property_in_cachingconnectionfactory" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_empty_addresses_property_in_cachingconnectionfactory"></a>Empty Addresses Property in CachingConnectionFactory</h5></div></div></div>
<p>Previously, if the connection factory was configured with a host/port, but an empty String was also supplied for
<code class="literal">addresses</code>, the host and port were ignored.
Now, an empty <code class="literal">addresses</code> String is treated the same as a <code class="literal">null</code>, and the host/port will be used.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_uri_constructor" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_uri_constructor"></a>URI Constructor</h5></div></div></div>
<p>The <code class="literal">CachingConnectionFactory</code> has an additional constructor, with a <code class="literal">URI</code> parameter, to configure the broker connection.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_connection_reset" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_connection_reset"></a>Connection Reset</h5></div></div></div>
<p>A new method <code class="literal">resetConnection()</code> has been added to allow users to reset the connection (or connections).
This might be used, for example, to reconnect to the primary broker after failing over to the secondary broker.
This <span class="strong"><strong>will</strong></span> impact in-process operations.
The existing <code class="literal">destroy()</code> method does exactly the same, but the new method has a less daunting name.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_properties_to_control_container_queue_declaration_behavior" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_properties_to_control_container_queue_declaration_behavior"></a>Properties to Control Container Queue Declaration Behavior</h4></div></div></div>
<p>When the listener container consumers start, they attempt to passively declare the queues to ensure they are available
on the broker.
Previously, if these declarations failed, for example because the queues didn’t exist, or when an HA queue was being
moved, the retry logic was fixed at 3 retry attempts at 5 second intervals.
If the queue(s) still do not exist, the behavior is controlled by the <code class="literal">missingQueuesFatal</code> property (default true).
Also, for containers configured to listen from multiple queues, if only a subset of queues are available, the consumer
retried the missing queues on a fixed interval of 60 seconds.</p>
<p>These 3 properties (<code class="literal">declarationRetries, failedDeclarationRetryInterval,
retryDeclarationInterval</code>) are now configurable.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#containerAttributes" title="3.1.15 Message Listener Container Configuration">Section&nbsp;3.1.15, “Message Listener Container Configuration”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_class_package_change" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_class_package_change"></a>Class Package Change</h4></div></div></div>
<p>The <code class="literal">RabbitGatewaySupport</code> class has been moved from <code class="literal">o.s.amqp.rabbit.core.support</code> to <code class="literal">o.s.amqp.rabbit.core</code>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_defaultmessagepropertiesconverter" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_defaultmessagepropertiesconverter"></a>DefaultMessagePropertiesConverter</h4></div></div></div>
<p>The <code class="literal">DefaultMessagePropertiesConverter</code> can now be configured to
determine the maximum length of a <code class="literal">LongString</code> that will be converted
to a <code class="literal">String</code> rather than a <code class="literal">DataInputStream</code>.
The converter has an alternative constructor that takes the value as a limit.
Previously, this limit was hard-coded at <code class="literal">1024</code> bytes.
(Also available in <span class="emphasis"><em>1.4.4</em></span>).</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="__rabbitlistener_improvements" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#__rabbitlistener_improvements"></a>@RabbitListener Improvements</h4></div></div></div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="__queuebinding_for_rabbitlistener" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#__queuebinding_for_rabbitlistener"></a>@QueueBinding for @RabbitListener</h5></div></div></div>
<p>The <code class="literal">bindings</code> attribute has been added to the <code class="literal">@RabbitListener</code> annotation as mutually exclusive with the <code class="literal">queues</code>
attribute to allow the specification of the <code class="literal">queue</code>, its <code class="literal">exchange</code> and <code class="literal">binding</code> for declaration by a <code class="literal">RabbitAdmin</code> on
the Broker.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_spel_in_sendto" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_spel_in_sendto"></a>SpEL in @SendTo</h5></div></div></div>
<p>The default reply address (<code class="literal">@SendTo</code>) for a <code class="literal">@RabbitListener</code> can now be a SpEL expression.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_multiple_queue_names_via_properties" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_multiple_queue_names_via_properties"></a>Multiple Queue Names Via Properties</h5></div></div></div>
<p>It is now possible to use a combination of SpEL and property placeholders to specify multiple queues for a listener.</p>
<p>See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#async-annotation-driven" title="Annotation-driven Listener Endpoints">the section called “Annotation-driven Listener Endpoints”</a> for more information.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_automatic_exchange_queue_binding_declaration" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_automatic_exchange_queue_binding_declaration"></a>Automatic Exchange, Queue, Binding Declaration</h4></div></div></div>
<p>It is now possible to declare beans that define a collection of these entities and the <code class="literal">RabbitAdmin</code> will add the
contents to the list of entities that it will declare when a connection is established.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#collection-declaration" title="Declaring Collections of Exchanges, Queues, Bindings">the section called “Declaring Collections of Exchanges, Queues, Bindings”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_rabbittemplate_changes_3" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbittemplate_changes_3"></a>RabbitTemplate Changes</h4></div></div></div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_reply_address" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_reply_address"></a>reply-address</h5></div></div></div>
<p>The <code class="literal">reply-address</code> attribute has been added to the <code class="literal">&lt;rabbit-template&gt;</code> component as an alternative <code class="literal">reply-queue</code>.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#request-reply" title="3.1.9 Request/Reply Messaging">Section&nbsp;3.1.9, “Request/Reply Messaging”</a> for more information.
(Also available in <span class="emphasis"><em>1.4.4</em></span> as a setter on the <code class="literal">RabbitTemplate</code>).</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_blocking_receive_methods" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_blocking_receive_methods"></a>Blocking Receive Methods</h5></div></div></div>
<p>The <code class="literal">RabbitTemplate</code> now supports blocking in <code class="literal">receive</code> and <code class="literal">convertAndReceive</code> methods.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#polling-consumer" title="Polling Consumer">the section called “Polling Consumer”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_mandatory_with_sendandreceive_methods" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_mandatory_with_sendandreceive_methods"></a>Mandatory with SendAndReceive Methods</h5></div></div></div>
<p>When the <code class="literal">mandatory</code> flag is set when using <code class="literal">sendAndReceive</code> and <code class="literal">convertSendAndReceive</code> methods, the calling thread
will throw an <code class="literal">AmqpMessageReturnedException</code> if the request message can’t be deliverted.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#reply-timeout" title="Reply Timeout">the section called “Reply Timeout”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_improper_reply_listener_configuration" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_improper_reply_listener_configuration"></a>Improper Reply Listener Configuration</h5></div></div></div>
<p>The framework will attempt to verify proper configuration of a reply listener container when using a named
reply queue.</p>
<p>See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#reply-listener" title="Reply Listener Container">the section called “Reply Listener Container”</a> for more information.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_the_rabbitmanagementtemplate" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_the_rabbitmanagementtemplate"></a>The RabbitManagementTemplate</h4></div></div></div>
<p>The <code class="literal">RabbitManagementTemplate</code> has been introduced to monitor and configure the RabbitMQ Broker using the REST API
provided by its <a class="ulink" href="https://www.rabbitmq.com/management.html" target="_top">Management Plugin</a>.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#management-template" title="3.1.12 RabbitMQ REST API">Section&nbsp;3.1.12, “RabbitMQ REST API”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_listener_container_bean_names_xml" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_listener_container_bean_names_xml"></a>Listener Container Bean Names (XML)</h4></div></div></div>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./Spring AMQP_files/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>The <code class="literal">id</code> attribute on the <code class="literal">&lt;listener-container/&gt;</code> element has been removed.
Starting with this release, the <code class="literal">id</code> on the <code class="literal">&lt;listener/&gt;</code> child element is used alone to name the listener container
bean created for each listener element.</p>
<p>Normal Spring bean name overrides are applied; if a later <code class="literal">&lt;listener/&gt;</code> is parsed with the same <code class="literal">id</code> as an existing
bean, the new definition will override the existing one.
Previously, bean names were composed from the ids of the <code class="literal">&lt;listener-container/&gt;</code> and <code class="literal">&lt;listener/&gt;</code> elements.</p>
<p>When migrating to this release, if you have <code class="literal">id</code> s on your <code class="literal">&lt;listener-container/&gt;</code> elements, remove them and set the
<code class="literal">id</code> on the child <code class="literal">&lt;listener/&gt;</code> element instead.</p>
</td></tr></tbody></table></div>
<p>However, to support starting/stopping containers as a group, a new <code class="literal">group</code> attribute has been added.
When this attribute is defined, the containers created by this element are added to a bean with this name, of type
<code class="literal">Collection&lt;SimpleMessageListenerContainer</code>.
You can iterate over this group to start/stop containers.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_class_level_rabbitlistener" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_class_level_rabbitlistener"></a>Class-Level @RabbitListener</h4></div></div></div>
<p>The <code class="literal">@RabbitListener</code> annotation can now be applied at the class level.
Together with the new <code class="literal">@RabbitHandler</code> method annotation, this allows the handler method to be selected based on payload
type. See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#annotation-method-selection" title="Multi-Method Listeners">the section called “Multi-Method Listeners”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_simplemessagelistenercontainer_backoff_support" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_simplemessagelistenercontainer_backoff_support"></a>SimpleMessageListenerContainer: BackOff support</h4></div></div></div>
<p>The <code class="literal">SimpleMessageListenerContainer</code> can now be supplied with a <code class="literal">BackOff</code> instance for <code class="literal">consumer</code> startup recovery.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#containerAttributes" title="3.1.15 Message Listener Container Configuration">Section&nbsp;3.1.15, “Message Listener Container Configuration”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_channel_close_logging" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_channel_close_logging"></a>Channel Close Logging</h4></div></div></div>
<p>A mechanism to control the log levels of channel closure has been introduced.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#channel-close-logging" title="Logging Channel Close Events">the section called “Logging Channel Close Events”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_application_events" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_application_events"></a>Application Events</h4></div></div></div>
<p>The <code class="literal">SimpleMessageListenerContainer</code> now emits application events when consumers fail.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#consumer-events" title="Consumer Events">the section called “Consumer Events”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_consumer_tag_configuration" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_consumer_tag_configuration"></a>Consumer Tag Configuration</h4></div></div></div>
<p>Previously, the consumer tags for asynchronous consumers were generated by the broker.
With this release, it is now possible to supply a naming strategy to the listener container.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#consumerTags" title="Consumer Tags">the section called “Consumer Tags”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_messagelisteneradapter" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_messagelisteneradapter"></a>MessageListenerAdapter</h4></div></div></div>
<p>The <code class="literal">MessageListenerAdapter</code> now supports a map of queue names (or consumer tags) to method names, to determine
which delegate method to call based on the queue the message was received from.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_localizedqueueconnectionfactory" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_localizedqueueconnectionfactory"></a>LocalizedQueueConnectionFactory</h4></div></div></div>
<p>A new connection factory that connects to the node in a cluster where a mirrored queue actually resides.</p>
<p>See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#queue-affinity" title="Queue Affinity and the LocalizedQueueConnectionFactory">the section called “Queue Affinity and the LocalizedQueueConnectionFactory”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_anonymous_queue_naming" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_anonymous_queue_naming"></a>Anonymous Queue Naming</h4></div></div></div>
<p>Starting with <span class="emphasis"><em>version 1.5.3</em></span>, you can now control how <code class="literal">AnonymousQueue</code> names are generated.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#anonymous-queue" title="AnonymousQueue">the section called “AnonymousQueue”</a> for more information.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_changes_in_1_4_since_1_3" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_changes_in_1_4_since_1_3"></a>A.2.3&nbsp;Changes in 1.4 Since 1.3</h3></div></div></div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="__rabbitlistener_annotation" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#__rabbitlistener_annotation"></a>@RabbitListener Annotation</h4></div></div></div>
<p>POJO listeners can be annotated with <code class="literal">@RabbitListener</code>, enabled by <code class="literal">@EnableRabbit</code> or <code class="literal">&lt;rabbit:annotation-driven /&gt;</code>.
Spring Framework 4.1 is required for this feature.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#async-annotation-driven" title="Annotation-driven Listener Endpoints">the section called “Annotation-driven Listener Endpoints”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_rabbitmessagingtemplate" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbitmessagingtemplate"></a>RabbitMessagingTemplate</h4></div></div></div>
<p>A new <code class="literal">RabbitMessagingTemplate</code> is provided to allow users to interact with RabbitMQ using <code class="literal">spring-messaging</code> <code class="literal">Message`s.
It uses the `RabbitTemplate</code> internally which can be configured as normal.
Spring Framework 4.1 is required for this feature.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#template-messaging" title="Messaging integration">the section called “Messaging integration”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_listener_container_emphasis_missing_queues_fatal_emphasis_attribute" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_listener_container_emphasis_missing_queues_fatal_emphasis_attribute"></a>Listener Container <span class="emphasis"><em>Missing Queues Fatal</em></span> Attribute</h4></div></div></div>
<p>1.3.5 introduced the <code class="literal">missingQueuesFatal</code> property on the <code class="literal">SimpleMessageListenerContainer</code>.
This is now available on the listener container namespace element.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#containerAttributes" title="3.1.15 Message Listener Container Configuration">Section&nbsp;3.1.15, “Message Listener Container Configuration”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_rabbittemplate_emphasis_confirmcallback_emphasis_interface" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbittemplate_emphasis_confirmcallback_emphasis_interface"></a>RabbitTemplate <span class="emphasis"><em>ConfirmCallback</em></span> Interface</h4></div></div></div>
<p>The <code class="literal">confirm</code> method on this interface has an additional parameter <code class="literal">cause</code>.
When available, this parameter will contain the reason for a negative acknowledgement (nack).
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#template-confirms" title="Publisher Confirms and Returns">the section called “Publisher Confirms and Returns”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_rabbitconnectionfactorybean_2" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbitconnectionfactorybean_2"></a>RabbitConnectionFactoryBean</h4></div></div></div>
<p>A factory bean is now provided to create the underlying RabbitMQ <code class="literal">ConnectionFactory</code> used by the <code class="literal">CachingConnectionFactory</code>.
This enables configuration of SSL options using Spring’s dependency injection.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#connection-factory" title="Configuring the Underlying Client Connection Factory">the section called “Configuring the Underlying Client Connection Factory”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_cachingconnectionfactory" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_cachingconnectionfactory"></a>CachingConnectionFactory</h4></div></div></div>
<p>The <code class="literal">CachingConnectionFactory</code> now allows the <code class="literal">connectionTimeout</code> to be set as a property or as an attribute in the namespace.
It sets the property on the underlying RabbitMQ <code class="literal">ConnectionFactory</code> See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#connection-factory" title="Configuring the Underlying Client Connection Factory">the section called “Configuring the Underlying Client Connection Factory”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_log_appender" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_log_appender"></a>Log Appender</h4></div></div></div>
<p>The Logback <code class="literal">org.springframework.amqp.rabbit.logback.AmqpAppender</code> has been introduced.
It provides similar options like <code class="literal">org.springframework.amqp.rabbit.log4j.AmqpAppender</code>.
For more info see JavaDocs of these classes.</p>
<p>The Log4j <code class="literal">AmqpAppender</code> now supports the <code class="literal">deliveryMode</code> property (<code class="literal">PERSISTENT</code> or <code class="literal">NON_PERSISTENT</code>, default: <code class="literal">PERSISTENT</code>).
Previously, all log4j messages were PERSISTENT.</p>
<p>The appender also supports modification of the <code class="literal">Message</code> before sending - allowing, for example, the addition of custom headers.
Subclasses should override the <code class="literal">postProcessMessageBeforeSend()</code>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_listener_queues" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_listener_queues"></a>Listener Queues</h4></div></div></div>
<p>The listener container now, by default, redeclares any missing queues during startup.
A new <code class="literal">auto-declare</code> attribute has been added to the <code class="literal">&lt;rabbit:listener-container&gt;</code> to prevent these redeclarations.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#lc-auto-delete" title="auto-delete Queues">the section called “<span class="emphasis"><em>auto-delete</em></span> Queues”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_rabbittemplate_mandatory_and_connectionfactoryselector_expressions" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbittemplate_mandatory_and_connectionfactoryselector_expressions"></a>RabbitTemplate: mandatory and connectionFactorySelector Expressions</h4></div></div></div>
<p>The <code class="literal">mandatoryExpression</code> and <code class="literal">sendConnectionFactorySelectorExpression</code> and <code class="literal">receiveConnectionFactorySelectorExpression</code> SpEL <code class="literal">Expression`s properties have been added to the `RabbitTemplate</code>.
The <code class="literal">mandatoryExpression</code> is used to evaluate a <code class="literal">mandatory</code> boolean value against each request message, when a <code class="literal">ReturnCallback</code> is in use.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#template-confirms" title="Publisher Confirms and Returns">the section called “Publisher Confirms and Returns”</a>.
The <code class="literal">sendConnectionFactorySelectorExpression</code> and <code class="literal">receiveConnectionFactorySelectorExpression</code> are used when an <code class="literal">AbstractRoutingConnectionFactory</code> is provided, to determine the <code class="literal">lookupKey</code> for the target <code class="literal">ConnectionFactory</code> at runtime on each AMQP protocol interaction operation.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#routing-connection-factory" title="Routing Connection Factory">the section called “Routing Connection Factory”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_listeners_and_the_routing_connection_factory" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_listeners_and_the_routing_connection_factory"></a>Listeners and the Routing Connection Factory</h4></div></div></div>
<p>A <code class="literal">SimpleMessageListenerContainer</code> can be configured with a routing connection factory to enable connection selection based on the queue names.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#routing-connection-factory" title="Routing Connection Factory">the section called “Routing Connection Factory”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_rabbittemplate_recoverycallback_option" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbittemplate_recoverycallback_option"></a>RabbitTemplate: RecoveryCallback option</h4></div></div></div>
<p>The <code class="literal">recoveryCallback</code> property has been added to be used in the <code class="literal">retryTemplate.execute()</code>.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#template-retry" title="Adding Retry Capabilities">the section called “Adding Retry Capabilities”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_messageconversionexception" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_messageconversionexception"></a>MessageConversionException</h4></div></div></div>
<p>This exception is now a subclass of <code class="literal">AmqpException</code>; if you have code like the following:</p>
<pre class="programlisting"><span class="hl-keyword">try</span> {
    template.convertAndSend(<span class="hl-string">"foo"</span>, <span class="hl-string">"bar"</span>, <span class="hl-string">"baz"</span>);
}
<span class="hl-keyword">catch</span> (AmqpException e) {
	...
}
<span class="hl-keyword">catch</span> (MessageConversionException e) {
	...
}</pre>
<p>The second catch block will no longer be reachable and needs to be moved above the catch-all <code class="literal">AmqpException</code> catch block.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_rabbitmq_3_4_compatibility" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbitmq_3_4_compatibility"></a>RabbitMQ 3.4 Compatibility</h4></div></div></div>
<p>Spring AMQP is now compatible with the <span class="strong"><strong>RabbitMQ 3.4</strong></span>, including direct reply-to; see <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#compatibility" title="Compatibility">the section called “Compatibility”</a> and <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#direct-reply-to" title="RabbitMQ Direct reply-to">the section called “RabbitMQ Direct reply-to”</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_contenttypedelegatingmessageconverter_2" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_contenttypedelegatingmessageconverter_2"></a>ContentTypeDelegatingMessageConverter</h4></div></div></div>
<p>The <code class="literal">ContentTypeDelegatingMessageConverter</code> has been introduced to select the <code class="literal">MessageConverter</code> to use, based on the <code class="literal">contentType</code> property in the <code class="literal">MessageProperties</code>.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#message-converters" title="3.1.7 Message Converters">Section&nbsp;3.1.7, “Message Converters”</a> for more information.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_changes_in_1_3_since_1_2" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_changes_in_1_3_since_1_2"></a>A.2.4&nbsp;Changes in 1.3 Since 1.2</h3></div></div></div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_listener_concurrency" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_listener_concurrency"></a>Listener Concurrency</h4></div></div></div>
<p>The listener container now supports dynamic scaling of the number of consumers based on workload, or the concurrency can be programmatically changed without stopping the container.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#listener-concurrency" title="3.1.16 Listener Concurrency">Section&nbsp;3.1.16, “Listener Concurrency”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_listener_queues_2" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_listener_queues_2"></a>Listener Queues</h4></div></div></div>
<p>The listener container now permits the queue(s) on which it is listening to be modified at runtime.
Also, the container will now start if at least one of its configured queues is available for use.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#listener-queues" title="3.1.18 Listener Container Queues">Section&nbsp;3.1.18, “Listener Container Queues”</a></p>
<p>This listener container will now redeclare any auto-delete queues during startup.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#lc-auto-delete" title="auto-delete Queues">the section called “<span class="emphasis"><em>auto-delete</em></span> Queues”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_consumer_priority" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_consumer_priority"></a>Consumer Priority</h4></div></div></div>
<p>The listener container now supports consumer arguments, allowing the <code class="literal">x-priority</code> argument to be set.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#consumer-priority">the section called “Container”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_exclusive_consumer" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_exclusive_consumer"></a>Exclusive Consumer</h4></div></div></div>
<p>The <code class="literal">SimpleMessageListenerContainer</code> can now be configured with a single <code class="literal">exclusive</code> consumer, preventing other consumers from listening to the queue.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#exclusive-consumer" title="3.1.17 Exclusive Consumer">Section&nbsp;3.1.17, “Exclusive Consumer”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_rabbit_admin" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbit_admin"></a>Rabbit Admin</h4></div></div></div>
<p>It is now possible to have the Broker generate the queue name, regardless of durable, autoDelete and exclusive settings.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#broker-configuration" title="3.1.10 Configuring the broker">Section&nbsp;3.1.10, “Configuring the broker”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_direct_exchange_binding" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_direct_exchange_binding"></a>Direct Exchange Binding</h4></div></div></div>
<p>Previously, omitting the <code class="literal">key</code> attribute from a <code class="literal">binding</code> element of a <code class="literal">direct-exchange</code> configuration caused the queue or exchange to be bound with an empty string as the routing key.
Now it is bound with the the name of the provided <code class="literal">Queue</code> or <code class="literal">Exchange</code>.
Users wishing to bind with an empty string routing key need to specify <code class="literal">key=""</code>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_amqp_template" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_amqp_template"></a>AMQP Template</h4></div></div></div>
<p>The <code class="literal">AmqpTemplate</code> now provides several synchronous <code class="literal">receiveAndReply</code> methods.
These are implemented by the <code class="literal">RabbitTemplate</code>.
For more information see <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#receiving-messages" title="3.1.6 Receiving messages">Section&nbsp;3.1.6, “Receiving messages”</a>.</p>
<p>The <code class="literal">RabbitTemplate</code> now supports configuring a <code class="literal">RetryTemplate</code> to attempt retries (with optional back off policy) for when the broker is not available.
For more information see <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#template-retry" title="Adding Retry Capabilities">the section called “Adding Retry Capabilities”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_caching_connection_factory" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_caching_connection_factory"></a>Caching Connection Factory</h4></div></div></div>
<p>The caching connection factory can now be configured to cache `Connection`s and their `Channel`s instead of using a single connection and caching just `Channel`s.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#connections" title="3.1.2 Connection and Resource Management">Section&nbsp;3.1.2, “Connection and Resource Management”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_binding_arguments" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_binding_arguments"></a>Binding Arguments</h4></div></div></div>
<p>The <code class="literal">&lt;exchange&gt;</code>'s <code class="literal">&lt;binding&gt;</code> now supports parsing of the <code class="literal">&lt;binding-arguments&gt;</code> sub-element.
The <code class="literal">&lt;headers-exchange&gt;</code>'s <code class="literal">&lt;binding&gt;</code> now can be configured with a <code class="literal">key/value</code> attribute pair (to match on a single header) or with a <code class="literal">&lt;binding-arguments&gt;</code> sub-element, allowing matching on multiple headers; these options are mutually exclusive.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#headers-exchange">the section called “Introduction”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_routing_connection_factory" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_routing_connection_factory"></a>Routing Connection Factory</h4></div></div></div>
<p>A new <code class="literal">SimpleRoutingConnectionFactory</code> has been introduced, to allow configuration of <code class="literal">ConnectionFactories</code> mapping to determine the target <code class="literal">ConnectionFactory</code> to use at runtime.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#routing-connection-factory" title="Routing Connection Factory">the section called “Routing Connection Factory”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_messagebuilder_and_messagepropertiesbuilder" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_messagebuilder_and_messagepropertiesbuilder"></a>MessageBuilder and MessagePropertiesBuilder</h4></div></div></div>
<p>"Fluent APIs" for building messages and/or message properties is now provided.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#message-builder" title="Message Builder API">the section called “Message Builder API”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_retryinterceptorbuilder" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_retryinterceptorbuilder"></a>RetryInterceptorBuilder</h4></div></div></div>
<p>A "Fluent API" for building listener container retry interceptors is now provided.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#retry" title="Failures in Synchronous Operations and Options for Retry">the section called “Failures in Synchronous Operations and Options for Retry”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_republishmessagerecoverer" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_republishmessagerecoverer"></a>RepublishMessageRecoverer</h4></div></div></div>
<p>This new <code class="literal">MessageRecoverer</code> is provided to allow publishing a failed message to another queue (including stack trace information in the header) when retries are exhausted.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#async-listeners" title="Message Listeners and the Asynchronous Case">the section called “Message Listeners and the Asynchronous Case”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_default_error_handler_since_1_3_2" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_default_error_handler_since_1_3_2"></a>Default Error Handler (Since 1.3.2)</h4></div></div></div>
<p>A default <code class="literal">ConditionalRejectingErrorHandler</code> has been added to the listener container.
This error handler detects message conversion problems (which are fatal) and instructs the container to reject the message to prevent the broker from continually redelivering the unconvertible message.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#exception-handling" title="3.1.13 Exception Handling">Section&nbsp;3.1.13, “Exception Handling”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_listener_container_missingqueuesfatal_property_since_1_3_5" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_listener_container_missingqueuesfatal_property_since_1_3_5"></a>Listener Container 'missingQueuesFatal` Property (Since 1.3.5)</h4></div></div></div>
<p>The <code class="literal">SimpleMessageListenerContainer</code> now has a property <code class="literal">missingQueuesFatal</code> (default <code class="literal">true</code>).
Previously, missing queues were always fatal.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#containerAttributes" title="3.1.15 Message Listener Container Configuration">Section&nbsp;3.1.15, “Message Listener Container Configuration”</a>.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_changes_to_1_2_since_1_1" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_changes_to_1_2_since_1_1"></a>A.2.5&nbsp;Changes to 1.2 Since 1.1</h3></div></div></div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_rabbitmq_version" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbitmq_version"></a>RabbitMQ Version</h4></div></div></div>
<p>Spring AMQP now using RabbitMQ 3.1.x by default (but retains compatibility with earlier versions).
Certain deprecations have been added for features no longer supported by RabbitMQ 3.1.x - federated exchanges and the <code class="literal">immediate</code> property on the <code class="literal">RabbitTemplate</code>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_rabbit_admin_2" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbit_admin_2"></a>Rabbit Admin</h4></div></div></div>
<p>The <code class="literal">RabbitAdmin</code> now provides an option to allow exchange, queue, and binding declarations to continue when a declaration fails.
Previously, all declarations stopped on a failure.
By setting <code class="literal">ignore-declaration-exceptions</code>, such exceptions are logged (WARN), but further declarations continue.
An example where this might be useful is when a queue declaration fails because of a slightly different <code class="literal">ttl</code> setting would normally stop other declarations from proceeding.</p>
<p>The <code class="literal">RabbitAdmin</code> now provides an additional method <code class="literal">getQueueProperties()</code>.
This can be used to determine if a queue exists on the broker (returns null for a non-existent queue).
In addition, the current number of messages in the queue, as well as the current number of consumers is returned.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_rabbit_template" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_rabbit_template"></a>Rabbit Template</h4></div></div></div>
<p>Previously, when using the <code class="literal">...sendAndReceive()</code> methods were used with a fixed reply queue, two custom headers were used for correlation data and to retain/restore reply queue information.
With this release, the standard message property <code class="literal">correlationId</code> is used by default, although the user can specifiy a custom property to use instead.
In addition, nested <code class="literal">replyTo</code> information is now retained internally in the template, instead of using a custom header.</p>
<p>The <code class="literal">immediate</code> property is deprecated; users must not set this property when using RabbitMQ 3.0.x or greater.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_json_message_converters" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_json_message_converters"></a>JSON Message Converters</h4></div></div></div>
<p>A Jackson 2.x <code class="literal">MessageConverter</code> is now provided, along with the existing converter that uses Jackson 1.x.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_automatic_declaration_of_queues_etc" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_automatic_declaration_of_queues_etc"></a>Automatic Declaration of Queues, etc</h4></div></div></div>
<p>Previously, when declaring queues, exchanges and bindings, it was not possible to define which connection factory was used for the declarations, each <code class="literal">RabbitAdmin</code> would declare all components using its connection.</p>
<p>Starting with this release, it is now possible to limit declarations to specific <code class="literal">RabbitAdmin</code> instances.
See <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#conditional-declaration" title="Conditional Declaration">the section called “Conditional Declaration”</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_amqp_remoting" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_amqp_remoting"></a>AMQP Remoting</h4></div></div></div>
<p>Facilities are now provided for using Spring Remoting techniques, using AMQP as the transport for the RPC calls.
For more information see <a class="xref" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#remoting" title="Spring Remoting with AMQP">the section called “Spring Remoting with AMQP”</a></p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_requested_heart_beats" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_requested_heart_beats"></a>Requested Heart Beats</h4></div></div></div>
<p>Several users have asked for the underlying client connection factory’s <code class="literal">requestedHeartBeats</code> property to be exposed on the Spring AMQP <code class="literal">CachingConnectionFactory</code>.
This is now available; previously, it was necessary to configure the AMQP client factory as a separate bean and provide a reference to it in the <code class="literal">CachingConnectionFactory</code>.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_changes_to_1_1_since_1_0" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_changes_to_1_1_since_1_0"></a>A.2.6&nbsp;Changes to 1.1 Since 1.0</h3></div></div></div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_general" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_general"></a>General</h4></div></div></div>
<p>Spring-AMQP is now built using gradle.</p>
<p>Adds support for publisher confirms and returns.</p>
<p>Adds support for HA queues, and broker failover.</p>
<p>Adds support for Dead Letter Exchanges/Dead Letter Queues.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_amqp_log4j_appender" href="https://docs.spring.io/spring-amqp/docs/1.7.8.RELEASE/reference/htmlsingle/#_amqp_log4j_appender"></a>AMQP Log4j Appender</h4></div></div></div>
<p>Adds an option to support adding a message id to logged messages.</p>
<p>Adds an option to allow the specification of a <code class="literal">Charset</code> name to be used when converting <code class="literal">String`s to `byte[]</code>.</p>
</div>
</div>
</div>
</div>
</div><script async="" src="./Spring AMQP_files/analytics.js.&#19979;&#36733;"></script><script>if(window.parent==window){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-2728886-23','auto',{'siteSpeedSampleRate':100});ga('send','pageview');}</script></body></html>